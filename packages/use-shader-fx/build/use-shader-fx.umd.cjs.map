{"version":3,"file":"use-shader-fx.umd.cjs","sources":["../src/hooks/useBrush/shader/main.vert","../src/hooks/useBrush/shader/main.frag","../src/utils/useResolution.ts","../src/utils/useAddMesh.ts","../src/utils/setUniforms.ts","../src/hooks/useBrush/useMesh.ts","../src/utils/useCamera.ts","../src/utils/useSingleFBO.ts","../src/utils/useDoubleFBO.ts","../src/utils/usePointer.ts","../src/utils/useParams.ts","../src/hooks/useBrush/index.ts","../src/hooks/useDuoTone/shader/main.vert","../src/hooks/useDuoTone/shader/main.frag","../src/hooks/useDuoTone/useMesh.ts","../src/hooks/useDuoTone/index.ts","../src/hooks/useFogProjection/shader/main.vert","../src/hooks/useFogProjection/shader/main.frag","../src/hooks/useFogProjection/useMesh.ts","../src/hooks/useFogProjection/index.ts","../src/hooks/useFruid/shaders/main.vert","../src/hooks/useFruid/shaders/init.frag","../src/hooks/useFruid/materials/useInitialMaterial.ts","../src/hooks/useFruid/shaders/advection.frag","../src/hooks/useFruid/materials/useAdvectionMaterial.ts","../src/hooks/useFruid/shaders/divergence.frag","../src/hooks/useFruid/materials/useDivergenceMaterial.ts","../src/hooks/useFruid/shaders/pressure.frag","../src/hooks/useFruid/materials/usePressureMaterial.ts","../src/hooks/useFruid/shaders/curl.frag","../src/hooks/useFruid/materials/useCurlMaterial.ts","../src/hooks/useFruid/shaders/vorticity.frag","../src/hooks/useFruid/materials/useVorticityMaterial.ts","../src/hooks/useFruid/shaders/clear.frag","../src/hooks/useFruid/materials/useClearMaterial.ts","../src/hooks/useFruid/shaders/gradientSubtract.frag","../src/hooks/useFruid/materials/useGradientSubtractMaterial.ts","../src/hooks/useFruid/shaders/splat.frag","../src/hooks/useFruid/materials/useSplatMaterial.ts","../src/hooks/useFruid/useMesh.ts","../src/hooks/useFruid/index.ts","../src/hooks/useRipple/useMesh.ts","../src/hooks/useRipple/index.ts","../src/hooks/useTransitionBg/shader/main.vert","../src/hooks/useTransitionBg/shader/main.frag","../src/hooks/useTransitionBg/useMesh.ts","../src/hooks/useTransitionBg/index.ts","../src/hooks/useNoise/shader/main.vert","../src/hooks/useNoise/shader/main.frag","../src/hooks/useNoise/useMesh.ts","../src/hooks/useNoise/index.ts"],"sourcesContent":["varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nuniform sampler2D uMap;\nuniform sampler2D uTexture;\nuniform float uRadius;\nuniform float uDissipation;\nuniform vec2 uResolution;\nuniform float uSmudge;\nuniform float uAspect;\nuniform vec2 uMouse;\nuniform vec2 uPrevMouse;\nuniform vec2 uVelocity;\nuniform vec3 uColor;\nuniform float uMotionBlur;\nuniform int uMotionSample;\n\nvarying vec2 vUv;\n\nfloat isOnLine(vec2 point, vec2 start, vec2 end, float width, float aspect) {\n\t// make circle\n\tpoint.x *= aspect;\n\tstart.x *= aspect;\n\tend.x *= aspect;\n\n\t// unit vector in direction\n\tvec2 dir = normalize(end - start);\n\t\n\t// unit vector perpendicular to the line segment\n\tvec2 n = vec2(dir.y, -dir.x);\n\n\tvec2 p0 = point - start;\n\t\n\t// calculate distance on a line\n\tfloat distToLine = abs(dot(p0, n));\n\tfloat distAlongLine = dot(p0, dir);\n\tfloat totalLength = length(end - start);\n\n\t// Include the radius of the circle at the start and end points in the range\n\tfloat distFromStart = length(point - start);\n\tfloat distFromEnd = length(point - end);\n\t\n\tbool withinLine = (distToLine < width && distAlongLine > 0.0 && distAlongLine < totalLength) || distFromStart < width || distFromEnd < width;\n\n\treturn float(withinLine);\n}\n\nvec4 createSmudge(){\n\tvec2 offsets[9];\n\toffsets[0] = vec2(-1, -1); offsets[1] = vec2( 0, -1); offsets[2] = vec2( 1, -1);\n\toffsets[3] = vec2(-1,  0); offsets[4] = vec2( 0,  0); offsets[5] = vec2( 1,  0);\n\toffsets[6] = vec2(-1,  1); offsets[7] = vec2( 0,  1); offsets[8] = vec2( 1,  1);\n\t// Scale offset to texture size\n\tfor(int i = 0; i < 9; i++) {\n\t\toffsets[i] = (offsets[i] * uSmudge) / uResolution;\n\t}\t\n\tvec4 smudgedColor = vec4(0.0);\n\tfor(int i = 0; i < 9; i++) {\n\t\tsmudgedColor += texture2D(uMap, vUv + offsets[i]);\n\t}\n\treturn smudgedColor / 9.0;\n}\n\nvec4 createMotionBlur(vec4 baseColor, vec2 velocity, float motion, int samples) {\n\tvec4 motionBlurredColor = baseColor;\n\tvec2 scaledVelocity = velocity * motion;\n\tfor(int i = 1; i < samples; i++) {\n\t\tfloat t = float(i) / float(samples - 1);\n\t\tvec2 offset = t * scaledVelocity / uResolution;\n\t\tmotionBlurredColor += texture2D(uMap, vUv + offset);\n\t}\n\treturn motionBlurredColor / float(samples);\n}\n\n\nvoid main() {\n\t// Convert UV coordinates to range [-1, 1]\n\tvec2 st = vUv * 2.0 - 1.0;\n\t\n\t// velocity vector\n\tvec2 velocity = uVelocity * uResolution;\n\n\t// add smudge\n\tvec4 smudgedColor = createSmudge();\n\t\n\t// add motion blur\n\tvec4 motionBlurredColor = createMotionBlur(smudgedColor, velocity, uMotionBlur,uMotionSample);\n\n\tvec4 bufferColor = motionBlurredColor * uDissipation;\n\n\t// radius\n\tfloat modifiedRadius = max(0.0,uRadius);\n\n\t//\tcolor \n\tvec3 color = uColor;\n\n\t// map texture to color\n\tvec4 textureColor = texture2D(uTexture, vUv);\n\tvec3 finalColor = mix(color, textureColor.rgb, textureColor.a);\n\n\tfloat onLine = isOnLine(st, uPrevMouse, uMouse, modifiedRadius, uAspect);\n\tbufferColor.rgb = mix(bufferColor.rgb, finalColor, onLine);\n\t\n\tgl_FragColor = vec4(bufferColor.rgb,1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\n/**\n * @params dpr if dpr is set, it returns the resolution which is size multiplied by dpr.\n */\nexport const useResolution = (size: Size, dpr: number | false = false) => {\n   const _width = dpr ? size.width * dpr : size.width;\n   const _height = dpr ? size.height * dpr : size.height;\n   const resolution = useMemo(\n      () => new THREE.Vector2(_width, _height),\n      [_width, _height]\n   );\n   return resolution;\n};\n","import * as THREE from \"three\";\nimport { useEffect, useMemo } from \"react\";\n\n/** Generate mesh from geometry and material and add to scene */\nexport const useAddMesh = (\n   scene: THREE.Scene,\n   geometry: THREE.PlaneGeometry,\n   material: THREE.Material\n) => {\n   const mesh = useMemo(\n      () => new THREE.Mesh(geometry, material),\n      [geometry, material]\n   );\n\n   useEffect(() => {\n      scene.add(mesh);\n   }, [scene, mesh]);\n\n   useEffect(() => {\n      return () => {\n         scene.remove(mesh);\n         geometry.dispose();\n         material.dispose();\n      };\n   }, [scene, geometry, material, mesh]);\n\n   return mesh;\n};\n","type UniformValue =\n   | THREE.CubeTexture\n   | THREE.Texture\n   | Int32Array\n   | Float32Array\n   | THREE.Matrix4\n   | THREE.Matrix3\n   | THREE.Quaternion\n   | THREE.Vector4\n   | THREE.Vector3\n   | THREE.Vector2\n   | THREE.Color\n   | number\n   | boolean\n   | Array<any>\n   | null;\ntype UniformObject = { [key: string]: { value: UniformValue } };\n\nexport const setUniform = <T extends UniformObject>(\n   material: { uniforms: T },\n   key: keyof T,\n   value: UniformValue\n) => {\n   if (\n      material.uniforms &&\n      material.uniforms[key] &&\n      value !== undefined &&\n      value !== null\n   ) {\n      material.uniforms[key].value = value;\n   } else {\n      console.error(\n         `Uniform key \"${String(\n            key\n         )}\" does not exist in the material. or \"${String(\n            key\n         )}\" is null | undefined`\n      );\n   }\n};\n","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useEffect, useMemo } from \"react\";\nimport { useResolution } from \"../../utils/useResolution\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TUniforms = {\n   uMap: { value: THREE.Texture };\n   uResolution: { value: THREE.Texture };\n   uAspect: { value: number };\n   uTexture: { value: THREE.Texture };\n   uRadius: { value: number };\n   uSmudge: { value: number };\n   uDissipation: { value: number };\n   uMotionBlur: { value: number };\n   uMotionSample: { value: number };\n   uMouse: { value: number };\n   uPrevMouse: { value: number };\n   uVelocity: { value: number };\n   uColor: { value: THREE.Color };\n};\n\nexport class BrushMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uMap: { value: new THREE.Texture() },\n               uResolution: { value: new THREE.Vector2(0, 0) },\n               uAspect: { value: 0.0 },\n               uTexture: { value: new THREE.Texture() },\n               uRadius: { value: 0.0 },\n               uSmudge: { value: 0.0 },\n               uDissipation: { value: 0.0 },\n               uMotionBlur: { value: 0.0 },\n               uMotionSample: { value: 0 },\n               uMouse: { value: new THREE.Vector2(0, 0) },\n               uPrevMouse: { value: new THREE.Vector2(0, 0) },\n               uVelocity: { value: new THREE.Vector2(0, 0) },\n               uColor: { value: new THREE.Color(0xffffff) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(material, \"uAspect\", resolution.width / resolution.height);\n      setUniform(material, \"uResolution\", resolution.clone());\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material as BrushMaterial;\n};\n","import * as THREE from \"three\";\nimport { useResolution } from \"./useResolution\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\nconst getCameraProps = (width: number, height: number) => {\n   const frustumSize = height;\n   const aspect = width / height;\n   const [w, h] = [(frustumSize * aspect) / 2, frustumSize / 2];\n   return { width: w, height: h, near: -1000, far: 1000 };\n};\n\nexport const useCamera = (size: Size) => {\n   const resolution = useResolution(size);\n   const { width, height, near, far } = getCameraProps(\n      resolution.x,\n      resolution.y\n   );\n   const camera = useMemo(\n      () =>\n         new THREE.OrthographicCamera(\n            -width,\n            width,\n            height,\n            -height,\n            near,\n            far\n         ),\n      [width, height, near, far]\n   );\n   return camera;\n};\n","import * as THREE from \"three\";\nimport {\n   useCallback,\n   useEffect,\n   useLayoutEffect,\n   useMemo,\n   useRef,\n} from \"react\";\nimport { useResolution } from \"./useResolution\";\nimport { UseFboProps } from \"./types\";\n\nexport const FBO_OPTION = {\n   minFilter: THREE.LinearFilter,\n   magFilter: THREE.LinearFilter,\n   type: THREE.HalfFloatType,\n   depthBuffer: false,\n   stencilBuffer: false,\n};\n\ntype FBOUpdateFunction = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({ read }: { read: THREE.Texture }) => void\n) => THREE.Texture;\n\ntype Return = [THREE.WebGLRenderTarget, FBOUpdateFunction];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [THREE.WebGLRenderTarget , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useSingleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n}: UseFboProps): Return => {\n   const renderTarget = useRef<THREE.WebGLRenderTarget>();\n\n   const resolution = useResolution(size, dpr);\n   renderTarget.current = useMemo(\n      () => new THREE.WebGLRenderTarget(resolution.x, resolution.y, FBO_OPTION),\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      []\n   );\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current?.setSize(resolution.x, resolution.y);\n      }\n   }, [resolution, isSizeUpdate]);\n\n   useEffect(() => {\n      const currentRenderTarget = renderTarget.current;\n      return () => {\n         currentRenderTarget?.dispose();\n      };\n   }, []);\n\n   const updateRenderTarget: FBOUpdateFunction = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current!;\n         gl.setRenderTarget(fbo);\n         onBeforeRender && onBeforeRender({ read: fbo.texture });\n         gl.render(scene, camera);\n         gl.setRenderTarget(null);\n         gl.clear();\n         return fbo.texture;\n      },\n      [scene, camera]\n   );\n\n   return [renderTarget.current, updateRenderTarget];\n};\n","import * as THREE from \"three\";\nimport {\n   useCallback,\n   useEffect,\n   useLayoutEffect,\n   useMemo,\n   useRef,\n} from \"react\";\nimport { FBO_OPTION } from \"./useSingleFBO\";\nimport { useResolution } from \"./useResolution\";\nimport { DoubleRenderTarget, UseFboProps } from \"./types\";\n\ninterface RenderTarget extends DoubleRenderTarget {\n   swap: () => void;\n}\n\ntype FBOUpdateFunction = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({\n      read,\n      write,\n   }: {\n      read: THREE.Texture;\n      write: THREE.Texture;\n   }) => void\n) => THREE.Texture;\n\ntype Return = [\n   { read: THREE.WebGLRenderTarget; write: THREE.WebGLRenderTarget },\n   FBOUpdateFunction\n];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [{read:THREE.WebGLRenderTarget,write:THREE.WebGLRenderTarget} , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useDoubleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n}: UseFboProps): Return => {\n   const renderTarget = useRef<RenderTarget>({\n      read: null,\n      write: null,\n      swap: function () {\n         let temp = this.read;\n         this.read = this.write;\n         this.write = temp;\n      },\n   });\n\n   const resolution = useResolution(size, dpr);\n   const initRenderTargets = useMemo(() => {\n      const read = new THREE.WebGLRenderTarget(\n         resolution.x,\n         resolution.y,\n         FBO_OPTION\n      );\n      const write = new THREE.WebGLRenderTarget(\n         resolution.x,\n         resolution.y,\n         FBO_OPTION\n      );\n      return { read, write };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, []);\n   renderTarget.current.read = initRenderTargets.read;\n   renderTarget.current.write = initRenderTargets.write;\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current.read?.setSize(resolution.x, resolution.y);\n         renderTarget.current.write?.setSize(resolution.x, resolution.y);\n      }\n   }, [resolution, isSizeUpdate]);\n\n   useEffect(() => {\n      const currentRenderTarget = renderTarget.current;\n      return () => {\n         currentRenderTarget.read?.dispose();\n         currentRenderTarget.write?.dispose();\n      };\n   }, []);\n\n   const updateRenderTarget: FBOUpdateFunction = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current;\n         gl.setRenderTarget(fbo.write);\n         onBeforeRender &&\n            onBeforeRender({\n               read: fbo.read!.texture,\n               write: fbo.write!.texture,\n            });\n         gl.render(scene, camera);\n         fbo.swap();\n         gl.setRenderTarget(null);\n         gl.clear();\n         return fbo.read?.texture as THREE.Texture;\n      },\n      [scene, camera]\n   );\n\n   return [\n      { read: renderTarget.current.read, write: renderTarget.current.write },\n      updateRenderTarget,\n   ];\n};\n","import * as THREE from \"three\";\nimport { useCallback, useRef } from \"react\";\n\ntype UpdatePointer = (currentPointer: THREE.Vector2) => {\n   currentPointer: THREE.Vector2;\n   prevPointer: THREE.Vector2;\n   diffPointer: THREE.Vector2;\n   velocity: THREE.Vector2;\n   isVelocityUpdate: boolean;\n};\n\n/** When given the pointer vector2 from r3f's RootState, it generates an update function that returns {currentPointer, prevPointer, diffPointer, isVelocityUpdate, velocity}. */\nexport const usePointer = (): UpdatePointer => {\n   const prevPointer = useRef(new THREE.Vector2(0, 0));\n   const diffPointer = useRef(new THREE.Vector2(0, 0));\n   const lastUpdateTime = useRef<number>(0);\n   const velocity = useRef(new THREE.Vector2(0, 0));\n   const isMoved = useRef(false);\n\n   const updatePointer = useCallback((currentPointer: THREE.Vector2) => {\n      const now = performance.now();\n      const current = currentPointer.clone();\n\n      // first frame\n      if (lastUpdateTime.current === 0) {\n         lastUpdateTime.current = now;\n         prevPointer.current = current;\n      }\n      const deltaTime = Math.max(1, now - lastUpdateTime.current);\n      lastUpdateTime.current = now;\n\n      // get velocity\n      velocity.current\n         .copy(current)\n         .sub(prevPointer.current)\n         .divideScalar(deltaTime);\n      const isUpdate = velocity.current.length() > 0;\n\n      //set prev temp pos\n      const prevTemp = isMoved.current ? prevPointer.current.clone() : current;\n      if (!isMoved.current && isUpdate) {\n         isMoved.current = true;\n      }\n      prevPointer.current = current;\n\n      return {\n         currentPointer: current,\n         prevPointer: prevTemp,\n         diffPointer: diffPointer.current.subVectors(current, prevTemp),\n         velocity: velocity.current,\n         isVelocityUpdate: isUpdate,\n      };\n   }, []);\n\n   return updatePointer;\n};\n","import { useCallback, useRef } from \"react\";\n\ntype Return<T> = [T, (params: Partial<T>) => void];\n\n/**\n * @param params Receives an initial value object. With structuredClone, deep copy and set, but if the object contains a function, just set it.\n */\nexport const useParams = <T extends object>(params: T): Return<T> => {\n   const isContainsFunctions = (obj: object): boolean =>\n      Object.values(obj).some((value) => typeof value === \"function\");\n   const paramsRef = useRef(\n      isContainsFunctions(params) ? params : structuredClone(params)\n   );\n\n   const setParams = useCallback((updateParams: Partial<T>) => {\n      for (const key in updateParams) {\n         const paramKey = key as keyof T;\n         if (\n            paramKey in paramsRef.current &&\n            updateParams[paramKey] !== undefined &&\n            updateParams[paramKey] !== null\n         ) {\n            paramsRef.current[paramKey] = updateParams[paramKey]!;\n         } else {\n            console.error(\n               `\"${String(\n                  paramKey\n               )}\" does not exist in the params. or \"${String(\n                  paramKey\n               )}\" is null | undefined`\n            );\n         }\n      }\n   }, []);\n   return [paramsRef.current, setParams];\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { useDoubleFBO } from \"../../utils/useDoubleFBO\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { usePointer } from \"../../utils/usePointer\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\nimport { DoubleRenderTarget } from \"../../utils/types\";\n\nexport type BrushParams = {\n   /** Texture applied to the brush.Mixed with the value of a , default:THREE.Texture() */\n   texture?: THREE.Texture;\n   /** size of the stamp, percentage of the size ,default:0.05 */\n   radius?: number;\n   /** Strength of smudge effect , default:0.0*/\n   smudge?: number;\n   /** dissipation rate. If set to 1, it will remain. ,default:1.0 */\n   dissipation?: number;\n   /** Strength of motion blur , default:0.0 */\n   motionBlur?: number;\n   /** Number of motion blur samples. Affects performance default: 5 */\n   motionSample?: number;\n   /** brush color , default:THREE.Color(0xffffff) */\n   color?: THREE.Color;\n};\n\nexport type BrushObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: DoubleRenderTarget;\n};\n\nexport const BRUSH_PARAMS: BrushParams = {\n   texture: new THREE.Texture(),\n   radius: 0.05,\n   smudge: 0.0,\n   dissipation: 1.0,\n   motionBlur: 0.0,\n   motionSample: 5,\n   color: new THREE.Color(0xffffff),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useBrush = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<BrushParams, BrushObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useDoubleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<BrushParams>(BRUSH_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: BrushParams) => {\n         const { gl, pointer } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uRadius\", params.radius!);\n         setUniform(material, \"uSmudge\", params.smudge!);\n         setUniform(material, \"uDissipation\", params.dissipation!);\n         setUniform(material, \"uMotionBlur\", params.motionBlur!);\n         setUniform(material, \"uMotionSample\", params.motionSample!);\n         setUniform(material, \"uColor\", params.color!);\n\n         const { currentPointer, prevPointer, velocity } =\n            updatePointer(pointer);\n         setUniform(material, \"uMouse\", currentPointer);\n         setUniform(material, \"uPrevMouse\", prevPointer);\n         setUniform(material, \"uVelocity\", velocity);\n\n         const bufferTexture = updateRenderTarget(gl, ({ read }) => {\n            setUniform(material, \"uMap\", read);\n         });\n\n         return bufferTexture;\n      },\n      [material, updatePointer, updateRenderTarget, params, setParams]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\n\nuniform vec3 uColor0;\nuniform vec3 uColor1;\n\nvoid main() {\n\tvec2 uv = vUv;\n\tvec4 texColor = texture2D(uTexture, uv);\n\tfloat grayscale = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n\tvec3 duotone = mix(uColor0, uColor1, grayscale);\n\tgl_FragColor = vec4(duotone, texColor.a);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\n\ntype TUniforms = {\n   uTexture: { value: THREE.Texture };\n   uColor0: { value: THREE.Color };\n   uColor1: { value: THREE.Color };\n};\n\nexport class DuoToneMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uColor0: { value: new THREE.Color(0xffffff) },\n               uColor1: { value: new THREE.Color(0x000000) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as DuoToneMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { DuoToneMaterial, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\n\nexport type DuoToneParams = {\n   /** Make this texture duotone , Default:new THREE.Texture() */\n   texture?: THREE.Texture;\n   /** 1st color ,　Default:new THREE.Color(0xffffff) */\n   color0?: THREE.Color;\n   /** 2nd color , Default: new THREE.Color(0x000000) */\n   color1?: THREE.Color;\n};\n\nexport type DuoToneObject = {\n   scene: THREE.Scene;\n   material: DuoToneMaterial;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const DUOTONE_PARAMS: DuoToneParams = {\n   texture: new THREE.Texture(),\n   color0: new THREE.Color(0xffffff),\n   color1: new THREE.Color(0x000000),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useDuoTone = ({\n   size,\n}: {\n   size: Size;\n}): HooksReturn<DuoToneParams, DuoToneObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<DuoToneParams>(DUOTONE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: DuoToneParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uColor0\", params.color0!);\n         setUniform(material, \"uColor1\", params.color1!);\n\n         const bufferTexture = updateRenderTarget(gl);\n\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform float uTime;\nuniform sampler2D uTexture;\nuniform sampler2D uNoiseMap;\nuniform float distortionStrength;\nuniform float fogEdge0;\nuniform float fogEdge1;\nuniform vec3 fogColor;\n\nvoid main() {\n\tvec2 uv = vUv;\n\n\tfloat noiseMap = texture2D(uNoiseMap,uv).r;\n\t\n\tfloat noiseTextureMap = noiseMap*2.0-1.0;\n\tuv += noiseTextureMap * distortionStrength;\n\tvec3 textureMap = texture2D(uTexture, uv).rgb;\n\n\tfloat edge0 = fogEdge0;\n\tfloat edge1 = fogEdge1;\n\tfloat blendValue = smoothstep(edge0, edge1, noiseMap);\n\n\tvec3 outputColor = blendValue * fogColor + (1.0 - blendValue) * textureMap;\n\tgl_FragColor = vec4(outputColor, 1.0);\n}\n\n\n","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\n\ntype TUniforms = {\n   uTime: { value: number };\n   uTexture: { value: THREE.Texture };\n   uNoiseMap: { value: THREE.Texture };\n   distortionStrength: { value: number };\n   fogEdge0: { value: number };\n   fogEdge1: { value: number };\n   fogColor: { value: THREE.Color };\n};\n\nexport class FogProjectionMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTime: { value: 0.0 },\n               uTexture: { value: new THREE.Texture() },\n               uNoiseMap: { value: new THREE.Texture() },\n               distortionStrength: { value: 0.0 },\n               fogEdge0: { value: 0.0 },\n               fogEdge1: { value: 0.9 },\n               fogColor: { value: new THREE.Color(0xffffff) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as FogProjectionMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\n\nexport type FogProjectionParams = {\n   /** Make this texture FogProjection , default:THREE.Texture */\n   texture?: THREE.Texture;\n   /** noise texture to map, default:THREE.Texture */\n   noiseMap?: THREE.Texture;\n   /** distortion strength , default:0.03 */\n   distortionStrength?: number;\n   /** value that reflects noise , default:0.0 */\n   fogEdge0?: number;\n   /** value that reflects noise , default:0.9  */\n   fogEdge1?: number;\n   /** fog color , default: THREE.Color(0xffffff) */\n   fogColor?: THREE.Color;\n};\n\nexport type FogProjectionObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const FOGPROJECTION_PARAMS: FogProjectionParams = {\n   texture: new THREE.Texture(),\n   noiseMap: new THREE.Texture(),\n   distortionStrength: 0.03,\n   fogEdge0: 0.0,\n   fogEdge1: 0.9,\n   fogColor: new THREE.Color(0xffffff),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useFogProjection = ({\n   size,\n}: {\n   size: Size;\n}): HooksReturn<FogProjectionParams, FogProjectionObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] =\n      useParams<FogProjectionParams>(FOGPROJECTION_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FogProjectionParams) => {\n         const { gl, clock } = props;\n         updateParams && setParams(updateParams);\n         setUniform(material, \"uTime\", clock.getElapsedTime());\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uNoiseMap\", params.noiseMap!);\n         setUniform(material, \"distortionStrength\", params.distortionStrength!);\n         setUniform(material, \"fogEdge0\", params.fogEdge0!);\n         setUniform(material, \"fogEdge1\", params.fogEdge1!);\n         setUniform(material, \"fogColor\", params.fogColor!);\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform vec2 texelSize;\n\nvoid main () {\n\tvUv = uv;\n\tvL = vUv - vec2(texelSize.x, 0.0);\n\tvR = vUv + vec2(texelSize.x, 0.0);\n\tvT = vUv + vec2(0.0, texelSize.y);\n\tvB = vUv - vec2(0.0, texelSize.y);\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvoid main(){\n\tgl_FragColor = vec4(0.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/init.frag\";\n\nexport const useInitialMaterial = () => {\n   const initialMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      []\n   );\n\n   return initialMaterial as THREE.ShaderMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uVelocity;\nuniform sampler2D uSource;\nuniform vec2 texelSize;\nuniform float dt;\nuniform float dissipation;\n\nvoid main () {\n\tvec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n\tgl_FragColor = dissipation * texture2D(uSource, coord);\n\tgl_FragColor.a = 1.0;\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/advection.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   uSource: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n   dt: { value: number };\n   dissipation: { value: number };\n};\n\nexport class AdvectionMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useAdvectionMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: new THREE.Texture() },\n               uSource: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n               dt: { value: 0.0 },\n               dissipation: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as AdvectionMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvec2 sampleVelocity (in vec2 uv) {\n\tvec2 multiplier = vec2(1.0, 1.0);\n\tif (uv.x < 0.0) { uv.x = 0.0; multiplier.x = -1.0; }\n\tif (uv.x > 1.0) { uv.x = 1.0; multiplier.x = -1.0; }\n\tif (uv.y < 0.0) { uv.y = 0.0; multiplier.y = -1.0; }\n\tif (uv.y > 1.0) { uv.y = 1.0; multiplier.y = -1.0; }\n\treturn multiplier * texture2D(uVelocity, uv).xy;\n}\n\nvoid main () {\n\tfloat L = sampleVelocity(vL).x;\n\tfloat R = sampleVelocity(vR).x;\n\tfloat T = sampleVelocity(vT).y;\n\tfloat B = sampleVelocity(vB).y;\n\tfloat div = 0.5 * (R - L + T - B);\n\tgl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/divergence.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class DivergenceMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useDivergenceMaterial = () => {\n   const divergenceMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return divergenceMaterial as DivergenceMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uDivergence;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tfloat C = texture2D(uPressure, vUv).x;\n\tfloat divergence = texture2D(uDivergence, vUv).x;\n\tfloat pressure = (L + R + B + T - divergence) * 0.25;\n\tgl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/pressure.frag\";\n\ntype TUniforms = {\n   uPressure: { value: THREE.Texture };\n   uDivergence: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class PressureMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const usePressureMaterial = () => {\n   const pressureMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: null },\n               uDivergence: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return pressureMaterial as PressureMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvoid main () {\n\tfloat L = texture2D(uVelocity, vL).y;\n\tfloat R = texture2D(uVelocity, vR).y;\n\tfloat T = texture2D(uVelocity, vT).x;\n\tfloat B = texture2D(uVelocity, vB).x;\n\tfloat vorticity = R - L - T + B;\n\tgl_FragColor = vec4(vorticity, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/curl.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class CurlMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useCurlMaterial = () => {\n   const curlMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return curlMaterial as CurlMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\nuniform sampler2D uCurl;\nuniform float curl;\nuniform float dt;\n\nvoid main () {\n\tfloat T = texture2D(uCurl, vT).x;\n\tfloat B = texture2D(uCurl, vB).x;\n\tfloat C = texture2D(uCurl, vUv).x;\n\tvec2 force = vec2(abs(T) - abs(B), 0.0);\n\tforce *= 1.0 / length(force + 0.00001) * curl * C;\n\tvec2 vel = texture2D(uVelocity, vUv).xy;\n\tgl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/vorticity.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   uCurl: { value: THREE.Texture };\n   curl: { value: number };\n   dt: { value: number };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class VorticityMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useVorticityMaterial = () => {\n   const vorticityMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               uCurl: { value: null },\n               curl: { value: 0 },\n               dt: { value: 0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return vorticityMaterial as VorticityMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform float value;\n\nvoid main () {\n\tgl_FragColor = value * texture2D(uTexture, vUv);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/clear.frag\";\n\ntype TUniforms = {\n   uTexture: { value: THREE.Texture };\n   value: { value: number };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class ClearMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useClearMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               value: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as ClearMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uVelocity;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tvec2 velocity = texture2D(uVelocity, vUv).xy;\n\tvelocity.xy -= vec2(R - L, T - B);\n\tgl_FragColor = vec4(velocity, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/gradientSubtract.frag\";\n\ntype TUniforms = {\n   uPressure: { value: THREE.Texture };\n   uVelocity: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class GradientSubtractMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useGradientSubtractMaterial = () => {\n   const gradientSubtractMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: new THREE.Texture() },\n               uVelocity: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return gradientSubtractMaterial as GradientSubtractMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uTarget;\nuniform float aspectRatio;\nuniform vec3 color;\nuniform vec2 point;\nuniform float radius;\n\nvoid main () {\n\tvec2 nPoint = (point + vec2(1.0)) * 0.5;\n\tvec2 p = vUv - nPoint.xy;\n\tp.x *= aspectRatio;\n\tvec3 splat = exp(-dot(p, p) / radius) * color;\n\tvec3 base = texture2D(uTarget, vUv).xyz;\n\tgl_FragColor = vec4(base + splat, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/splat.frag\";\n\ntype TUniforms = {\n   uTarget: { value: THREE.Texture };\n   aspectRatio: { value: number };\n   color: { value: THREE.Vector3 };\n   point: { value: THREE.Vector2 };\n   radius: { value: number };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class SplatMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useSplateMaterial = () => {\n   const splatMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTarget: { value: new THREE.Texture() },\n               aspectRatio: { value: 0 },\n               color: { value: new THREE.Vector3() },\n               point: { value: new THREE.Vector2() },\n               radius: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return splatMaterial as SplatMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo } from \"react\";\nimport { useInitialMaterial } from \"./materials/useInitialMaterial\";\nimport {\n   AdvectionMaterial,\n   useAdvectionMaterial,\n} from \"./materials/useAdvectionMaterial\";\nimport {\n   DivergenceMaterial,\n   useDivergenceMaterial,\n} from \"./materials/useDivergenceMaterial\";\nimport {\n   PressureMaterial,\n   usePressureMaterial,\n} from \"./materials/usePressureMaterial\";\nimport { CurlMaterial, useCurlMaterial } from \"./materials/useCurlMaterial\";\nimport {\n   VorticityMaterial,\n   useVorticityMaterial,\n} from \"./materials/useVorticityMaterial\";\nimport { useResolution } from \"../../utils/useResolution\";\nimport { ClearMaterial, useClearMaterial } from \"./materials/useClearMaterial\";\nimport {\n   GradientSubtractMaterial,\n   useGradientSubtractMaterial,\n} from \"./materials/useGradientSubtractMaterial\";\nimport { SplatMaterial, useSplateMaterial } from \"./materials/useSplatMaterial\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TMaterials =\n   | AdvectionMaterial\n   | DivergenceMaterial\n   | CurlMaterial\n   | PressureMaterial\n   | ClearMaterial\n   | GradientSubtractMaterial\n   | SplatMaterial;\n\nexport type FruidMaterials = {\n   vorticityMaterial: VorticityMaterial;\n   curlMaterial: CurlMaterial;\n   advectionMaterial: AdvectionMaterial;\n   divergenceMaterial: DivergenceMaterial;\n   pressureMaterial: PressureMaterial;\n   clearMaterial: ClearMaterial;\n   gradientSubtractMaterial: GradientSubtractMaterial;\n   splatMaterial: SplatMaterial;\n};\ntype TUseMeshReturnType = [FruidMaterials, (material: TMaterials) => void];\n\n/**\n * Returns the material update function in the second argument\n */\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}): TUseMeshReturnType => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const initialMaterial = useInitialMaterial();\n   const updateMaterial = initialMaterial.clone();\n   const curlMaterial = useCurlMaterial();\n   const vorticityMaterial = useVorticityMaterial();\n   const advectionMaterial = useAdvectionMaterial();\n   const divergenceMaterial = useDivergenceMaterial();\n   const pressureMaterial = usePressureMaterial();\n   const clearMaterial = useClearMaterial();\n   const gradientSubtractMaterial = useGradientSubtractMaterial();\n   const splatMaterial = useSplateMaterial();\n   const materials = useMemo(\n      () => ({\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      }),\n      [\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      ]\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(\n         materials.splatMaterial,\n         \"aspectRatio\",\n         resolution.x / resolution.y\n      );\n      for (const material of Object.values(materials)) {\n         setUniform<any>(\n            material,\n            \"texelSize\",\n            new THREE.Vector2(1.0 / resolution.x, 1.0 / resolution.y)\n         );\n      }\n   }, [resolution, materials]);\n\n   const mesh = useAddMesh(scene, geometry, initialMaterial);\n   useEffect(() => {\n      initialMaterial.dispose();\n      mesh.material = updateMaterial;\n   }, [initialMaterial, mesh, updateMaterial]);\n\n   useEffect(() => {\n      return () => {\n         for (const material of Object.values(materials)) {\n            material.dispose();\n         }\n      };\n   }, [materials]);\n\n   const setMeshMaterial = useCallback(\n      (material: TMaterials) => {\n         mesh.material = material;\n         mesh.material.needsUpdate = true;\n      },\n      [mesh]\n   );\n\n   return [materials, setMeshMaterial];\n};\n","import * as THREE from \"three\";\nimport { FruidMaterials, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { useDoubleFBO } from \"../../utils/useDoubleFBO\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { usePointer } from \"../../utils/usePointer\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\nimport { DoubleRenderTarget } from \"../../utils/types\";\n\nexport type FruidParams = {\n   /** density disspation , default:0.98 */\n   density_dissipation?: number;\n   /** velocity dissipation , default:0.99 */\n   velocity_dissipation?: number;\n   /** velocity acceleration , default:10.0 */\n   velocity_acceleration?: number;\n   /** pressure dissipation , default:0.9 */\n   pressure_dissipation?: number;\n   /** pressure iterations. affects performance , default:20 */\n   pressure_iterations?: number;\n   /** curl_strength , default:35 */\n   curl_strength?: number;\n   /** splat radius , default:0.002 */\n   splat_radius?: number;\n   /** Fluid Color.THREE.Vector3 Alternatively, it accepts a function that returns THREE.Vector3.The function takes velocity:THREE.Vector2 as an argument. , default:THREE.Vector3(1.0, 1.0, 1.0) */\n   fruid_color?: ((velocity: THREE.Vector2) => THREE.Vector3) | THREE.Vector3;\n};\n\nexport type FruidObject = {\n   scene: THREE.Scene;\n   materials: FruidMaterials;\n   camera: THREE.Camera;\n   renderTarget: {\n      velocity: DoubleRenderTarget;\n      density: DoubleRenderTarget;\n      curl: THREE.WebGLRenderTarget;\n      divergence: THREE.WebGLRenderTarget;\n      pressure: DoubleRenderTarget;\n   };\n};\n\nexport const FRUID_PARAMS: FruidParams = {\n   density_dissipation: 0.98,\n   velocity_dissipation: 0.99,\n   velocity_acceleration: 10.0,\n   pressure_dissipation: 0.9,\n   pressure_iterations: 20,\n   curl_strength: 35,\n   splat_radius: 0.002,\n   fruid_color: new THREE.Vector3(1.0, 1.0, 1.0),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useFruid = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<FruidParams, FruidObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const [materials, setMeshMaterial] = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n\n   const fboProps = useMemo(\n      () => ({\n         scene,\n         camera,\n         size,\n         dpr,\n      }),\n      [scene, camera, size, dpr]\n   );\n   const [velocityFBO, updateVelocityFBO] = useDoubleFBO(fboProps);\n   const [densityFBO, updateDensityFBO] = useDoubleFBO(fboProps);\n   const [curlFBO, updateCurlFBO] = useSingleFBO(fboProps);\n   const [divergenceFBO, updateDivergenceFBO] = useSingleFBO(fboProps);\n   const [pressureFBO, updatePressureFBO] = useDoubleFBO(fboProps);\n\n   const lastTime = useRef(0);\n   const scaledDiffVec = useRef(new THREE.Vector2(0, 0));\n   const spaltVec = useRef(new THREE.Vector3(0, 0, 0));\n\n   const [params, setParams] = useParams<FruidParams>(FRUID_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FruidParams) => {\n         const { gl, pointer, clock, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         if (lastTime.current === 0) {\n            lastTime.current = clock.getElapsedTime();\n         }\n         const dt = Math.min(\n            (clock.getElapsedTime() - lastTime.current) / 3,\n            0.02\n         );\n         lastTime.current = clock.getElapsedTime();\n\n         // update velocity\n         const velocityTex = updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", read);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(materials.advectionMaterial, \"dt\", dt);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.velocity_dissipation!\n            );\n         });\n\n         // update density\n         const densityTex = updateDensityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", velocityTex);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.density_dissipation!\n            );\n         });\n\n         // update splatting\n         const { currentPointer, diffPointer, isVelocityUpdate, velocity } =\n            updatePointer(pointer);\n         if (isVelocityUpdate) {\n            updateVelocityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               setUniform(materials.splatMaterial, \"point\", currentPointer);\n               const scaledDiff = diffPointer.multiply(\n                  scaledDiffVec.current\n                     .set(size.width, size.height)\n                     .multiplyScalar(params.velocity_acceleration!)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"color\",\n                  spaltVec.current.set(scaledDiff.x, scaledDiff.y, 1.0)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"radius\",\n                  params.splat_radius!\n               );\n            });\n            updateDensityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               const color: THREE.Vector3 =\n                  typeof params.fruid_color === \"function\"\n                     ? params.fruid_color(velocity)\n                     : params.fruid_color!;\n               setUniform(materials.splatMaterial, \"color\", color);\n            });\n         }\n\n         // update curl\n         const curlTex = updateCurlFBO(gl, () => {\n            setMeshMaterial(materials.curlMaterial);\n            setUniform(materials.curlMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update vorticity\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.vorticityMaterial);\n            setUniform(materials.vorticityMaterial, \"uVelocity\", read);\n            setUniform(materials.vorticityMaterial, \"uCurl\", curlTex);\n            setUniform(\n               materials.vorticityMaterial,\n               \"curl\",\n               params.curl_strength!\n            );\n            setUniform(materials.vorticityMaterial, \"dt\", dt);\n         });\n\n         // update divergence\n         const divergenceTex = updateDivergenceFBO(gl, () => {\n            setMeshMaterial(materials.divergenceMaterial);\n            setUniform(materials.divergenceMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update pressure\n         updatePressureFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.clearMaterial);\n            setUniform(materials.clearMaterial, \"uTexture\", read);\n            setUniform(\n               materials.clearMaterial,\n               \"value\",\n               params.pressure_dissipation!\n            );\n         });\n\n         // solve pressure iterative (Gauss-Seidel)\n         setMeshMaterial(materials.pressureMaterial);\n         setUniform(materials.pressureMaterial, \"uDivergence\", divergenceTex);\n         let pressureTexTemp: THREE.Texture;\n         for (let i = 0; i < params.pressure_iterations!; i++) {\n            pressureTexTemp = updatePressureFBO(gl, ({ read }) => {\n               setUniform(materials.pressureMaterial, \"uPressure\", read);\n            });\n         }\n\n         // update gradienSubtract\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.gradientSubtractMaterial);\n            setUniform(\n               materials.gradientSubtractMaterial,\n               \"uPressure\",\n               pressureTexTemp\n            );\n            setUniform(materials.gradientSubtractMaterial, \"uVelocity\", read);\n         });\n\n         return densityTex;\n      },\n      [\n         materials,\n         setMeshMaterial,\n         updateCurlFBO,\n         updateDensityFBO,\n         updateDivergenceFBO,\n         updatePointer,\n         updatePressureFBO,\n         updateVelocityFBO,\n         setParams,\n         params,\n      ]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         materials: materials,\n         camera: camera,\n         renderTarget: {\n            velocity: velocityFBO,\n            density: densityFBO,\n            curl: curlFBO,\n            divergence: divergenceFBO,\n            pressure: pressureFBO,\n         },\n      },\n   ];\n};\n","import { useEffect, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\n\ntype TcreateMesh = {\n   scale: number;\n   max: number;\n   texture?: THREE.Texture;\n   scene: THREE.Scene;\n};\nexport const useMesh = ({ scale, max, texture, scene }: TcreateMesh) => {\n   const meshArr = useRef<THREE.Mesh[]>([]);\n   const geometry = useMemo(\n      () => new THREE.PlaneGeometry(scale, scale),\n      [scale]\n   );\n   const material = useMemo(\n      () =>\n         new THREE.MeshBasicMaterial({\n            map: texture ?? null,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      [texture]\n   );\n\n   useEffect(() => {\n      for (let i = 0; i < max; i++) {\n         const mesh = new THREE.Mesh(geometry.clone(), material.clone());\n         mesh.rotateZ(2 * Math.PI * Math.random());\n         mesh.visible = false;\n         scene.add(mesh);\n         meshArr.current.push(mesh);\n      }\n   }, [geometry, material, scene, max]);\n\n   useEffect(() => {\n      return () => {\n         meshArr.current.forEach((mesh) => {\n            mesh.geometry.dispose();\n            if (Array.isArray(mesh.material)) {\n               mesh.material.forEach((material) => material.dispose());\n            } else {\n               mesh.material.dispose();\n            }\n            scene.remove(mesh);\n         });\n         meshArr.current = [];\n      };\n   }, [scene]);\n\n   return meshArr.current;\n};\n","import { useCallback, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { usePointer } from \"../../utils/usePointer\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\n\nexport type RippleParams = {\n   /** How often ripples appear,default:0.01 */\n   frequency?: number;\n   /** rotation rate,default:0.05 */\n   rotation?: number;\n   /** fadeout speed,default:0.9 */\n   fadeout_speed?: number;\n   /** scale rate,default:0.3 */\n   scale?: number;\n   /** alpha,default:0.6 */\n   alpha?: number;\n};\n\nexport type RippleObject = {\n   scene: THREE.Scene;\n   meshArr: THREE.Mesh[];\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const RIPPLE_PARAMS: RippleParams = {\n   frequency: 0.01,\n   rotation: 0.05,\n   fadeout_speed: 0.9,\n   scale: 0.3,\n   alpha: 0.6,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useRipple = ({\n   texture,\n   scale = 64,\n   max = 100,\n   size,\n}: {\n   /** texture applied to ripple */\n   texture: THREE.Texture;\n   /** ripple size, default:64 */\n   scale?: number;\n   /** ripple max length, default:100 */\n   max?: number;\n   size: Size;\n}): HooksReturn<RippleParams, RippleObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const meshArr = useMesh({\n      scale: scale,\n      max: max,\n      texture,\n      scene,\n   });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<RippleParams>(RIPPLE_PARAMS);\n\n   const currentWave = useRef(0);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: RippleParams) => {\n         const { gl, pointer, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         const { currentPointer, diffPointer } = updatePointer(pointer);\n         if (params.frequency! < diffPointer.length()) {\n            const mesh = meshArr[currentWave.current];\n            mesh.visible = true;\n            mesh.position.set(\n               currentPointer.x * (size.width / 2),\n               currentPointer.y * (size.height / 2),\n               0\n            );\n            mesh.scale.x = mesh.scale.y = 0.0;\n            (mesh.material as THREE.MeshBasicMaterial).opacity = params.alpha!;\n            currentWave.current = (currentWave.current + 1) % max;\n         }\n         meshArr.forEach((mesh) => {\n            if (mesh.visible) {\n               const material = mesh.material as THREE.MeshBasicMaterial;\n               mesh.rotation.z += params.rotation!;\n               material.opacity *= params.fadeout_speed!;\n               mesh.scale.x =\n                  params.fadeout_speed! * mesh.scale.x + params.scale!;\n               mesh.scale.y = mesh.scale.x;\n               if (material.opacity < 0.002) mesh.visible = false;\n            }\n         });\n\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, meshArr, updatePointer, max, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         camera: camera,\n         meshArr: meshArr,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform vec2 uResolution;\nuniform vec2 uImageResolution;\n\nuniform sampler2D uTexture0;\nuniform sampler2D uTexture1;\nuniform sampler2D uNoiseMap;\nuniform float noiseStrength;\nuniform float progress;\nuniform float dirX;\nuniform float dirY;\n\nvoid main() {\n\tvec2 bgRatio=vec2(\n\t\tmin((uResolution.x/uResolution.y)/(uImageResolution.x/uImageResolution.y),1.),\n\t\tmin((uResolution.y/uResolution.x)/(uImageResolution.y/uImageResolution.x),1.)\n\t);\n\tvec2 uv=vec2(\n\t\tvUv.x*bgRatio.x+(1.-bgRatio.x)*.5,\n\t\tvUv.y*bgRatio.y+(1.-bgRatio.y)*.5\n\t);\n\n\t// noise\n\tvec2 noiseMap = texture2D(uNoiseMap, uv).rg;\n\tnoiseMap=noiseMap*2.0-1.0;\n\tuv += noiseMap * noiseStrength;\n\n\t// center uv\n\tvec2 centeredUV = uv - vec2(0.5);\n\t\n\t// texture 0\n\tfloat xOffsetTexture0 = 0.5 - dirX * progress;\n\tfloat yOffsetTexture0 = 0.5 - dirY * progress;\n\tvec2 samplePosTexture0 = vec2(xOffsetTexture0, yOffsetTexture0) + centeredUV;\n\n\t//texture 1\n\tfloat xOffsetTexture1 = 0.5 + dirX * (1.0 - progress);\n\tfloat yOffsetTexture1 = 0.5 + dirY * (1.0 - progress);\n\tvec2 samplePosTexture1 = vec2(xOffsetTexture1, yOffsetTexture1) + centeredUV;\n\n\tvec4 color0 = texture2D(uTexture0, samplePosTexture0);\n\tvec4 color1 = texture2D(uTexture1, samplePosTexture1);\n\n\tgl_FragColor = mix(color0, color1, progress);\n\n}","import { useEffect, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useResolution } from \"../../utils/useResolution\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TUniforms = {\n   uResolution: { value: THREE.Vector2 };\n   uImageResolution: { value: THREE.Vector2 };\n   uTexture0: { value: THREE.Texture };\n   uTexture1: { value: THREE.Texture };\n   uNoiseMap: { value: THREE.Texture };\n   noiseStrength: { value: number };\n   progress: { value: number };\n   dirX: { value: number };\n   dirY: { value: number };\n};\n\nexport class TransitionBgMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uResolution: { value: new THREE.Vector2() },\n               uImageResolution: { value: new THREE.Vector2() },\n               uTexture0: { value: new THREE.Texture() },\n               uTexture1: { value: new THREE.Texture() },\n               uNoiseMap: { value: new THREE.Texture() },\n               noiseStrength: { value: 0.0 },\n               progress: { value: 0.0 },\n               dirX: { value: 0.0 },\n               dirY: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      material.uniforms.uResolution.value = resolution.clone();\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material as TransitionBgMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\n\nexport type TransitionBgParams = {\n   /** 1st texture , default:THREE.Texture() */\n   texture0?: THREE.Texture;\n   /** 2nd texture , default:THREE.Texture() */\n   texture1?: THREE.Texture;\n   /** background image ratio , default:THREE.Vector2(0, 0) */\n   imageResolution?: THREE.Vector2;\n   /** Noise texture to be multiplied when transitioning. You can use useNoise, but you can also use noise texture exported as an image. , default:THREE.Texture() */\n   noiseMap?: THREE.Texture;\n   /** noise strength , default:0.0 */\n   noiseStrength?: number;\n   /** Switch value to switch between texture0 and texture1 */\n   progress?: number;\n   /** direction of transition , default: THREE.Vector2(0, 0) */\n   dir?: THREE.Vector2;\n};\n\nexport type TransitionBgObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const TRANSITIONBG_PARAMS: TransitionBgParams = {\n   texture0: new THREE.Texture(),\n   texture1: new THREE.Texture(),\n   imageResolution: new THREE.Vector2(0, 0),\n   noiseMap: new THREE.Texture(),\n   noiseStrength: 0.0,\n   progress: 0.0,\n   dir: new THREE.Vector2(0, 0),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useTransitionBg = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<TransitionBgParams, TransitionBgObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      dpr,\n      size,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] =\n      useParams<TransitionBgParams>(TRANSITIONBG_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: TransitionBgParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture0\", params.texture0!);\n         setUniform(material, \"uTexture1\", params.texture1!);\n         setUniform(material, \"uImageResolution\", params.imageResolution!);\n         setUniform(material, \"uNoiseMap\", params.noiseMap!);\n         setUniform(material, \"noiseStrength\", params.noiseStrength!);\n         setUniform(material, \"progress\", params.progress!);\n         setUniform(material, \"dirX\", params.dir!.x);\n         setUniform(material, \"dirY\", params.dir!.y);\n\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\n\nuniform float uTime;\nuniform float timeStrength;\nuniform int noiseOctaves;\nuniform int fbmOctaves;\n\nconst float per  = 0.5;\nconst float PI   = 3.1415926;\n\nfloat interpolate(float a, float b, float x){\n    float f = (1.0 - cos(x * PI)) * 0.5;\n    return a * (1.0 - f) + b * f;\n}\n\nfloat rnd(vec2 p){\n    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat irnd(vec2 p){\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tvec4 v = vec4(rnd(vec2(i.x,i.y)),rnd(vec2(i.x + 1.0,i.y)),rnd(vec2(i.x,i.y + 1.0)),rnd(vec2(i.x + 1.0, i.y + 1.0)));\n\treturn interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);\n}\n\nfloat noise(vec2 p, float time){\n\tfloat t = 0.0;\n\tfor(int i = 0; i < noiseOctaves; i++){\n\t\tfloat freq = pow(2.0, float(i));\n\t\tfloat amp  = pow(per, float(noiseOctaves - i));\n\t\tt += irnd(vec2(p.y / freq + time, p.x / freq + time)) * amp;\n\t}\n\treturn t;\n}\n\nfloat fbm(vec2 x, float time) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfloat sign = 1.0;\n\tfor (int i = 0; i < fbmOctaves; ++i) {\n\t\tv += a * noise(x, time * sign);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t\tsign *= -1.0;\n\t}\n\treturn v;\n}\n\nvoid main() {\n\tvec2 uv = vUv;\n\tfloat noiseMap = fbm(gl_FragCoord.xy ,uTime * timeStrength);\n\tgl_FragColor = vec4(noiseMap,noiseMap,noiseMap,1.0);\n}\n\n","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\n\ntype TUniforms = {\n   uTime: { value: number };\n   timeStrength: { value: number };\n   noiseOctaves: { value: number };\n   fbmOctaves: { value: number };\n};\n\nexport class NoiseMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTime: { value: 0.0 },\n               timeStrength: { value: 0.0 },\n               noiseOctaves: { value: 0 },\n               fbmOctaves: { value: 0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as NoiseMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { useParams } from \"../../utils/useParams\";\nimport { HooksReturn } from \"../types\";\n\nexport type NoiseParams = {\n   /** time factor default:0.3 */\n   timeStrength?: number;\n   /** noiseOctaves, affects performance default:8 */\n   noiseOctaves?: number;\n   /** fbmOctaves, affects performance default:3 */\n   fbmOctaves?: number;\n};\n\nexport type NoiseObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const NOISE_PARAMS: NoiseParams = {\n   timeStrength: 0.3,\n   noiseOctaves: 8,\n   fbmOctaves: 3,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useNoise = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<NoiseParams, NoiseObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n   });\n\n   const [params, setParams] = useParams<NoiseParams>(NOISE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: NoiseParams) => {\n         const { gl, clock } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"timeStrength\", params.timeStrength!);\n         setUniform(material, \"noiseOctaves\", params.noiseOctaves!);\n         setUniform(material, \"fbmOctaves\", params.fbmOctaves!);\n\n         setUniform(material, \"uTime\", clock.getElapsedTime());\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n"],"names":["main_default","useResolution","size","dpr","_width","_height","useMemo","THREE","useAddMesh","scene","geometry","material","mesh","useEffect","setUniform","key","value","useMesh","vertexShader","fragmentShader","resolution","getCameraProps","width","height","frustumSize","aspect","w","h","useCamera","near","far","FBO_OPTION","useSingleFBO","camera","isSizeUpdate","renderTarget","useRef","useLayoutEffect","_a","currentRenderTarget","updateRenderTarget","useCallback","gl","onBeforeRender","fbo","useDoubleFBO","temp","initRenderTargets","read","write","_b","usePointer","prevPointer","diffPointer","lastUpdateTime","velocity","isMoved","currentPointer","now","current","deltaTime","isUpdate","prevTemp","useParams","params","isContainsFunctions","obj","paramsRef","setParams","updateParams","paramKey","BRUSH_PARAMS","useBrush","updatePointer","props","pointer","DUOTONE_PARAMS","useDuoTone","FOGPROJECTION_PARAMS","useFogProjection","clock","init_default","useInitialMaterial","advection_default","useAdvectionMaterial","divergence_default","useDivergenceMaterial","pressure_default","usePressureMaterial","curl_default","useCurlMaterial","vorticity_default","useVorticityMaterial","clear_default","useClearMaterial","gradientSubtract_default","useGradientSubtractMaterial","splat_default","useSplateMaterial","initialMaterial","updateMaterial","curlMaterial","vorticityMaterial","advectionMaterial","divergenceMaterial","pressureMaterial","clearMaterial","gradientSubtractMaterial","splatMaterial","materials","setMeshMaterial","FRUID_PARAMS","useFruid","fboProps","velocityFBO","updateVelocityFBO","densityFBO","updateDensityFBO","curlFBO","updateCurlFBO","divergenceFBO","updateDivergenceFBO","pressureFBO","updatePressureFBO","lastTime","scaledDiffVec","spaltVec","dt","velocityTex","densityTex","isVelocityUpdate","scaledDiff","color","curlTex","divergenceTex","pressureTexTemp","i","scale","max","texture","meshArr","RIPPLE_PARAMS","useRipple","currentWave","TRANSITIONBG_PARAMS","useTransitionBg","NOISE_PARAMS","useNoise"],"mappings":"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"}