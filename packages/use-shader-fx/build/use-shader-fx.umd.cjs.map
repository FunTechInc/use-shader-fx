{"version":3,"file":"use-shader-fx.umd.cjs","sources":["../src/fxs/interactions/useBrush/shader/main.vert","../src/fxs/interactions/useBrush/shader/main.frag","../src/utils/useResolution.ts","../src/utils/setUniforms.ts","../src/utils/useAddObject.ts","../src/fxs/interactions/useBrush/useMesh.ts","../src/utils/useCamera.ts","../src/misc/usePointer.ts","../src/utils/useParams.ts","../src/utils/useSingleFBO.ts","../src/utils/useDoubleFBO.ts","../src/utils/getDpr.ts","../src/fxs/interactions/useBrush/index.ts","../src/fxs/interactions/useFluid/shaders/main.vert","../src/fxs/interactions/useFluid/shaders/init.frag","../src/fxs/interactions/useFluid/materials/useInitialMaterial.ts","../src/fxs/interactions/useFluid/shaders/advection.frag","../src/fxs/interactions/useFluid/materials/useAdvectionMaterial.ts","../src/fxs/interactions/useFluid/shaders/divergence.frag","../src/fxs/interactions/useFluid/materials/useDivergenceMaterial.ts","../src/fxs/interactions/useFluid/shaders/pressure.frag","../src/fxs/interactions/useFluid/materials/usePressureMaterial.ts","../src/fxs/interactions/useFluid/shaders/curl.frag","../src/fxs/interactions/useFluid/materials/useCurlMaterial.ts","../src/fxs/interactions/useFluid/shaders/vorticity.frag","../src/fxs/interactions/useFluid/materials/useVorticityMaterial.ts","../src/fxs/interactions/useFluid/shaders/clear.frag","../src/fxs/interactions/useFluid/materials/useClearMaterial.ts","../src/fxs/interactions/useFluid/shaders/gradientSubtract.frag","../src/fxs/interactions/useFluid/materials/useGradientSubtractMaterial.ts","../src/fxs/interactions/useFluid/shaders/splat.frag","../src/fxs/interactions/useFluid/materials/useSplatMaterial.ts","../src/fxs/interactions/useFluid/useMesh.ts","../src/fxs/interactions/useFluid/index.ts","../src/fxs/interactions/useRipple/useMesh.ts","../src/fxs/interactions/useRipple/index.ts","../src/fxs/noises/useNoise/shader/main.vert","../src/fxs/noises/useNoise/shader/main.frag","../src/fxs/noises/useNoise/useMesh.ts","../src/fxs/noises/useNoise/index.ts","../src/fxs/noises/useColorStrata/shader/main.vert","../src/fxs/noises/useColorStrata/shader/main.frag","../src/fxs/noises/useColorStrata/useMesh.ts","../src/fxs/noises/useColorStrata/index.ts","../src/fxs/noises/useMarble/shader/main.vert","../src/fxs/noises/useMarble/shader/main.frag","../src/fxs/noises/useMarble/useMesh.ts","../src/fxs/noises/useMarble/index.ts","../src/fxs/noises/useCosPalette/shader/main.vert","../src/fxs/noises/useCosPalette/shader/main.frag","../src/fxs/noises/useCosPalette/useMesh.ts","../src/fxs/noises/useCosPalette/index.ts","../src/fxs/utils/useDuoTone/shader/main.vert","../src/fxs/utils/useDuoTone/shader/main.frag","../src/fxs/utils/useDuoTone/useMesh.ts","../src/fxs/utils/useDuoTone/index.ts","../src/fxs/utils/useBlending/shader/main.vert","../src/fxs/utils/useBlending/shader/main.frag","../src/fxs/utils/useBlending/useMesh.ts","../src/fxs/utils/useBlending/index.ts","../src/fxs/utils/useFxTexture/shader/main.vert","../src/fxs/utils/useFxTexture/shader/main.frag","../src/fxs/utils/useFxTexture/useMesh.ts","../src/fxs/utils/useFxTexture/index.ts","../src/fxs/utils/useBrightnessPicker/shader/main.vert","../src/fxs/utils/useBrightnessPicker/shader/main.frag","../src/fxs/utils/useBrightnessPicker/useMesh.ts","../src/fxs/utils/useBrightnessPicker/index.ts","../src/fxs/utils/useFxBlending/shader/main.vert","../src/fxs/utils/useFxBlending/shader/main.frag","../src/fxs/utils/useFxBlending/useMesh.ts","../src/fxs/utils/useFxBlending/index.ts","../src/fxs/utils/useAlphaBlending/shader/main.vert","../src/fxs/utils/useAlphaBlending/shader/main.frag","../src/fxs/utils/useAlphaBlending/useMesh.ts","../src/fxs/utils/useAlphaBlending/index.ts","../src/fxs/utils/useHSV/shader/main.vert","../src/fxs/utils/useHSV/shader/main.frag","../src/fxs/utils/useHSV/useMesh.ts","../src/fxs/utils/useHSV/index.ts","../src/fxs/utils/useCoverTexture/shader/main.vert","../src/fxs/utils/useCoverTexture/shader/main.frag","../src/fxs/utils/useCoverTexture/useMesh.ts","../src/fxs/utils/useCoverTexture/index.ts","../src/fxs/effects/useSimpleBlur/shader/main.vert","../src/fxs/effects/useSimpleBlur/shader/main.frag","../src/fxs/effects/useSimpleBlur/useMesh.ts","../src/fxs/effects/useSimpleBlur/index.ts","../src/fxs/effects/useWave/shader/main.vert","../src/fxs/effects/useWave/shader/main.frag","../src/fxs/effects/useWave/useMesh.ts","../src/fxs/effects/useWave/index.ts","../src/fxs/misc/useChromaKey/shader/main.vert","../src/fxs/misc/useChromaKey/shader/main.frag","../src/fxs/misc/useChromaKey/useMesh.ts","../src/fxs/misc/useChromaKey/index.ts","../src/fxs/3D/useMorphParticles/utils/useCreateObject.ts","../src/fxs/3D/useMorphParticles/shaders/main.vert","../src/fxs/3D/useMorphParticles/shaders/main.frag","../src/libs/shaders/getWobble.glsl","../src/libs/constants.ts","../src/fxs/3D/useMorphParticles/utils/rewriteVertexShader.ts","../src/fxs/3D/useMorphParticles/utils/modifyAttributes.ts","../src/fxs/3D/useMorphParticles/utils/rewriteFragmentShader.ts","../src/fxs/3D/useMorphParticles/utils/useMaterial.ts","../src/fxs/3D/useMorphParticles/useCreateMorphParticles.ts","../src/fxs/3D/useMorphParticles/index.ts","../node_modules/three-stdlib/utils/BufferGeometryUtils.js","../src/libs/shaders/snoise.glsl","../src/fxs/3D/useWobble3D/shaders/transmission_pars_fragment.glsl","../src/fxs/3D/useWobble3D/shaders/transmission_fragment.glsl","../src/fxs/3D/useWobble3D/useMaterial.ts","../src/fxs/3D/useWobble3D/useCreateWobble3D.ts","../src/fxs/3D/useWobble3D/index.ts","../src/utils/useAddMesh.ts","../src/libs/easing.ts","../src/misc/useBeat.ts","../src/misc/useFPSLimiter.ts","../src/misc/useDomSyncer/utils/errorHandler.ts","../src/misc/useDomSyncer/shader/main.vert","../src/misc/useDomSyncer/shader/main.frag","../src/misc/useDomSyncer/utils/createMesh.ts","../src/misc/useDomSyncer/utils/useIntersectionHandler.ts","../src/misc/useDomSyncer/utils/useUpdateDomRect.ts","../src/misc/useDomSyncer/utils/useIsIntersecting.ts","../src/misc/useDomSyncer/utils/createUseDomView.ts","../src/misc/useDomSyncer/index.ts","../src/misc/useCopyTexture.ts"],"sourcesContent":["varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nuniform sampler2D uBuffer;\nuniform sampler2D uTexture;\nuniform bool uIsTexture;\nuniform sampler2D uMap;\nuniform bool uIsMap;\nuniform float uMapIntensity;\nuniform float uRadius;\nuniform float uDissipation;\nuniform vec2 uResolution;\nuniform float uSmudge;\nuniform vec2 uMouse;\nuniform vec2 uPrevMouse;\nuniform vec2 uVelocity;\nuniform vec3 uColor;\nuniform float uMotionBlur;\nuniform int uMotionSample;\nuniform bool uIsCursor;\nuniform float uPressureStart;\nuniform float uPressureEnd;\n\nvarying vec2 vUv;\n\nfloat isOnLine(vec2 point, vec2 start, vec2 end, float radius, float pressureStart, float pressureEnd) {\n\t\n\tfloat aspect = uResolution.x / uResolution.y;\n\n\tpoint.x *= aspect;\n\tstart.x *= aspect;\n\tend.x *= aspect;\n\n\tvec2 dir = normalize(end - start);\n\tvec2 n = vec2(dir.y, -dir.x);\n\tvec2 p0 = point - start;\n\t\n\tfloat distToLine = abs(dot(p0, n));\n\tfloat distAlongLine = dot(p0, dir);\n\tfloat totalLength = length(end - start);\n\n\tfloat progress = clamp(distAlongLine / totalLength, 0.0, 1.0);\n\tfloat pressure = mix(pressureStart, pressureEnd, progress);\n\tradius = min(radius,radius * pressure);\n\n\tfloat distFromStart = length(point - start);\n\tfloat distFromEnd = length(point - end);\n\t\n\tbool withinLine = (distToLine < radius && distAlongLine > 0.0 && distAlongLine < totalLength) || distFromStart < radius || distFromEnd < radius;\n\n\treturn float(withinLine);\n}\n\nvec4 createSmudge(vec2 uv){\n\tvec2 offsets[9];\n\toffsets[0] = vec2(-1, -1); offsets[1] = vec2( 0, -1); offsets[2] = vec2( 1, -1);\n\toffsets[3] = vec2(-1,  0); offsets[4] = vec2( 0,  0); offsets[5] = vec2( 1,  0);\n\toffsets[6] = vec2(-1,  1); offsets[7] = vec2( 0,  1); offsets[8] = vec2( 1,  1);\n\n\tfor(int i = 0; i < 9; i++) {\n\t\toffsets[i] = (offsets[i] * uSmudge) / uResolution;\n\t}\t\n\tvec4 smudgedColor = vec4(0.);\n\tfor(int i = 0; i < 9; i++) {\n\t\tsmudgedColor += texture2D(uBuffer, uv + offsets[i]);\n\t}\n\treturn smudgedColor / 9.0;\n}\n\nvec4 createMotionBlur(vec2 uv , vec4 baseColor, vec2 velocity) {\n\tvec2 scaledV = velocity * uMotionBlur;\n\tfor(int i = 1; i < uMotionSample; i++) {\n\t\tfloat t = float(i) / float(uMotionSample - 1);\n\t\tvec2 offset = t * scaledV / uResolution;\n\t\tbaseColor += texture2D(uBuffer, uv + offset);\n\t}\n\treturn baseColor / float(uMotionSample);\n}\n\nvoid main() {\n\n\tvec2 uv = vUv;\n\tif(uIsMap){\n\t\tvec2 mapColor = texture2D(uMap, uv).rg;\n\t\tvec2 normalizedMap = mapColor * 2.0 - 1.0;\n\t\tuv = uv * 2.0 - 1.0;\n\t\tuv *= mix(vec2(1.0), abs(normalizedMap.rg), uMapIntensity);\n\t\tuv = (uv + 1.0) / 2.0;\n\t}\n\tvec2 suv = uv*2.-1.;\n\n\tvec2 velocity = uVelocity * uResolution;\n\n\tfloat radius = max(0.0,uRadius);\n\t\n\tvec4 smudgedColor = uSmudge > 0. ? createSmudge(uv) : texture2D(uBuffer, uv);\n\n\tvec4 motionBlurredColor = uMotionBlur > 0. ? createMotionBlur(uv,smudgedColor, velocity) : smudgedColor;\n\n\tvec4 bufferColor = motionBlurredColor;\n\tbufferColor.a = bufferColor.a < 1e-10 ? 0.0 : bufferColor.a * uDissipation;\n\t\n\tvec4 brushColor = uIsTexture ? texture2D(uTexture, uv) : vec4(uColor,1.);\n\t\n\tfloat onLine = isOnLine(suv, uPrevMouse, uMouse, radius, uPressureStart,uPressureEnd);\n\tfloat isOnLine = length(velocity) > 0. ? onLine : uIsCursor ? onLine : 0.;\n\n\tvec4 finalColor = mix(bufferColor, brushColor, isOnLine);\n\n\tgl_FragColor = finalColor;\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\n/**\n * @params dpr if dpr is set, it returns the resolution which is size multiplied by dpr.\n */\nexport const useResolution = (size: Size, dpr: number | false = false) => {\n   const _width = dpr ? size.width * dpr : size.width;\n   const _height = dpr ? size.height * dpr : size.height;\n   const resolution = useMemo(\n      () => new THREE.Vector2(_width, _height),\n      [_width, _height]\n   );\n   return resolution;\n};\n","type UniformValue =\n   | THREE.CubeTexture\n   | THREE.Texture\n   | Int32Array\n   | Float32Array\n   | THREE.Matrix4\n   | THREE.Matrix3\n   | THREE.Quaternion\n   | THREE.Vector4\n   | THREE.Vector3\n   | THREE.Vector2\n   | THREE.Color\n   | number\n   | boolean\n   | Array<any>\n   | null\n   | undefined;\ntype UniformObject = { [key: string]: { value: UniformValue } };\n\nexport const setUniform = <T extends UniformObject>(\n   material: { uniforms: T },\n   key: keyof T,\n   value: UniformValue\n) => {\n   if (value === undefined) {\n      return;\n   }\n   // By design, I don't want to pass null to uniform\n   if (material.uniforms && material.uniforms[key] && value !== null) {\n      material.uniforms[key].value = value;\n   }\n};\n","import * as THREE from \"three\";\nimport { useEffect, useMemo } from \"react\";\n\ntype Object3DConstructor<T, M extends THREE.Material> = new (\n   geometry: THREE.BufferGeometry,\n   material: M\n) => T;\n\n/**\n * Add geometry and material to Object3D and add them to scene.\n */\nexport const useAddObject = <\n   T extends THREE.Object3D,\n   M extends THREE.Material\n>(\n   scene: THREE.Scene | false,\n   geometry: THREE.BufferGeometry,\n   material: M,\n   Proto: Object3DConstructor<T, M>\n) => {\n   const object3D = useMemo(() => {\n      const obj = new Proto(geometry, material);\n      scene && scene.add(obj);\n      return obj;\n   }, [geometry, material, Proto, scene]);\n\n   useEffect(() => {\n      return () => {\n         scene && scene.remove(object3D);\n         geometry.dispose();\n         material.dispose();\n      };\n   }, [scene, geometry, material, object3D]);\n\n   return object3D;\n};\n","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useEffect, useMemo } from \"react\";\nimport { useResolution } from \"../../../utils/useResolution\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class BrushMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uBuffer: { value: THREE.Texture };\n      uTexture: { value: THREE.Texture };\n      uIsTexture: { value: boolean };\n      uMap: { value: THREE.Texture };\n      uIsMap: { value: boolean };\n      uMapIntensity: { value: number };\n      uResolution: { value: THREE.Texture };\n      uRadius: { value: number };\n      uSmudge: { value: number };\n      uDissipation: { value: number };\n      uMotionBlur: { value: number };\n      uMotionSample: { value: number };\n      uMouse: { value: number };\n      uPrevMouse: { value: number };\n      uVelocity: { value: number };\n      uColor: { value: THREE.Vector3 | THREE.Color };\n      uIsCursor: { value: boolean };\n      uPressureStart: { value: number };\n      uPressureEnd: { value: number };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number | false;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uBuffer: { value: new THREE.Texture() },\n               uResolution: { value: new THREE.Vector2(0, 0) },\n               uTexture: { value: new THREE.Texture() },\n               uIsTexture: { value: false },\n               uMap: { value: new THREE.Texture() },\n               uIsMap: { value: false },\n               uMapIntensity: { value: 0.0 },\n               uRadius: { value: 0.0 },\n               uSmudge: { value: 0.0 },\n               uDissipation: { value: 0.0 },\n               uMotionBlur: { value: 0.0 },\n               uMotionSample: { value: 0 },\n               uMouse: { value: new THREE.Vector2(-10, -10) },\n               uPrevMouse: { value: new THREE.Vector2(-10, -10) },\n               uVelocity: { value: new THREE.Vector2(0, 0) },\n               uColor: { value: new THREE.Vector3(1, 0, 0) },\n               uIsCursor: { value: false },\n               uPressureStart: { value: 1.0 },\n               uPressureEnd: { value: 1.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as BrushMaterial;\n\n   const resolution = useResolution(size, dpr);\n   setUniform(material, \"uResolution\", resolution.clone());\n\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n\n   return { material, mesh };\n};\n","import * as THREE from \"three\";\nimport { useResolution } from \"./useResolution\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\nconst getCameraProps = (width: number, height: number) => {\n   const frustumSize = height;\n   const aspect = width / height;\n   const [w, h] = [(frustumSize * aspect) / 2, frustumSize / 2];\n   return { width: w, height: h, near: -1000, far: 1000 };\n};\n\nexport const useCamera = (\n   size: Size,\n   cameraType: \"OrthographicCamera\" | \"PerspectiveCamera\" = \"OrthographicCamera\"\n) => {\n   const resolution = useResolution(size);\n   const { width, height, near, far } = getCameraProps(\n      resolution.x,\n      resolution.y\n   );\n   const camera = useMemo(() => {\n      return cameraType === \"OrthographicCamera\"\n         ? new THREE.OrthographicCamera(\n              -width,\n              width,\n              height,\n              -height,\n              near,\n              far\n           )\n         : new THREE.PerspectiveCamera(50, width / height);\n   }, [width, height, near, far, cameraType]);\n   return camera;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useRef } from \"react\";\n\nexport type PointerValues = {\n   currentPointer: THREE.Vector2;\n   prevPointer: THREE.Vector2;\n   diffPointer: THREE.Vector2;\n   velocity: THREE.Vector2;\n   isVelocityUpdate: boolean;\n};\n\ntype UpdatePointer = (currentPointer: THREE.Vector2) => PointerValues;\n\n/**\n * @description When given the pointer vector2 from r3f's RootState, it generates an update function that returns {`currentPointer`, `prevPointer`, `diffPointer`, `isVelocityUpdate`, `velocity`}.\n * @description When calling custom in a `useFrame` loop, you can avoid duplication of execution by passing `pointerValues` to the update function of a Pointer-activated fxHook, such as `useBrush`.\n * @param lerp 0~1, lerp intensity (0 to less than 1) , default : `0`\n */\nexport const usePointer = (lerp: number = 0): UpdatePointer => {\n   const prevPointer = useRef(new THREE.Vector2(0, 0));\n   const diffPointer = useRef(new THREE.Vector2(0, 0));\n   const lerpPointer = useRef(new THREE.Vector2(0, 0));\n   const lastUpdateTime = useRef<number>(0);\n   const velocity = useRef(new THREE.Vector2(0, 0));\n   const isMoved = useRef(false);\n\n   const updatePointer = useCallback(\n      (currentPointer: THREE.Vector2) => {\n         const now = performance.now();\n\n         // lerp\n         let current: THREE.Vector2;\n         if (isMoved.current && lerp) {\n            lerpPointer.current = lerpPointer.current.lerp(\n               currentPointer,\n               1 - lerp\n            );\n            current = lerpPointer.current.clone();\n         } else {\n            current = currentPointer.clone();\n            lerpPointer.current = current;\n         }\n\n         // first frame\n         if (lastUpdateTime.current === 0) {\n            lastUpdateTime.current = now;\n            prevPointer.current = current;\n         }\n         const deltaTime = Math.max(1, now - lastUpdateTime.current);\n         lastUpdateTime.current = now;\n\n         // get velocity\n         velocity.current\n            .copy(current)\n            .sub(prevPointer.current)\n            .divideScalar(deltaTime);\n         const isUpdate = velocity.current.length() > 0;\n\n         //set prev temp pos\n         const prevTemp = isMoved.current\n            ? prevPointer.current.clone()\n            : current;\n         if (!isMoved.current && isUpdate) {\n            isMoved.current = true;\n         }\n         prevPointer.current = current;\n\n         return {\n            currentPointer: current,\n            prevPointer: prevTemp,\n            diffPointer: diffPointer.current.subVectors(current, prevTemp),\n            velocity: velocity.current,\n            isVelocityUpdate: isUpdate,\n         };\n      },\n      [lerp]\n   );\n\n   return updatePointer;\n};\n","import { useCallback, useRef } from \"react\";\n\ntype UseParamsReturn<T> = [T, (params: Partial<T>) => void];\n\n/**\n * @param params Receives an initial value object. With structuredClone, deep copy and set, but if the object contains a function, just set it.\n */\nexport const useParams = <T extends object>(params: T): UseParamsReturn<T> => {\n   const isContainsFunctions = (obj: object): boolean =>\n      Object.values(obj).some((value) => typeof value === \"function\");\n   const paramsRef = useRef(\n      isContainsFunctions(params) ? params : structuredClone(params)\n   );\n\n   const setParams = useCallback((updateParams: Partial<T>) => {\n      for (const key in updateParams) {\n         const paramKey = key as keyof T;\n         if (\n            paramKey in paramsRef.current &&\n            updateParams[paramKey] !== undefined &&\n            updateParams[paramKey] !== null\n         ) {\n            paramsRef.current[paramKey] = updateParams[paramKey]!;\n         } else {\n            console.error(\n               `\"${String(\n                  paramKey\n               )}\" does not exist in the params. or \"${String(\n                  paramKey\n               )}\" is null | undefined`\n            );\n         }\n      }\n   }, []);\n   return [paramsRef.current, setParams];\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { useResolution } from \"./useResolution\";\nimport { Size } from \"@react-three/fiber\";\n\nexport const FBO_OPTION: THREE.RenderTargetOptions = {\n   minFilter: THREE.LinearFilter,\n   magFilter: THREE.LinearFilter,\n   type: THREE.HalfFloatType,\n   stencilBuffer: false,\n};\n\nexport type UseFboProps = {\n   scene: THREE.Scene;\n   camera: THREE.Camera;\n   size: Size;\n   /** If dpr is set, dpr will be multiplied, default : `false` */\n   dpr?: number | false;\n   /** Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default : `false` */\n   isSizeUpdate?: boolean;\n   /** Defines the count of MSAA samples. Can only be used with WebGL 2. default : `0.0` */\n   samples?: number;\n   /** Renders to the depth buffer. Unlike the three.js, default : `false` */\n   depthBuffer?: boolean;\n   /** If set, the scene depth will be rendered to this texture. default : `false` */\n   depthTexture?: boolean;\n};\n\nexport const renderFBO = ({\n   gl,\n   fbo,\n   scene,\n   camera,\n   onBeforeRender,\n   onSwap,\n}: {\n   gl: THREE.WebGLRenderer;\n   fbo: THREE.WebGLRenderTarget;\n   scene: THREE.Scene;\n   camera: THREE.Camera;\n   onBeforeRender: () => void;\n   onSwap?: () => void;\n}) => {\n   gl.setRenderTarget(fbo);\n   onBeforeRender();\n   gl.clear();\n   gl.render(scene, camera);\n   onSwap && onSwap();\n   gl.setRenderTarget(null);\n   gl.clear();\n};\n\ntype UpdateRenderTarget = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({ read }: { read: THREE.Texture }) => void\n) => THREE.Texture;\n\ntype UseSingleFBOReturn = [THREE.WebGLRenderTarget, UpdateRenderTarget];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [THREE.WebGLRenderTarget , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useSingleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n   samples = 0,\n   depthBuffer = false,\n   depthTexture = false,\n}: UseFboProps): UseSingleFBOReturn => {\n   const renderTarget = useRef<THREE.WebGLRenderTarget>();\n\n   const resolution = useResolution(size, dpr);\n\n   renderTarget.current = useMemo(\n      () => {\n         const target = new THREE.WebGLRenderTarget(\n            resolution.x,\n            resolution.y,\n            {\n               ...FBO_OPTION,\n               samples,\n               depthBuffer,\n            }\n         );\n         if (depthTexture) {\n            target.depthTexture = new THREE.DepthTexture(\n               resolution.x,\n               resolution.y,\n               THREE.FloatType\n            );\n         }\n         return target;\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      []\n   );\n\n   if (isSizeUpdate) {\n      renderTarget.current?.setSize(resolution.x, resolution.y);\n   }\n\n   useEffect(() => {\n      const temp = renderTarget.current;\n      return () => {\n         temp?.dispose();\n      };\n   }, []);\n\n   const updateRenderTarget: UpdateRenderTarget = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current!;\n         renderFBO({\n            gl,\n            fbo,\n            scene,\n            camera,\n            onBeforeRender: () =>\n               onBeforeRender && onBeforeRender({ read: fbo.texture }),\n         });\n         return fbo.texture;\n      },\n      [scene, camera]\n   );\n\n   return [renderTarget.current, updateRenderTarget];\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { FBO_OPTION, UseFboProps, renderFBO } from \"./useSingleFBO\";\nimport { useResolution } from \"./useResolution\";\n\nexport type DoubleRenderTarget = {\n   read: THREE.WebGLRenderTarget | null;\n   write: THREE.WebGLRenderTarget | null;\n};\n\ninterface WebGLDoubleRenderTarget extends DoubleRenderTarget {\n   swap: () => void;\n}\n\ntype FBOUpdateFunction = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({\n      read,\n      write,\n   }: {\n      read: THREE.Texture;\n      write: THREE.Texture;\n   }) => void\n) => THREE.Texture;\n\ntype UseDoubleFBOReturn = [\n   { read: THREE.WebGLRenderTarget; write: THREE.WebGLRenderTarget },\n   FBOUpdateFunction\n];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default : `false`\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default : `false`\n * @returns [{read:THREE.WebGLRenderTarget,write:THREE.WebGLRenderTarget} , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useDoubleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n   samples = 0,\n   depthBuffer = false,\n   depthTexture = false,\n}: UseFboProps): UseDoubleFBOReturn => {\n   const renderTarget = useRef<WebGLDoubleRenderTarget>({\n      read: null,\n      write: null,\n      swap: function () {\n         let temp = this.read;\n         this.read = this.write;\n         this.write = temp;\n      },\n   });\n\n   const resolution = useResolution(size, dpr);\n\n   const initRenderTargets = useMemo(() => {\n      const read = new THREE.WebGLRenderTarget(resolution.x, resolution.y, {\n         ...FBO_OPTION,\n         samples,\n         depthBuffer,\n      });\n      const write = new THREE.WebGLRenderTarget(resolution.x, resolution.y, {\n         ...FBO_OPTION,\n         samples,\n         depthBuffer,\n      });\n\n      if (depthTexture) {\n         read.depthTexture = new THREE.DepthTexture(\n            resolution.x,\n            resolution.y,\n            THREE.FloatType\n         );\n         write.depthTexture = new THREE.DepthTexture(\n            resolution.x,\n            resolution.y,\n            THREE.FloatType\n         );\n      }\n\n      return { read, write };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, []);\n\n   renderTarget.current.read = initRenderTargets.read;\n   renderTarget.current.write = initRenderTargets.write;\n\n   if (isSizeUpdate) {\n      renderTarget.current.read?.setSize(resolution.x, resolution.y);\n      renderTarget.current.write?.setSize(resolution.x, resolution.y);\n   }\n\n   useEffect(() => {\n      const temp = renderTarget.current;\n      return () => {\n         temp.read?.dispose();\n         temp.write?.dispose();\n      };\n   }, []);\n\n   const updateRenderTarget: FBOUpdateFunction = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current;\n         renderFBO({\n            gl,\n            scene,\n            camera,\n            fbo: fbo.write!,\n            onBeforeRender: () =>\n               onBeforeRender &&\n               onBeforeRender({\n                  read: fbo.read!.texture,\n                  write: fbo.write!.texture,\n               }),\n            onSwap: () => fbo.swap(),\n         });\n         return fbo.read?.texture as THREE.Texture;\n      },\n      [scene, camera]\n   );\n\n   return [\n      { read: renderTarget.current.read, write: renderTarget.current.write },\n      updateRenderTarget,\n   ];\n};\n","import { Dpr } from \"../fxs/types\";\n\nexport const getDpr = (\n   dpr: Dpr\n): { shader: number | false; fbo: number | false } => {\n   if (typeof dpr === \"number\") {\n      return { shader: dpr, fbo: dpr };\n   }\n   // use dpr if `shader` and `fbo` are undefined\n   return {\n      shader: (dpr.effect?.shader ?? true) && dpr.dpr,\n      fbo: (dpr.effect?.fbo ?? true) && dpr.dpr,\n   };\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { RootState } from \"@react-three/fiber\";\nimport { PointerValues, usePointer } from \"../../../misc/usePointer\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { DoubleRenderTarget, useDoubleFBO } from \"../../../utils/useDoubleFBO\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type BrushParams = {\n   /** Texture applied to the brush, If texture is true, it will take precedence over color , default : `false` */\n   texture?: THREE.Texture | false;\n   /** You can attach an fx map , default : `false` */\n   map?: THREE.Texture | false;\n   /** map intensity , default : `0.1` */\n   mapIntensity?: number;\n   /** size of the stamp, percentage of the size ,default : `0.05` */\n   radius?: number;\n   /** Strength of smudge effect , default : `0.0`*/\n   smudge?: number;\n   /** dissipation rate. If set to 1, it will remain. , default : `1.0` */\n   dissipation?: number;\n   /** Strength of motion blur , default : `0.0` */\n   motionBlur?: number;\n   /** Number of motion blur samples. Affects performance default : `5` */\n   motionSample?: number;\n   /** brush color , it accepts a function that returns THREE.Vector3.The function takes velocity:THREE.Vector2 as an argument. , default : `THREE.Vector3(1.0, 1.0, 1.0)` */\n   color?:\n      | ((velocity: THREE.Vector2) => THREE.Vector3)\n      | THREE.Vector3\n      | THREE.Color;\n   /** Follows the cursor even if it loses speed , default : `false` */\n   isCursor?: boolean;\n   /** brush pressure (0 to 1) , default : `1.0` */\n   pressure?: number;\n   /** When calling usePointer in a frame loop, setting PointerValues ​​to this value prevents double calls , default : `false` */\n   pointerValues?: PointerValues | false;\n};\n\nexport type BrushObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: DoubleRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const BRUSH_PARAMS: BrushParams = Object.freeze({\n   texture: false,\n   map: false,\n   mapIntensity: 0.1,\n   radius: 0.05,\n   smudge: 0.0,\n   dissipation: 1.0,\n   motionBlur: 0.0,\n   motionSample: 5,\n   color: new THREE.Vector3(1.0, 0.0, 0.0),\n   isCursor: false,\n   pressure: 1.0,\n   pointerValues: false,\n});\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useBrush = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<BrushParams, BrushObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh({ scene, size, dpr: _dpr.shader });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useDoubleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] = useParams<BrushParams>(BRUSH_PARAMS);\n\n   const pressureEnd = useRef<number | null>(null);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: BrushParams) => {\n         const { gl, pointer } = props;\n\n         updateParams && setParams(updateParams);\n\n         if (params.texture!) {\n            setUniform(material, \"uIsTexture\", true);\n            setUniform(material, \"uTexture\", params.texture!);\n         } else {\n            setUniform(material, \"uIsTexture\", false);\n         }\n\n         if (params.map!) {\n            setUniform(material, \"uIsMap\", true);\n            setUniform(material, \"uMap\", params.map!);\n            setUniform(material, \"uMapIntensity\", params.mapIntensity!);\n         } else {\n            setUniform(material, \"uIsMap\", false);\n         }\n\n         setUniform(material, \"uRadius\", params.radius!);\n         setUniform(material, \"uSmudge\", params.smudge!);\n         setUniform(material, \"uDissipation\", params.dissipation!);\n         setUniform(material, \"uMotionBlur\", params.motionBlur!);\n         setUniform(material, \"uMotionSample\", params.motionSample!);\n\n         const pointerValues = params.pointerValues! || updatePointer(pointer);\n\n         if (pointerValues.isVelocityUpdate) {\n            setUniform(material, \"uMouse\", pointerValues.currentPointer);\n            setUniform(material, \"uPrevMouse\", pointerValues.prevPointer);\n         }\n         setUniform(material, \"uVelocity\", pointerValues.velocity);\n\n         const color: THREE.Vector3 | THREE.Color =\n            typeof params.color === \"function\"\n               ? params.color(pointerValues.velocity)\n               : params.color!;\n         setUniform(material, \"uColor\", color);\n\n         setUniform(material, \"uIsCursor\", params.isCursor!);\n\n         // pressure\n         setUniform(material, \"uPressureEnd\", params.pressure!);\n         if (pressureEnd.current === null) {\n            pressureEnd.current = params.pressure!;\n         }\n         setUniform(material, \"uPressureStart\", pressureEnd.current);\n         pressureEnd.current = params.pressure!;\n\n         return updateRenderTarget(gl, ({ read }) => {\n            setUniform(material, \"uBuffer\", read);\n         });\n      },\n      [material, updatePointer, updateRenderTarget, params, setParams]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.read.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform vec2 texelSize;\n\nvoid main () {\n\tvUv = uv;\n\tvL = vUv - vec2(texelSize.x, 0.0);\n\tvR = vUv + vec2(texelSize.x, 0.0);\n\tvT = vUv + vec2(0.0, texelSize.y);\n\tvB = vUv - vec2(0.0, texelSize.y);\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvoid main(){\n\tgl_FragColor = vec4(0.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/init.frag\";\n\nexport const useInitialMaterial = () => {\n   const initialMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      []\n   );\n\n   return initialMaterial as THREE.ShaderMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D uVelocity;\nuniform sampler2D uSource;\nuniform vec2 texelSize;\nuniform float dt;\nuniform float dissipation;\n\nvoid main () {\n\tvec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n\tgl_FragColor = dissipation * texture2D(uSource, coord);\n\tgl_FragColor.a = 1.0;\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/advection.frag\";\n\nexport class AdvectionMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uVelocity: { value: THREE.Texture };\n      uSource: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n      dt: { value: number };\n      dissipation: { value: number };\n   };\n}\n\nexport const useAdvectionMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: new THREE.Texture() },\n               uSource: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n               dt: { value: 0.0 },\n               dissipation: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as AdvectionMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvec2 sampleVelocity (in vec2 uv) {\n\tvec2 multiplier = vec2(1.0, 1.0);\n\tif (uv.x < 0.0) { uv.x = 0.0; multiplier.x = -1.0; }\n\tif (uv.x > 1.0) { uv.x = 1.0; multiplier.x = -1.0; }\n\tif (uv.y < 0.0) { uv.y = 0.0; multiplier.y = -1.0; }\n\tif (uv.y > 1.0) { uv.y = 1.0; multiplier.y = -1.0; }\n\treturn multiplier * texture2D(uVelocity, uv).xy;\n}\n\nvoid main () {\n\tfloat L = sampleVelocity(vL).x;\n\tfloat R = sampleVelocity(vR).x;\n\tfloat T = sampleVelocity(vT).y;\n\tfloat B = sampleVelocity(vB).y;\n\tfloat div = 0.5 * (R - L + T - B);\n\tgl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/divergence.frag\";\n\nexport class DivergenceMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uVelocity: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useDivergenceMaterial = () => {\n   const divergenceMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return divergenceMaterial as DivergenceMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uDivergence;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tfloat C = texture2D(uPressure, vUv).x;\n\tfloat divergence = texture2D(uDivergence, vUv).x;\n\tfloat pressure = (L + R + B + T - divergence) * 0.25;\n\tgl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/pressure.frag\";\n\nexport class PressureMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uPressure: { value: THREE.Texture };\n      uDivergence: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const usePressureMaterial = () => {\n   const pressureMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: null },\n               uDivergence: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return pressureMaterial as PressureMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvoid main () {\n\tfloat L = texture2D(uVelocity, vL).y;\n\tfloat R = texture2D(uVelocity, vR).y;\n\tfloat T = texture2D(uVelocity, vT).x;\n\tfloat B = texture2D(uVelocity, vB).x;\n\tfloat vorticity = R - L - T + B;\n\tgl_FragColor = vec4(vorticity, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/curl.frag\";\n\nexport class CurlMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uVelocity: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useCurlMaterial = () => {\n   const curlMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return curlMaterial as CurlMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\nuniform sampler2D uCurl;\nuniform float curl;\nuniform float dt;\n\nvoid main () {\n\tfloat T = texture2D(uCurl, vT).x;\n\tfloat B = texture2D(uCurl, vB).x;\n\tfloat C = texture2D(uCurl, vUv).x;\n\tvec2 force = vec2(abs(T) - abs(B), 0.0);\n\tforce *= 1.0 / length(force + 0.00001) * curl * C;\n\tvec2 vel = texture2D(uVelocity, vUv).xy;\n\tgl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/vorticity.frag\";\n\nexport class VorticityMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uVelocity: { value: THREE.Texture };\n      uCurl: { value: THREE.Texture };\n      curl: { value: number };\n      dt: { value: number };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useVorticityMaterial = () => {\n   const vorticityMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               uCurl: { value: null },\n               curl: { value: 0 },\n               dt: { value: 0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return vorticityMaterial as VorticityMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform float value;\n\nvoid main () {\n\tgl_FragColor = value * texture2D(uTexture, vUv);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/clear.frag\";\n\nexport class ClearMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      value: { value: number };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useClearMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               value: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as ClearMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uVelocity;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tvec2 velocity = texture2D(uVelocity, vUv).xy;\n\tvelocity.xy -= vec2(R - L, T - B);\n\tgl_FragColor = vec4(velocity, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/gradientSubtract.frag\";\n\nexport class GradientSubtractMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uPressure: { value: THREE.Texture };\n      uVelocity: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useGradientSubtractMaterial = () => {\n   const gradientSubtractMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: new THREE.Texture() },\n               uVelocity: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return gradientSubtractMaterial as GradientSubtractMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D uTarget;\nuniform float aspectRatio;\nuniform vec3 color;\nuniform vec2 point;\nuniform float radius;\n\nvoid main () {\n\tvec2 nPoint = (point + vec2(1.0)) * 0.5;\n\tvec2 p = vUv - nPoint.xy;\n\tp.x *= aspectRatio;\n\tvec3 splat = exp(-dot(p, p) / radius) * color;\n\tvec3 base = texture2D(uTarget, vUv).xyz;\n\tgl_FragColor = vec4(base + splat, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/splat.frag\";\n\nexport class SplatMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTarget: { value: THREE.Texture };\n      aspectRatio: { value: number };\n      color: { value: THREE.Vector3 | THREE.Color };\n      point: { value: THREE.Vector2 };\n      radius: { value: number };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useSplateMaterial = () => {\n   const splatMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTarget: { value: new THREE.Texture() },\n               aspectRatio: { value: 0 },\n               color: { value: new THREE.Vector3() },\n               point: { value: new THREE.Vector2() },\n               radius: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return splatMaterial as SplatMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo } from \"react\";\nimport { useInitialMaterial } from \"./materials/useInitialMaterial\";\nimport {\n   AdvectionMaterial,\n   useAdvectionMaterial,\n} from \"./materials/useAdvectionMaterial\";\nimport {\n   DivergenceMaterial,\n   useDivergenceMaterial,\n} from \"./materials/useDivergenceMaterial\";\nimport {\n   PressureMaterial,\n   usePressureMaterial,\n} from \"./materials/usePressureMaterial\";\nimport { CurlMaterial, useCurlMaterial } from \"./materials/useCurlMaterial\";\nimport {\n   VorticityMaterial,\n   useVorticityMaterial,\n} from \"./materials/useVorticityMaterial\";\nimport { useResolution } from \"../../../utils/useResolution\";\nimport { ClearMaterial, useClearMaterial } from \"./materials/useClearMaterial\";\nimport {\n   GradientSubtractMaterial,\n   useGradientSubtractMaterial,\n} from \"./materials/useGradientSubtractMaterial\";\nimport { SplatMaterial, useSplateMaterial } from \"./materials/useSplatMaterial\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\ntype TMaterials =\n   | AdvectionMaterial\n   | DivergenceMaterial\n   | CurlMaterial\n   | PressureMaterial\n   | ClearMaterial\n   | GradientSubtractMaterial\n   | SplatMaterial;\n\nexport type FluidMaterials = {\n   vorticityMaterial: VorticityMaterial;\n   curlMaterial: CurlMaterial;\n   advectionMaterial: AdvectionMaterial;\n   divergenceMaterial: DivergenceMaterial;\n   pressureMaterial: PressureMaterial;\n   clearMaterial: ClearMaterial;\n   gradientSubtractMaterial: GradientSubtractMaterial;\n   splatMaterial: SplatMaterial;\n};\n\n/**\n * Returns the material update function in the second argument\n */\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number | false;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const initialMaterial = useInitialMaterial();\n   const updateMaterial = initialMaterial.clone();\n   const curlMaterial = useCurlMaterial();\n   const vorticityMaterial = useVorticityMaterial();\n   const advectionMaterial = useAdvectionMaterial();\n   const divergenceMaterial = useDivergenceMaterial();\n   const pressureMaterial = usePressureMaterial();\n   const clearMaterial = useClearMaterial();\n   const gradientSubtractMaterial = useGradientSubtractMaterial();\n   const splatMaterial = useSplateMaterial();\n   const materials = useMemo(\n      () => ({\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      }),\n      [\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      ]\n   );\n\n   const resolution = useResolution(size, dpr);\n   useMemo(() => {\n      setUniform(\n         materials.splatMaterial,\n         \"aspectRatio\",\n         resolution.x / resolution.y\n      );\n      for (const material of Object.values(materials)) {\n         setUniform<typeof material.uniforms>(\n            material,\n            \"texelSize\",\n            new THREE.Vector2(1.0 / resolution.x, 1.0 / resolution.y)\n         );\n      }\n   }, [resolution, materials]);\n\n   const mesh = useAddObject(scene, geometry, initialMaterial, THREE.Mesh);\n\n   useMemo(() => {\n      initialMaterial.dispose();\n      mesh.material = updateMaterial;\n   }, [initialMaterial, mesh, updateMaterial]);\n\n   useEffect(() => {\n      return () => {\n         for (const material of Object.values(materials)) {\n            material.dispose();\n         }\n      };\n   }, [materials]);\n\n   const setMeshMaterial = useCallback(\n      (material: TMaterials) => {\n         mesh.material = material;\n         mesh.material.needsUpdate = true;\n      },\n      [mesh]\n   );\n\n   return { materials, setMeshMaterial, mesh };\n};\n","import * as THREE from \"three\";\nimport { FluidMaterials, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { PointerValues, usePointer } from \"../../../misc/usePointer\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { UseFboProps } from \"../../../utils/useSingleFBO\";\nimport { DoubleRenderTarget, useDoubleFBO } from \"../../../utils/useDoubleFBO\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type FluidParams = {\n   /** density disspation , default : `0.98` */\n   density_dissipation?: number;\n   /** velocity dissipation , default : `0.99` */\n   velocity_dissipation?: number;\n   /** velocity acceleration , default : `10.0` */\n   velocity_acceleration?: number;\n   /** pressure dissipation , default : `0.9` */\n   pressure_dissipation?: number;\n   /** pressure iterations. affects performance , default : `20` */\n   pressure_iterations?: number;\n   /** curl_strength , default : `35` */\n   curl_strength?: number;\n   /** splat radius , default : `0.002` */\n   splat_radius?: number;\n   /** Fluid Color.THREE.Vector3 Alternatively, it accepts a function that returns THREE.Vector3.The function takes velocity:THREE.Vector2 as an argument. , default : `THREE.Vector3(1.0, 1.0, 1.0)` */\n   fluid_color?:\n      | ((velocity: THREE.Vector2) => THREE.Vector3)\n      | THREE.Vector3\n      | THREE.Color;\n   /** When calling usePointer in a frame loop, setting PointerValues ​​to this value prevents double calls , default : `false` */\n   pointerValues?: PointerValues | false;\n};\n\nexport type FluidObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   materials: FluidMaterials;\n   camera: THREE.Camera;\n   renderTarget: {\n      velocity: DoubleRenderTarget;\n      density: DoubleRenderTarget;\n      curl: THREE.WebGLRenderTarget;\n      divergence: THREE.WebGLRenderTarget;\n      pressure: DoubleRenderTarget;\n   };\n   output: THREE.Texture;\n};\n\nexport const FLUID_PARAMS: FluidParams = Object.freeze({\n   density_dissipation: 0.98,\n   velocity_dissipation: 0.99,\n   velocity_acceleration: 10.0,\n   pressure_dissipation: 0.9,\n   pressure_iterations: 20,\n   curl_strength: 35,\n   splat_radius: 0.002,\n   fluid_color: new THREE.Vector3(1.0, 1.0, 1.0),\n   pointerValues: false,\n});\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useFluid = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<FluidParams, FluidObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { materials, setMeshMaterial, mesh } = useMesh({\n      scene,\n      size,\n      dpr: _dpr.shader,\n   });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n\n   const fboProps = useMemo<UseFboProps>(\n      () => ({\n         scene,\n         camera,\n         dpr: _dpr.fbo,\n         size,\n         samples,\n      }),\n      [scene, camera, size, samples, _dpr.fbo]\n   );\n   const [velocityFBO, updateVelocityFBO] = useDoubleFBO(fboProps);\n   const [densityFBO, updateDensityFBO] = useDoubleFBO(fboProps);\n   const [curlFBO, updateCurlFBO] = useSingleFBO(fboProps);\n   const [divergenceFBO, updateDivergenceFBO] = useSingleFBO(fboProps);\n   const [pressureFBO, updatePressureFBO] = useDoubleFBO(fboProps);\n\n   const lastTime = useRef(0);\n   const scaledDiffVec = useRef(new THREE.Vector2(0, 0));\n   const spaltVec = useRef(new THREE.Vector3(0, 0, 0));\n\n   const [params, setParams] = useParams<FluidParams>(FLUID_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FluidParams) => {\n         const { gl, pointer, clock, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         if (lastTime.current === 0) {\n            lastTime.current = clock.getElapsedTime();\n         }\n         const dt = Math.min(\n            (clock.getElapsedTime() - lastTime.current) / 3,\n            0.02\n         );\n         lastTime.current = clock.getElapsedTime();\n\n         // update velocity\n         const velocityTex = updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", read);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(materials.advectionMaterial, \"dt\", dt);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.velocity_dissipation!\n            );\n         });\n\n         // update density\n         const densityTex = updateDensityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", velocityTex);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.density_dissipation!\n            );\n         });\n\n         // update splatting\n         const pointerValues = params.pointerValues! || updatePointer(pointer);\n\n         if (pointerValues.isVelocityUpdate) {\n            updateVelocityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               setUniform(\n                  materials.splatMaterial,\n                  \"point\",\n                  pointerValues.currentPointer\n               );\n               const scaledDiff = pointerValues.diffPointer.multiply(\n                  scaledDiffVec.current\n                     .set(size.width, size.height)\n                     .multiplyScalar(params.velocity_acceleration!)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"color\",\n                  spaltVec.current.set(scaledDiff.x, scaledDiff.y, 1.0)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"radius\",\n                  params.splat_radius!\n               );\n            });\n            updateDensityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               const color: THREE.Vector3 | THREE.Color =\n                  typeof params.fluid_color === \"function\"\n                     ? params.fluid_color(pointerValues.velocity)\n                     : params.fluid_color!;\n               setUniform(materials.splatMaterial, \"color\", color);\n            });\n         }\n\n         // update curl\n         const curlTex = updateCurlFBO(gl, () => {\n            setMeshMaterial(materials.curlMaterial);\n            setUniform(materials.curlMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update vorticity\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.vorticityMaterial);\n            setUniform(materials.vorticityMaterial, \"uVelocity\", read);\n            setUniform(materials.vorticityMaterial, \"uCurl\", curlTex);\n            setUniform(\n               materials.vorticityMaterial,\n               \"curl\",\n               params.curl_strength!\n            );\n            setUniform(materials.vorticityMaterial, \"dt\", dt);\n         });\n\n         // update divergence\n         const divergenceTex = updateDivergenceFBO(gl, () => {\n            setMeshMaterial(materials.divergenceMaterial);\n            setUniform(materials.divergenceMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update pressure\n         updatePressureFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.clearMaterial);\n            setUniform(materials.clearMaterial, \"uTexture\", read);\n            setUniform(\n               materials.clearMaterial,\n               \"value\",\n               params.pressure_dissipation!\n            );\n         });\n\n         // solve pressure iterative (Gauss-Seidel)\n         setMeshMaterial(materials.pressureMaterial);\n         setUniform(materials.pressureMaterial, \"uDivergence\", divergenceTex);\n         let pressureTexTemp: THREE.Texture;\n         for (let i = 0; i < params.pressure_iterations!; i++) {\n            pressureTexTemp = updatePressureFBO(gl, ({ read }) => {\n               setUniform(materials.pressureMaterial, \"uPressure\", read);\n            });\n         }\n\n         // update gradienSubtract\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.gradientSubtractMaterial);\n            setUniform(\n               materials.gradientSubtractMaterial,\n               \"uPressure\",\n               pressureTexTemp\n            );\n            setUniform(materials.gradientSubtractMaterial, \"uVelocity\", read);\n         });\n\n         return densityTex;\n      },\n      [\n         materials,\n         setMeshMaterial,\n         updateCurlFBO,\n         updateDensityFBO,\n         updateDivergenceFBO,\n         updatePointer,\n         updatePressureFBO,\n         updateVelocityFBO,\n         setParams,\n         params,\n      ]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         materials: materials,\n         camera: camera,\n         renderTarget: {\n            velocity: velocityFBO,\n            density: densityFBO,\n            curl: curlFBO,\n            divergence: divergenceFBO,\n            pressure: pressureFBO,\n         },\n         output: densityFBO.read.texture,\n      },\n   ];\n};\n","import { useEffect, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\n\ntype UseMeshProps = {\n   scale: number;\n   max: number;\n   texture?: THREE.Texture;\n   scene: THREE.Scene;\n};\n\nexport const useMesh = ({ scale, max, texture, scene }: UseMeshProps) => {\n   const meshArr = useRef<THREE.Mesh[]>([]);\n   const geometry = useMemo(\n      () => new THREE.PlaneGeometry(scale, scale),\n      [scale]\n   );\n   const material = useMemo(\n      () =>\n         new THREE.MeshBasicMaterial({\n            map: texture,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      [texture]\n   );\n\n   useEffect(() => {\n      for (let i = 0; i < max; i++) {\n         const mesh = new THREE.Mesh(geometry.clone(), material.clone());\n         mesh.rotateZ(2 * Math.PI * Math.random());\n         mesh.visible = false;\n         scene.add(mesh);\n         meshArr.current.push(mesh);\n      }\n   }, [geometry, material, scene, max]);\n\n   useEffect(() => {\n      return () => {\n         meshArr.current.forEach((mesh) => {\n            mesh.geometry.dispose();\n            if (Array.isArray(mesh.material)) {\n               mesh.material.forEach((material) => material.dispose());\n            } else {\n               mesh.material.dispose();\n            }\n            scene.remove(mesh);\n         });\n         meshArr.current = [];\n      };\n   }, [scene]);\n\n   return meshArr.current;\n};\n","import { useCallback, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { usePointer, PointerValues } from \"../../../misc/usePointer\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type RippleParams = {\n   /** How often ripples appear, default : `0.01` */\n   frequency?: number;\n   /** rotation rate, default : `0.05` */\n   rotation?: number;\n   /** fadeout speed, default : `0.9` */\n   fadeout_speed?: number;\n   /** scale rate, default : `0.3` */\n   scale?: number;\n   /** alpha, default : `0.6` */\n   alpha?: number;\n   /** When calling usePointer in a frame loop, setting PointerValues ​​to this value prevents double calls , default : `false` */\n   pointerValues?: PointerValues | false;\n};\n\nexport type RippleObject = {\n   scene: THREE.Scene;\n   meshArr: THREE.Mesh[];\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const RIPPLE_PARAMS: RippleParams = Object.freeze({\n   frequency: 0.01,\n   rotation: 0.05,\n   fadeout_speed: 0.9,\n   scale: 0.3,\n   alpha: 0.6,\n   pointerValues: false,\n});\n\ninterface UseRippleProps extends HooksProps {\n   /** texture applied to ripple */\n   texture?: THREE.Texture;\n   /** ripple size, default:64 */\n   scale?: number;\n   /** ripple max length, default:100 */\n   max?: number;\n}\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useRipple = ({\n   texture = new THREE.Texture(),\n   scale = 64,\n   max = 100,\n   size,\n   dpr,\n   samples = 0,\n}: UseRippleProps): HooksReturn<RippleParams, RippleObject> => {\n   const _dpr = getDpr(dpr);\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const meshArr = useMesh({\n      scale: scale,\n      max: max,\n      texture,\n      scene,\n   });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] = useParams<RippleParams>(RIPPLE_PARAMS);\n\n   const currentWave = useRef(0);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: RippleParams) => {\n         const { gl, pointer, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         const pointerValues = params.pointerValues! || updatePointer(pointer);\n\n         if (params.frequency! < pointerValues.diffPointer.length()) {\n            const mesh = meshArr[currentWave.current];\n            mesh.visible = true;\n            mesh.position.set(\n               pointerValues.currentPointer.x * (size.width / 2),\n               pointerValues.currentPointer.y * (size.height / 2),\n               0\n            );\n            mesh.scale.x = mesh.scale.y = 0.0;\n            (mesh.material as THREE.MeshBasicMaterial).opacity = params.alpha!;\n            currentWave.current = (currentWave.current + 1) % max;\n         }\n         meshArr.forEach((mesh) => {\n            if (mesh.visible) {\n               const material = mesh.material as THREE.MeshBasicMaterial;\n               mesh.rotation.z += params.rotation!;\n               material.opacity *= params.fadeout_speed!;\n               mesh.scale.x =\n                  params.fadeout_speed! * mesh.scale.x + params.scale!;\n               mesh.scale.y = mesh.scale.x;\n               if (material.opacity < 0.002) mesh.visible = false;\n            }\n         });\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, meshArr, updatePointer, max, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         camera: camera,\n         meshArr: meshArr,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\nprecision highp int;\n\nvarying vec2 vUv;\nuniform float uTime;\nuniform float timeStrength;\nuniform int noiseOctaves;\nuniform int fbmOctaves;\nuniform int warpOctaves;\nuniform vec2 warpDirection;\nuniform float warpStrength;\nuniform float scale;\n\nconst float per  = 0.5;\nconst float PI   = 3.14159265359;\n\nfloat rnd(vec2 n) {\n\tfloat a = 0.129898;\n\tfloat b = 0.78233;\n\tfloat c = 437.585453;\n\tfloat dt= dot(n ,vec2(a, b));\n\tfloat sn= mod(dt, PI);\n\treturn fract(sin(sn) * c);\n}\n\nfloat interpolate(float a, float b, float x){\n    float f = (1.0 - cos(x * PI)) * 0.5;\n    return a * (1.0 - f) + b * f;\n}\n\nfloat irnd(vec2 p){\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tvec4 v = vec4(rnd(vec2(i.x,i.y)),rnd(vec2(i.x + 1.0,i.y)),rnd(vec2(i.x,i.y + 1.0)),rnd(vec2(i.x + 1.0, i.y + 1.0)));\n\treturn interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);\n}\n\n// Based on The Book of Shaders\n// https://thebookofshaders.com/13/\nfloat noise(vec2 p, float time){\n\tfloat t = 0.0;\n\tfor(int i = 0; i < noiseOctaves; i++){\n\t\tfloat freq = pow(2.0, float(i));\n\t\tfloat amp  = pow(per, float(noiseOctaves - i));\n\t\tt += irnd(vec2(p.y / freq + time, p.x / freq + time)) * amp;\n\t}\n\treturn t;\n}\n\nfloat fbm(vec2 x, float time) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n\tfloat sign = 1.0;\n\tfor (int i = 0; i < fbmOctaves; ++i) {\n\t\tv += a * noise(x, time * sign);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t\tsign *= -1.0;\n\t}\n\treturn v;\n}\n\nfloat warp(vec2 x, float g,float time){\n\tfloat val = 0.0;\n\tfor (int i = 0; i < warpOctaves; i++){\n\t\tval = fbm(x + g * vec2(cos(warpDirection.x * val), sin(warpDirection.y * val)), time);\n\t}\n\treturn val;\n}\n\nvoid main() {\n\tfloat noise = warp(gl_FragCoord.xy * scale ,warpStrength,uTime * timeStrength);\n\tgl_FragColor = vec4(vec3(noise),1.0);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class NoiseMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTime: { value: number };\n      scale: { value: number };\n      timeStrength: { value: number };\n      noiseOctaves: { value: number };\n      fbmOctaves: { value: number };\n      warpOctaves: { value: number };\n      warpDirection: { value: THREE.Vector2 };\n      warpStrength: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTime: { value: 0.0 },\n               scale: { value: 0.0 },\n               timeStrength: { value: 0.0 },\n               noiseOctaves: { value: 0 },\n               fbmOctaves: { value: 0 },\n               warpOctaves: { value: 0 },\n               warpDirection: { value: new THREE.Vector2() },\n               warpStrength: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as NoiseMaterial;\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n   return { material, mesh };\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type NoiseParams = {\n   /** noise scale , default : `0.004` */\n   scale?: number;\n   /** time factor default : `0.3` */\n   timeStrength?: number;\n   /** noiseOctaves, affects performance default : `2` */\n   noiseOctaves?: number;\n   /** fbmOctaves, affects performance default : `2` */\n   fbmOctaves?: number;\n   /** domain warping octaves , affects performance default : `2`  */\n   warpOctaves?: number;\n   /** direction of domain warping , default : `(2.0,2,0)` */\n   warpDirection?: THREE.Vector2;\n   /** strength of domain warping , default : `8.0` */\n   warpStrength?: number;\n   /** you can get into the rhythm ♪ , default : `false` */\n   beat?: number | false;\n};\n\nexport type NoiseObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const NOISE_PARAMS: NoiseParams = Object.freeze({\n   scale: 0.004,\n   timeStrength: 0.3,\n   noiseOctaves: 2,\n   fbmOctaves: 2,\n   warpOctaves: 2,\n   warpDirection: new THREE.Vector2(2.0, 2.0),\n   warpStrength: 8.0,\n   beat: false,\n});\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n *\n * It is a basic value noise with `fbm` and `domain warping`\n */\nexport const useNoise = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<NoiseParams, NoiseObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] = useParams<NoiseParams>(NOISE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: NoiseParams) => {\n         const { gl, clock } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"scale\", params.scale!);\n         setUniform(material, \"timeStrength\", params.timeStrength!);\n         setUniform(material, \"noiseOctaves\", params.noiseOctaves!);\n         setUniform(material, \"fbmOctaves\", params.fbmOctaves!);\n         setUniform(material, \"warpOctaves\", params.warpOctaves!);\n         setUniform(material, \"warpDirection\", params.warpDirection!);\n         setUniform(material, \"warpStrength\", params.warpStrength!);\n\n         setUniform(material, \"uTime\", params.beat || clock.getElapsedTime());\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\nvarying vec2 vUv;\n\nuniform sampler2D uTexture;\nuniform bool isTexture;\nuniform sampler2D noise;\nuniform bool isNoise;\nuniform vec2 noiseStrength;\nuniform float laminateLayer;\nuniform vec2 laminateInterval;\nuniform vec2 laminateDetail;\nuniform vec2 distortion;\nuniform vec3 colorFactor;\nuniform float uTime;\nuniform vec2 timeStrength;\nuniform float scale;\n\nvoid main() {\n\tvec2 uv = vUv;\n\n\tvec2 pos = isTexture ? texture2D(uTexture, uv).rg : uv * scale;\n\tvec2 noise = isNoise ? texture2D(noise, uv).rg : vec2(0.0);\n\tfloat alpha = isTexture ? texture2D(uTexture, uv).a : 1.0;\n\t\n\t// Avoid floating point bugs caused by GPU drivers.\n\talpha = (alpha < 1e-10) ? 0.0 : alpha;\n\n\tvec3 col;\n\tfor(float j = 0.0; j < 3.0; j++){\n\t\tfor(float i = 1.0; i < laminateLayer; i++){\n\t\t\tfloat timeNoiseSin = sin(uTime / (i + j)) * timeStrength.x + noise.r * noiseStrength.x;\n\t\t\tfloat timeNoiseCos = cos(uTime / (i + j)) * timeStrength.y + noise.g * noiseStrength.y;\n\t\t\tpos.x += laminateInterval.x / (i + j) * cos(i * distortion.x * pos.y + timeNoiseSin + sin(i + j));\n\t\t\tpos.y += laminateInterval.y / (i + j) * cos(i * distortion.y * pos.x + timeNoiseCos + sin(i + j));\n\t\t}\n\t\tcol[int(j)] = sin(pow(pos.x, 2.) * pow(laminateDetail.x, 2.)) + sin(pow(pos.y, 2.) * pow(laminateDetail.y, 2.));\n\t}\n\n\tcol *= colorFactor * alpha;\n\tcol = clamp(col, 0.0, 1.0);\n\t\n\tgl_FragColor = vec4(col, alpha);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class ColorStrataMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      isTexture: { value: boolean };\n      scale: { value: number };\n      noise: { value: THREE.Texture };\n      noiseStrength: { value: THREE.Vector2 };\n      isNoise: { value: boolean };\n      laminateLayer: { value: number };\n      laminateInterval: { value: THREE.Vector2 };\n      laminateDetail: { value: THREE.Vector2 };\n      distortion: { value: THREE.Vector2 };\n      colorFactor: { value: THREE.Vector3 };\n      uTime: { value: number };\n      timeStrength: { value: THREE.Vector2 };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               isTexture: { value: false },\n               scale: { value: 1.0 },\n               noise: { value: new THREE.Texture() },\n               noiseStrength: { value: new THREE.Vector2(0, 0) },\n               isNoise: { value: false },\n               laminateLayer: { value: 1.0 },\n               laminateInterval: { value: new THREE.Vector2(0.1, 0.1) },\n               laminateDetail: { value: new THREE.Vector2(1, 1) },\n               distortion: { value: new THREE.Vector2(0, 0) },\n               colorFactor: { value: new THREE.Vector3(1, 1, 1) },\n               uTime: { value: 0 },\n               timeStrength: { value: new THREE.Vector2(0, 0) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as ColorStrataMaterial;\n\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n\n   return { material, mesh };\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type ColorStrataParams = {\n   /** default : `null` */\n   texture?: THREE.Texture | false;\n   /** Valid when texture is false. default : `1` */\n   scale?: number;\n   /** default : `1.0` */\n   laminateLayer?: number;\n   /** default : `(0.1, 0.1)` */\n   laminateInterval?: THREE.Vector2;\n   /** default : `(1.0, 1.0)` */\n   laminateDetail?: THREE.Vector2;\n   /** default : `(0.0, 0.0)` */\n   distortion?: THREE.Vector2;\n   /** default : `(1.0, 1.0, 1.0)` */\n   colorFactor?: THREE.Vector3;\n   /** default : `(0.0, 0.0)` */\n   timeStrength?: THREE.Vector2;\n   /** default : `false` */\n   noise?: THREE.Texture | false;\n   /** default : `(0.0,0.0)` */\n   noiseStrength?: THREE.Vector2;\n   /** you can get into the rhythm ♪ , default : `false` */\n   beat?: number | false;\n};\n\nexport type ColorStrataObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const COLORSTRATA_PARAMS: ColorStrataParams = Object.freeze({\n   texture: false,\n   scale: 1.0,\n   laminateLayer: 1.0,\n   laminateInterval: new THREE.Vector2(0.1, 0.1),\n   laminateDetail: new THREE.Vector2(1, 1),\n   distortion: new THREE.Vector2(0, 0),\n   colorFactor: new THREE.Vector3(1, 1, 1),\n   timeStrength: new THREE.Vector2(0, 0),\n   noise: false,\n   noiseStrength: new THREE.Vector2(0, 0),\n   beat: false,\n});\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useColorStrata = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<ColorStrataParams, ColorStrataObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] = useParams<ColorStrataParams>(COLORSTRATA_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: ColorStrataParams) => {\n         const { gl, clock } = props;\n         updateParams && setParams(updateParams);\n\n         if (params.texture) {\n            setUniform(material, \"uTexture\", params.texture);\n            setUniform(material, \"isTexture\", true);\n         } else {\n            setUniform(material, \"isTexture\", false);\n            setUniform(material, \"scale\", params.scale!);\n         }\n\n         if (params.noise) {\n            setUniform(material, \"noise\", params.noise);\n            setUniform(material, \"isNoise\", true);\n            setUniform(material, \"noiseStrength\", params.noiseStrength!);\n         } else {\n            setUniform(material, \"isNoise\", false);\n         }\n\n         setUniform(material, \"uTime\", params.beat || clock.getElapsedTime());\n\n         setUniform(material, \"laminateLayer\", params.laminateLayer!);\n         setUniform(material, \"laminateInterval\", params.laminateInterval!);\n         setUniform(material, \"laminateDetail\", params.laminateDetail!);\n         setUniform(material, \"distortion\", params.distortion!);\n         setUniform(material, \"colorFactor\", params.colorFactor!);\n         setUniform(material, \"timeStrength\", params.timeStrength!);\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform float u_time;\nuniform float u_pattern;\nuniform float u_complexity;\nuniform float u_complexityAttenuation;\nuniform float u_iterations;\nuniform float u_timeStrength;\nuniform float u_scale;\n\nvec3 marble(vec3 p){\n\tvec4 n;\n\tfor(float i;i<u_iterations;i++){\n\t\tp+=sin(p.yzx + u_pattern);\n\t\tn=u_complexity*n+vec4(cross(cos(p + u_pattern),sin(p.zxy + u_pattern)),1.)*(1.+i*u_complexityAttenuation);\n\t\tp*=u_complexity;\n\t}\n\treturn n.xyz/n.w;\n}\n\nvoid main() {\n\tfloat time = u_time * u_timeStrength;\n\tvec3 color = clamp(marble(vec3(gl_FragCoord.xy*u_scale,time)),0.,1.);\n\tgl_FragColor = vec4(color,1.);\n}\n\n","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class MarbleMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_time: { value: number };\n      u_pattern: { value: number };\n      u_complexity: { value: number };\n      u_complexityAttenuation: { value: number };\n      u_iterations: { value: number };\n      u_timeStrength: { value: number };\n      u_scale: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               u_time: { value: 0 },\n               u_pattern: { value: 0 },\n               u_complexity: { value: 0 },\n               u_complexityAttenuation: { value: 0 },\n               u_iterations: { value: 0 },\n               u_timeStrength: { value: 0 },\n               u_scale: { value: 0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as MarbleMaterial;\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n   return { material, mesh };\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type MarbleParams = {\n   /** You can add random patterns to noise by passing random numbers ,default : `0` */\n   pattern?: number;\n   /** default : `2` */\n   complexity?: number;\n   /** default : `0.2` */\n   complexityAttenuation?: number;\n   /** default : `8` */\n   iterations?: number;\n   /** default : `0.2` */\n   timeStrength?: number;\n   /** default : `0.002` */\n   scale?: number;\n   /** you can get into the rhythm ♪ , default : `false` */\n   beat?: number | false;\n};\n\nexport type MarbleObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const MARBLE_PARAMS: MarbleParams = Object.freeze({\n   pattern: 0,\n   complexity: 2,\n   complexityAttenuation: 0.2,\n   iterations: 8,\n   timeStrength: 0.2,\n   scale: 0.002,\n   beat: false,\n});\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useMarble = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<MarbleParams, MarbleObject> => {\n   const _dpr = getDpr(dpr);\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] = useParams<MarbleParams>(MARBLE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: MarbleParams) => {\n         const { gl, clock } = props;\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"u_pattern\", params.pattern!);\n         setUniform(material, \"u_complexity\", params.complexity!);\n         setUniform(\n            material,\n            \"u_complexityAttenuation\",\n            params.complexityAttenuation!\n         );\n         setUniform(material, \"u_iterations\", params.iterations!);\n         setUniform(material, \"u_timeStrength\", params.timeStrength!);\n         setUniform(material, \"u_scale\", params.scale!);\n\n         setUniform(material, \"u_time\", params.beat || clock.getElapsedTime());\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\nprecision highp int;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform vec3 uColor3;\nuniform vec3 uColor4;\nuniform vec3 uRgbWeight;\n\n\n// Based on glsl-cos-palette by Erkaman\n// https://github.com/Erkaman/glsl-cos-palette\nvec3 cosPalette(  float t,  vec3 color1,  vec3 color2,  vec3 color3, vec3 color4 ){\n    return color1 + color2 * cos( 6.28318 * ( color3 * t + color4) );\n}\n\nvoid main() {\n\n\tvec4 tex = texture2D(uTexture, vUv);\n\tfloat gray = dot(tex.rgb, uRgbWeight);\t\t\n\n\tvec3 outColor = cosPalette(\n\t\tgray,\n\t\tuColor1,\n\t\tuColor2,\n\t\tuColor3,\n\t\tuColor4\n\t);\n\n\tgl_FragColor = vec4(outColor, tex.a);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class CosPaletteMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      uRgbWeight: { value: THREE.Vector3 };\n      uColor1: { value: THREE.Color };\n      uColor2: { value: THREE.Color };\n      uColor3: { value: THREE.Color };\n      uColor4: { value: THREE.Color };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uRgbWeight: { value: new THREE.Vector3(0.299, 0.587, 0.114) },\n               uColor1: { value: new THREE.Color().set(0.5, 0.5, 0.5) },\n               uColor2: { value: new THREE.Color().set(0.5, 0.5, 0.5) },\n               uColor3: { value: new THREE.Color().set(1, 1, 1) },\n               uColor4: { value: new THREE.Color().set(0, 0.1, 0.2) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as CosPaletteMaterial;\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n   return { material, mesh };\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type CosPaletteParams = {\n   /** color1, default : `rgb(50%, 50%, 50%)` */\n   color1?: THREE.Color;\n   /** color2, default : `rgb(50%, 50%, 50%)` */\n   color2?: THREE.Color;\n   /** color3, default : `rgb(100%, 100%, 100%)` */\n   color3?: THREE.Color;\n   /** color4, default : `rgb(0%, 10%, 20%)` */\n   color4?: THREE.Color;\n   /** texture to be used as a palette */\n   texture?: THREE.Texture;\n   /** weight of the rgb, default : `THREE.Vector3(1.0,0.0,0.0)` */\n   rgbWeight?: THREE.Vector3;\n};\n\nexport type ColorPaletteObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const COSPALETTE_PARAMS: CosPaletteParams = Object.freeze({\n   texture: new THREE.Texture(),\n   color1: new THREE.Color().set(0.5, 0.5, 0.5),\n   color2: new THREE.Color().set(0.5, 0.5, 0.5),\n   color3: new THREE.Color().set(1, 1, 1),\n   color4: new THREE.Color().set(0, 0.1, 0.2),\n   rgbWeight: new THREE.Vector3(0.299, 0.587, 0.114),\n});\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useCosPalette = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<CosPaletteParams, ColorPaletteObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] = useParams<CosPaletteParams>(COSPALETTE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: CosPaletteParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uColor1\", params.color1!);\n         setUniform(material, \"uColor2\", params.color2!);\n         setUniform(material, \"uColor3\", params.color3!);\n         setUniform(material, \"uColor4\", params.color4!);\n         setUniform(material, \"uRgbWeight\", params.rgbWeight!);\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\n\nuniform vec3 uColor0;\nuniform vec3 uColor1;\n\nvoid main() {\n\tvec2 uv = vUv;\n\tvec4 texColor = texture2D(uTexture, uv);\n\tfloat grayscale = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n\tvec3 duotone = mix(uColor0, uColor1, grayscale);\n\tgl_FragColor = vec4(duotone, texColor.a);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class DuoToneMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      uColor0: { value: THREE.Color };\n      uColor1: { value: THREE.Color };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uColor0: { value: new THREE.Color(0xffffff) },\n               uColor1: { value: new THREE.Color(0x000000) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as DuoToneMaterial;\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n   return { material, mesh };\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { DuoToneMaterial, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type DuoToneParams = {\n   /** Make this texture duotone , Default : `THREE.Texture()` */\n   texture?: THREE.Texture;\n   /** 1st color ,　Default : `THREE.Color(0xffffff)` */\n   color0?: THREE.Color;\n   /** 2nd color , Default : `THREE.Color(0x000000)` */\n   color1?: THREE.Color;\n};\n\nexport type DuoToneObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: DuoToneMaterial;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const DUOTONE_PARAMS: DuoToneParams = {\n   texture: new THREE.Texture(),\n   color0: new THREE.Color(0xffffff),\n   color1: new THREE.Color(0x000000),\n};\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useDuoTone = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<DuoToneParams, DuoToneObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] = useParams<DuoToneParams>(DUOTONE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: DuoToneParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uColor0\", params.color0!);\n         setUniform(material, \"uColor1\", params.color1!);\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D u_texture;\nuniform sampler2D u_map;\nuniform bool u_isAlphaMap;\nuniform sampler2D u_alphaMap;\nuniform float u_mapIntensity;\nuniform vec3 u_brightness;\nuniform float u_min;\nuniform float u_max;\nuniform vec3 u_dodgeColor;\nuniform bool u_isDodgeColor;\n\nvoid main() {\n\tvec2 uv = vUv;\n\n\t// fx blending\n\tvec3 mapColor = texture2D(u_map, uv).rgb;\n\tvec3 normalizedMap = mapColor * 2.0 - 1.0;\n\n\tuv = uv * 2.0 - 1.0;\n\tuv *= mix(vec2(1.0), abs(normalizedMap.rg), u_mapIntensity);\n\tuv = (uv + 1.0) / 2.0;\n\n\t// colro blending\n\tfloat brightness = dot(mapColor,u_brightness);\n\tvec4 textureMap = texture2D(u_texture, uv);\n\tfloat blendValue = smoothstep(u_min, u_max, brightness);\n\n\t// set dodge color\n\tvec3 dodgeColor = u_isDodgeColor ? u_dodgeColor : mapColor;\n\tvec3 outputColor = blendValue * dodgeColor + (1.0 - blendValue) * textureMap.rgb;\n\t\n\t// alpha blending\n\tfloat alpha = u_isAlphaMap ? texture2D(u_alphaMap, uv).a : textureMap.a;\n\tfloat mixValue = u_isAlphaMap ? alpha : 0.0;\n\tvec3 alphColor = mix(outputColor,mapColor,mixValue);\n\n\tgl_FragColor = vec4(alphColor, alpha);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class BlendingMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_map: { value: THREE.Texture };\n      u_alphaMap: { value: THREE.Texture };\n      u_isAlphaMap: { value: boolean };\n      u_mapIntensity: { value: number };\n      u_brightness: { value: THREE.Vector3 };\n      u_min: { value: number };\n      u_max: { value: number };\n      u_dodgeColor: { value: THREE.Color };\n      u_isDodgeColor: { value: boolean };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               u_texture: { value: new THREE.Texture() },\n               u_map: { value: new THREE.Texture() },\n               u_alphaMap: { value: new THREE.Texture() },\n               u_isAlphaMap: { value: false },\n               u_mapIntensity: { value: 0.0 },\n               u_brightness: { value: new THREE.Vector3() },\n               u_min: { value: 0.0 },\n               u_max: { value: 0.9 },\n               u_dodgeColor: { value: new THREE.Color(0xffffff) },\n               u_isDodgeColor: { value: false },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as BlendingMaterial;\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n   return { material, mesh };\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type BlendingParams = {\n   /** Make this texture Blending , default : `THREE.Texture` */\n   texture?: THREE.Texture;\n   /** map texture, default : `THREE.Texture` */\n   map?: THREE.Texture;\n   /** map strength , r,g value are affecting , default : `0.3` */\n   mapIntensity?: number;\n   /** Alpha blending is performed using the alpha of the set texture. , default : `false` */\n   alphaMap?: THREE.Texture | false;\n   /** default : `(0.5,0.5,0.5)` */\n   brightness?: THREE.Vector3;\n   /** default : `0.0` */\n   min?: number;\n   /** default : `1.0` */\n   max?: number;\n   /** If set, this value will apply color dodge , default : `false` */\n   dodgeColor?: THREE.Color | false;\n};\n\nexport type BlendingObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const BLENDING_PARAMS: BlendingParams = {\n   texture: new THREE.Texture(),\n   map: new THREE.Texture(),\n   alphaMap: false,\n   mapIntensity: 0.3,\n   brightness: new THREE.Vector3(0.5, 0.5, 0.5),\n   min: 0.0,\n   max: 1.0,\n   dodgeColor: false,\n};\n\n/**\n * Blend map to texture. You can set the threshold for blending with brightness. You can set the dodge color by setting color. \nIf you don't want to reflect the map's color, you can use useFxBlending instead.\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useBlending = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<BlendingParams, BlendingObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] = useParams<BlendingParams>(BLENDING_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: BlendingParams) => {\n         const { gl } = props;\n         updateParams && setParams(updateParams);\n         setUniform(material, \"u_texture\", params.texture!);\n         setUniform(material, \"u_map\", params.map!);\n         setUniform(material, \"u_mapIntensity\", params.mapIntensity!);\n\n         if (params.alphaMap) {\n            setUniform(material, \"u_alphaMap\", params.alphaMap!);\n            setUniform(material, \"u_isAlphaMap\", true);\n         } else {\n            setUniform(material, \"u_isAlphaMap\", false);\n         }\n\n         setUniform(material, \"u_brightness\", params.brightness!);\n         setUniform(material, \"u_min\", params.min!);\n         setUniform(material, \"u_max\", params.max!);\n         if (params.dodgeColor) {\n            setUniform(material, \"u_dodgeColor\", params.dodgeColor);\n            setUniform(material, \"u_isDodgeColor\", true);\n         } else {\n            setUniform(material, \"u_isDodgeColor\", false);\n         }\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform vec2 uResolution;\nuniform vec2 uTextureResolution;\nuniform sampler2D uTexture0;\nuniform sampler2D uTexture1;\nuniform sampler2D uMap;\nuniform float mapIntensity;\nuniform float edgeIntensity;\nuniform float progress;\nuniform float dirX;\nuniform float dirY;\nuniform vec2 epicenter;\nuniform float padding;\n\nbool isInPaddingArea(vec2 uv) {\n   return uv.x < padding || uv.x > 1.0 - padding || uv.y < padding || uv.y > 1.0 - padding;\n}\n\nvoid main() {\n\tfloat screenAspect = uResolution.x / uResolution.y;\n\tfloat textureAspect = uTextureResolution.x / uTextureResolution.y;\n\tvec2 aspectRatio = vec2(\n\t\tmin(screenAspect / textureAspect, 1.0),\n\t\tmin(textureAspect / screenAspect, 1.0)\n\t);\n\tvec2 uv = vUv * aspectRatio + (1.0 - aspectRatio) * .5;\n\n\t// fx map\n\tvec2 map = texture2D(uMap, uv).rg;\n\tvec2 normalizedMap = map * 2.0 - 1.0;\n\n\t// multiply edge fx\n\tuv = uv * 2.0 - 1.0;\n\tuv *= map * distance(epicenter, uv) * edgeIntensity + 1.0;\n\tuv = (uv + 1.0) / 2.0;\n\n\t// padding\n\tif (isInPaddingArea(uv)) {\n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n\t}\n\tvec2 paddedUV = uv * (1.0 - 2.0 * padding * -1.) + padding * -1.;\n\n\t// centered uv\n\tvec2 centeredUV = paddedUV - vec2(0.5);\n\n\t// multiply map fx\n\tcenteredUV *= normalizedMap * map * mapIntensity + 1.0;\n\n\t// texture 0\n\tfloat xOffsetTexture0 = 0.5 - dirX * progress;\n\tfloat yOffsetTexture0 = 0.5 - dirY * progress;\n\tvec2 samplePosTexture0 = vec2(xOffsetTexture0, yOffsetTexture0) + centeredUV;\n\n\t//texture 1\n\tfloat xOffsetTexture1 = 0.5 + dirX * (1.0 - progress);\n\tfloat yOffsetTexture1 = 0.5 + dirY * (1.0 - progress);\n\tvec2 samplePosTexture1 = vec2(xOffsetTexture1, yOffsetTexture1) + centeredUV;\n\n\tvec4 color0 = texture2D(uTexture0, samplePosTexture0);\n\tvec4 color1 = texture2D(uTexture1, samplePosTexture1);\n\n\tgl_FragColor = mix(color0, color1, progress);\n\n}","import { useEffect, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useResolution } from \"../../../utils/useResolution\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class FxTextureMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uResolution: { value: THREE.Vector2 };\n      uTextureResolution: { value: THREE.Vector2 };\n      uTexture0: { value: THREE.Texture };\n      uTexture1: { value: THREE.Texture };\n      padding: { value: number };\n      uMap: { value: THREE.Texture };\n      edgeIntensity: { value: number };\n      mapIntensity: { value: number };\n      epicenter: { value: THREE.Vector2 };\n      progress: { value: number };\n      dirX: { value: number };\n      dirY: { value: number };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number | false;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uResolution: { value: new THREE.Vector2() },\n               uTextureResolution: { value: new THREE.Vector2() },\n               uTexture0: { value: new THREE.Texture() },\n               uTexture1: { value: new THREE.Texture() },\n               padding: { value: 0.0 },\n               uMap: { value: new THREE.Texture() },\n               edgeIntensity: { value: 0.0 },\n               mapIntensity: { value: 0.0 },\n               epicenter: { value: new THREE.Vector2(0.0, 0.0) },\n               progress: { value: 0.0 },\n               dirX: { value: 0.0 },\n               dirY: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as FxTextureMaterial;\n\n   const resolution = useResolution(size, dpr);\n   setUniform(material, \"uResolution\", resolution.clone());\n\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n\n   return { material, mesh };\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type FxTextureParams = {\n   /** 1st texture , default : `THREE.Texture()` */\n   texture0?: THREE.Texture;\n   /** 2nd texture , default : `THREE.Texture()` */\n   texture1?: THREE.Texture;\n   /** add transparent padding, 0.0 ~ 1.0 , default : `0.0` */\n   padding?: number;\n   /** The color map. The uv value is affected according to this rbg , default : `THREE.Texture()` */\n   map?: THREE.Texture;\n   /** intensity of map , r,g value are affecting , default : `0.0` */\n   mapIntensity?: number;\n   /** Intensity of effect on edges , default : `0.0` */\n   edgeIntensity?: number;\n   /** epicenter of fx, -1 ~ 1 , default : `vec2(0.0,0.0)` */\n   epicenter?: THREE.Vector2;\n   /** Switch value to switch between texture0 and texture1 , 0 ~ 1 , default : `0` */\n   progress?: number;\n   /** direction of transition , default: `THREE.Vector2(0, 0)` */\n   dir?: THREE.Vector2;\n};\n\nexport type FxTextureObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const FXTEXTURE_PARAMS: FxTextureParams = {\n   texture0: new THREE.Texture(),\n   texture1: new THREE.Texture(),\n   padding: 0.0,\n   map: new THREE.Texture(),\n   mapIntensity: 0.0,\n   edgeIntensity: 0.0,\n   epicenter: new THREE.Vector2(0, 0),\n   progress: 0.0,\n   dir: new THREE.Vector2(0, 0),\n};\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useFxTexture = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<FxTextureParams, FxTextureObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh({ scene, size, dpr: _dpr.shader });\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      dpr: _dpr.fbo,\n      size,\n      samples,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] = useParams<FxTextureParams>(FXTEXTURE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FxTextureParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture0\", params.texture0!);\n         setUniform(material, \"uTexture1\", params.texture1!);\n\n         setUniform(material, \"progress\", params.progress!);\n\n         // calculate resolution by linear interpolation.\n         const tex0Res = [\n            params.texture0!?.image?.width || 0,\n            params.texture0!?.image?.height || 0,\n         ];\n         const tex1Res = [\n            params.texture1!?.image?.width || 0,\n            params.texture1!?.image?.height || 0,\n         ];\n         const interpolatedResolution = tex0Res.map((value, index) => {\n            return value + (tex1Res[index] - value) * params.progress!;\n         });\n         setUniform(material, \"uTextureResolution\", interpolatedResolution);\n\n         setUniform(material, \"padding\", params.padding!);\n         setUniform(material, \"uMap\", params.map!);\n         setUniform(material, \"mapIntensity\", params.mapIntensity!);\n         setUniform(material, \"edgeIntensity\", params.edgeIntensity!);\n         setUniform(material, \"epicenter\", params.epicenter!);\n         setUniform(material, \"dirX\", params.dir!.x);\n         setUniform(material, \"dirY\", params.dir!.y);\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D u_texture;\nuniform vec3 u_brightness;\nuniform float u_min;\nuniform float u_max;\n\nvoid main() {\n\tvec2 uv = vUv;\n\tvec3 color = texture2D(u_texture, uv).rgb;\n\tfloat brightness = dot(color,u_brightness);\n\tfloat alpha = clamp(smoothstep(u_min, u_max, brightness),0.0,1.0);\n\tgl_FragColor = vec4(color, alpha);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class BrightnessPickerMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_brightness: { value: THREE.Vector3 };\n      u_min: { value: number };\n      u_max: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               u_texture: { value: new THREE.Texture() },\n               u_brightness: { value: new THREE.Vector3() },\n               u_min: { value: 0.0 },\n               u_max: { value: 1.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as BrightnessPickerMaterial;\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n   return { material, mesh };\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type BrightnessPickerParams = {\n   /** pick brightness from this texture , default : `THREE.Texture` */\n   texture?: THREE.Texture;\n   /** default : `(0.5,0.5,0.5)` */\n   brightness?: THREE.Vector3;\n   /** default : `0.0` */\n   min?: number;\n   /** default : `1.0` */\n   max?: number;\n};\n\nexport type BrightnessPickerObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const BRIGHTNESSPICKER_PARAMS: BrightnessPickerParams = {\n   texture: new THREE.Texture(),\n   brightness: new THREE.Vector3(0.5, 0.5, 0.5),\n   min: 0.0,\n   max: 1.0,\n};\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useBrightnessPicker = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<BrightnessPickerParams, BrightnessPickerObject> => {\n   const _dpr = getDpr(dpr);\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] = useParams<BrightnessPickerParams>(\n      BRIGHTNESSPICKER_PARAMS\n   );\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: BrightnessPickerParams) => {\n         const { gl } = props;\n         updateParams && setParams(updateParams);\n         setUniform(material, \"u_texture\", params.texture!);\n         setUniform(material, \"u_brightness\", params.brightness!);\n         setUniform(material, \"u_min\", params.min!);\n         setUniform(material, \"u_max\", params.max!);\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D u_texture;\nuniform sampler2D u_map;\nuniform float u_mapIntensity;\n\nvoid main() {\n\tvec2 uv = vUv;\n\n\tvec2 mapColor = texture2D(u_map, uv).rg;\n\tvec2 normalizedMap = mapColor * 2.0 - 1.0;\n\t\n\tuv = uv * 2.0 - 1.0;\n\tuv *= mix(vec2(1.0), abs(normalizedMap.rg), u_mapIntensity);\n\tuv = (uv + 1.0) / 2.0;\n\n\tgl_FragColor = texture2D(u_texture, uv);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class FxBlendingMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_map: { value: THREE.Texture };\n      u_mapIntensity: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               u_texture: { value: new THREE.Texture() },\n               u_map: { value: new THREE.Texture() },\n               u_mapIntensity: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as FxBlendingMaterial;\n\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n   return { material, mesh };\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type FxBlendingParams = {\n   /** Make this texture Blending , default : `THREE.Texture` */\n   texture?: THREE.Texture;\n   /** map texture, default : `THREE.Texture` */\n   map?: THREE.Texture;\n   /** map strength , r,g value are affecting , default : `0.3` */\n   mapIntensity?: number;\n};\n\nexport type FxBlendingObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const FXBLENDING_PARAMS: FxBlendingParams = {\n   texture: new THREE.Texture(),\n   map: new THREE.Texture(),\n   mapIntensity: 0.3,\n};\n\n/**\n * Blend map to texture. You can change the intensity of fx applied by the rg value of map. Unlike \"useBlending\", the map color is not reflected.\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useFxBlending = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<FxBlendingParams, FxBlendingObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] = useParams<FxBlendingParams>(FXBLENDING_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FxBlendingParams) => {\n         const { gl } = props;\n         updateParams && setParams(updateParams);\n         setUniform(material, \"u_texture\", params.texture!);\n         setUniform(material, \"u_map\", params.map!);\n         setUniform(material, \"u_mapIntensity\", params.mapIntensity!);\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMap;\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvec2 uv = vUv;\n\tvec4 tex = texture2D(uTexture, uv);\n\tvec4 map = texture2D(uMap, uv);\n\tgl_FragColor = mix(tex,map,map.a);\n}\n\n","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class AlphaBlendingMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      uMap: { value: THREE.Texture };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number | false;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uMap: { value: new THREE.Texture() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as AlphaBlendingMaterial;\n\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n\n   return { material, mesh };\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState } from \"@react-three/fiber\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type AlphaBlendingParams = {\n   /** default : `THREE.Texture()` */\n   texture?: THREE.Texture;\n   /** alpha map , default : `THREE.Texture()` */\n   map?: THREE.Texture;\n};\n\nexport type AlphaBlendingObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const ALPHABLENDING_PARAMS: AlphaBlendingParams = {\n   texture: new THREE.Texture(),\n   map: new THREE.Texture(),\n};\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useAlphaBlending = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<AlphaBlendingParams, AlphaBlendingObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh({ scene, size, dpr: _dpr.shader });\n   const camera = useCamera(size);\n\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] =\n      useParams<AlphaBlendingParams>(ALPHABLENDING_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: AlphaBlendingParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uMap\", params.map!);\n\n         return updateRenderTarget(gl);\n      },\n      [material, updateRenderTarget, params, setParams]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D u_texture;\nuniform float u_brightness;\nuniform float u_saturation;\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n\tvec4 tex = texture2D(u_texture, vUv);\n\tvec3 hsv = rgb2hsv(tex.rgb);\n\thsv.y *= u_saturation;\n\thsv.z *= u_brightness;\n\tvec3 final = hsv2rgb(hsv);\n\tgl_FragColor = vec4(final, tex.a);\n}\n\n","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class HSVMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_brightness: { value: number };\n      u_saturation: { value: number };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number | false;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               u_texture: { value: new THREE.Texture() },\n               u_brightness: { value: 1 },\n               u_saturation: { value: 1 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as HSVMaterial;\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n   return { material, mesh };\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState } from \"@react-three/fiber\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type HSVParams = {\n   /** default : `THREE.Texture()` */\n   texture?: THREE.Texture;\n   /** default : `1` */\n   brightness?: number;\n   /** default : `1` */\n   saturation?: number;\n};\n\nexport type HSVObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const HSV_PARAMS: HSVParams = {\n   texture: new THREE.Texture(),\n   brightness: 1,\n   saturation: 1,\n};\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useHSV = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<HSVParams, HSVObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh({ scene, size, dpr: _dpr.shader });\n   const camera = useCamera(size);\n\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] = useParams<HSVParams>(HSV_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: HSVParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"u_texture\", params.texture!);\n         setUniform(material, \"u_brightness\", params.brightness!);\n         setUniform(material, \"u_saturation\", params.saturation!);\n\n         return updateRenderTarget(gl);\n      },\n      [material, updateRenderTarget, params, setParams]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform vec2 uResolution;\nuniform vec2 uTextureResolution;\nuniform sampler2D uTexture;\n\nvoid main() {\n\tfloat screenAspect = uResolution.x / uResolution.y;\n\tfloat textureAspect = uTextureResolution.x / uTextureResolution.y;\n\tvec2 aspectRatio = vec2(\n\t\tmin(screenAspect / textureAspect, 1.0),\n\t\tmin(textureAspect / screenAspect, 1.0)\n\t);\n\tvec2 uv = vUv * aspectRatio + (1.0 - aspectRatio) * .5;\n\t\n\tgl_FragColor = texture2D(uTexture, uv);\n\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useResolution } from \"../../../utils/useResolution\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class FxTextureMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uResolution: { value: THREE.Vector2 };\n      uTextureResolution: { value: THREE.Vector2 };\n      uTexture: { value: THREE.Texture };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number | false;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uResolution: { value: new THREE.Vector2() },\n               uTextureResolution: { value: new THREE.Vector2() },\n               uTexture: { value: new THREE.Texture() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as FxTextureMaterial;\n\n   const resolution = useResolution(size, dpr);\n   setUniform(material, \"uResolution\", resolution.clone());\n\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n\n   return { material, mesh };\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type CoverTextureParams = {\n   /** Textures that you want to display exactly on the screen , default : `THREE.Texture()` */\n   texture?: THREE.Texture;\n};\n\nexport type CoverTextureObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const COVERTEXTURE_PARAMS: CoverTextureParams = {\n   texture: new THREE.Texture(),\n};\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useCoverTexture = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<CoverTextureParams, CoverTextureObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh({ scene, size, dpr: _dpr.shader });\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      dpr: _dpr.fbo,\n      size,\n      samples,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] =\n      useParams<CoverTextureParams>(COVERTEXTURE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: CoverTextureParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uTextureResolution\", [\n            params.texture!?.source?.data?.width || 0,\n            params.texture!?.source?.data?.height || 0,\n         ]);\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","precision mediump float;\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uBlurSize;\n\nvoid main() {\n\tvec2 uv = vUv;\t\n\tvec2 perDivSize = uBlurSize / uResolution;\n\n\t// calc average color value from adjacent point\n\tvec4 outColor = vec4(\n\t\ttexture2D(uTexture, uv + perDivSize * vec2(-1.0, -1.0)) +\n\t\ttexture2D(uTexture, uv + perDivSize * vec2(0.0, -1.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(1.0, -1.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(-1.0, 0.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(0.0,  0.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(1.0,  0.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(-1.0, 1.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(0.0,  1.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(1.0,  1.0))\n\t\t) / 9.0;\n\t\n\tgl_FragColor = outColor;\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\nimport { SIMPLEBLUR_PARAMS } from \".\";\n\nexport class SampleMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      uResolution: { value: THREE.Vector2 };\n      uBlurSize: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uResolution: { value: new THREE.Vector2(0, 0) },\n               uBlurSize: { value: SIMPLEBLUR_PARAMS.blurSize },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as SampleMaterial;\n\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n\n   return { material, mesh };\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { useDoubleFBO } from \"../../../utils/useDoubleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { useParams } from \"../../../utils/useParams\";\n\nimport type { HooksProps, HooksReturn } from \"../../types\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type SimpleBlurParams = {\n   /** Make this texture blur , default : `THREE.Texture()` */\n   texture?: THREE.Texture;\n   /** blurSize, default : `3` */\n   blurSize?: number;\n   /** blurPower, affects performance default : `5` */\n   blurPower?: number;\n};\n\nexport type SimpleBlurObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const SIMPLEBLUR_PARAMS: SimpleBlurParams = Object.freeze({\n   texture: new THREE.Texture(),\n   blurSize: 3,\n   blurPower: 5,\n});\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useSimpleBlur = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<SimpleBlurParams, SimpleBlurObject> => {\n   const _dpr = getDpr(dpr);\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh(scene);\n   const camera = useCamera(size);\n\n   const fboProps = useMemo(\n      () => ({\n         scene,\n         camera,\n         size,\n         dpr: _dpr.fbo,\n         samples,\n      }),\n      [scene, camera, size, _dpr.fbo, samples]\n   );\n   const [renderTarget, updateRenderTarget] = useSingleFBO(fboProps);\n   const [_, updateTempTexture] = useDoubleFBO(fboProps);\n   const [params, setParams] = useParams<SimpleBlurParams>(SIMPLEBLUR_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: SimpleBlurParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uResolution\", [\n            params.texture!?.source?.data?.width || 0,\n            params.texture!?.source?.data?.height || 0,\n         ]);\n         setUniform(material, \"uBlurSize\", params.blurSize!);\n\n         let _tempTexture: THREE.Texture = updateTempTexture(gl);\n\n         const iterations = params.blurPower!;\n         for (let i = 0; i < iterations; i++) {\n            setUniform(material, \"uTexture\", _tempTexture);\n            _tempTexture = updateTempTexture(gl);\n         }\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, updateTempTexture, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform float uProgress;\nuniform float uStrength;\nuniform float uWidth;\nuniform vec2 uEpicenter;\nuniform int uMode;\n\nfloat PI = 3.141592653589;\n\nvoid main() {\n\n\tvec2 uv = vUv;\n\n\tfloat progress = min(uProgress, 1.0);\n\tfloat progressFactor = sin(progress * PI);\n\n\tfloat border = progress - progress * progressFactor * uWidth;\n\tfloat blur = uStrength * progressFactor;\n\t\n\t// 0 ~ 1\n\tvec2 normalizeCenter = (uEpicenter + 1.0) / 2.0;\n\n\t// 0:center 1:horizontal 2:vertical\n\tfloat dist = uMode == 0 ? length(uv - normalizeCenter) : uMode == 1 ? length(uv.x - normalizeCenter.x) : length(uv.y - normalizeCenter.y);\n\n\t// Calculate the maximum distance to the four corners of the screen\n\tfloat maxDistance = max(\n\t\tlength(vec2(0.0, 0.0) - normalizeCenter),\n\t\tmax(\n\t\t\t\tlength(vec2(1.0, 0.0) - normalizeCenter),\n\t\t\t\tmax(\n\t\t\t\t\tlength(vec2(0.0, 1.0) - normalizeCenter),\n\t\t\t\t\tlength(vec2(1.0, 1.0) - normalizeCenter)\n\t\t\t\t)\n\t\t)\n\t);\n\n\t// Scale distance so that waves extend to the edge of the screen\n\tdist = maxDistance > 0.0 ? dist / maxDistance : dist;\n\n\tvec3 color = vec3(smoothstep(border - blur, border, dist) -\n                  smoothstep(progress, progress + blur, dist));\n\t\n\t// Ensure color is 0 when progress is 0,1\n\tcolor *= progressFactor;\n\n\tgl_FragColor = vec4(color, 1.0);\n}\n\n","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { WAVE_PARAMS } from \".\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class WaveMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uEpicenter: { value: THREE.Vector2 };\n      uProgress: { value: number };\n      uStrength: { value: number };\n      uWidth: { value: number };\n      uMode: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uEpicenter: { value: WAVE_PARAMS.epicenter },\n               uProgress: { value: WAVE_PARAMS.progress },\n               uStrength: { value: WAVE_PARAMS.strength },\n               uWidth: { value: WAVE_PARAMS.width },\n               uMode: { value: 0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as WaveMaterial;\n\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n\n   return { material, mesh };\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { useMesh } from \"./useMesh\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type WaveParams = {\n   /** -1.0 ~ 1.0 , default : `vec2(0.0,0.0)` */\n   epicenter?: THREE.Vector2;\n   /** 0.0 ~ 1.0 , default : `0.0` */\n   progress?: number;\n   /** default : `0.0` */\n   width?: number;\n   /** default : `0.0` */\n   strength?: number;\n   /** default : `center` */\n   mode?: \"center\" | \"horizontal\" | \"vertical\";\n};\n\nexport type WaveObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const WAVE_PARAMS: WaveParams = Object.freeze({\n   epicenter: new THREE.Vector2(0.0, 0.0),\n   progress: 0.0,\n   width: 0.0,\n   strength: 0.0,\n   mode: \"center\",\n});\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx\n */\nexport const useWave = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<WaveParams, WaveObject> => {\n   const _dpr = getDpr(dpr);\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] = useParams<WaveParams>(WAVE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: WaveParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uEpicenter\", params.epicenter!);\n         setUniform(material, \"uProgress\", params.progress!);\n         setUniform(material, \"uWidth\", params.width!);\n         setUniform(material, \"uStrength\", params.strength!);\n         setUniform(\n            material,\n            \"uMode\",\n            params.mode! === \"center\"\n               ? 0\n               : params.mode! === \"horizontal\"\n               ? 1\n               : 2\n         );\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\nvarying vec2 vUv;\n\nuniform sampler2D u_texture;\nuniform vec2 u_resolution;\nuniform vec3 u_keyColor;\nuniform float u_similarity;\nuniform float u_smoothness;\nuniform float u_spill;\n\nuniform vec4 u_color;\nuniform float u_contrast;\nuniform float u_brightness;\nuniform float u_gamma;\n\n// From https://github.com/libretro/glsl-shaders/blob/master/nnedi3/shaders/rgb-to-yuv.glsl\nvec2 RGBtoUV(vec3 rgb) {\n  return vec2(\n    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,\n    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5\n  );\n}\nfloat getChromeDist(vec3 texColor){\n\tfloat chromaDist = distance(RGBtoUV(texColor), RGBtoUV(u_keyColor));\n\treturn chromaDist;\n}\n\nfloat getBoxFilteredChromaDist(vec3 rgb, vec2 uv)\n{\n\tvec2 pixel_size = vec2(1.) / u_resolution;\n\tvec2 h_pixel_size = pixel_size / 2.0;\n\tvec2 point_0 = vec2(pixel_size.x, h_pixel_size.y);\n\tvec2 point_1 = vec2(h_pixel_size.x, -pixel_size.y);\n\tfloat distVal = getChromeDist(texture2D(u_texture,uv-point_0).rgb);\n\tdistVal += getChromeDist(texture2D(u_texture,uv+point_0).rgb);\n\tdistVal += getChromeDist(texture2D(u_texture,uv-point_1).rgb);\n\tdistVal += getChromeDist(texture2D(u_texture,uv+point_1).rgb);\n\tdistVal *= 2.0;\n\tdistVal += getChromeDist(rgb);\n\treturn distVal / 9.0;\n}\n\nvec4 CalcColor(vec4 rgba)\n{\n\treturn vec4(pow(rgba.rgb, vec3(u_gamma, u_gamma, u_gamma)) * u_contrast + u_brightness, rgba.a);\n}\n\nvoid main() {\n\n\tvec2 uv = vUv;\n\n\tvec4 texColor = texture2D(u_texture, uv);\n\ttexColor.rgb *= (texColor.a > 0.) ? (1. / texColor.a) : 0.;\n\n\tfloat chromaDist = getBoxFilteredChromaDist(texColor.rgb,uv);\n\t\n\tfloat baseMask = chromaDist - u_similarity;\n\tfloat fullMask = pow(clamp(baseMask / u_smoothness, 0., 1.), 1.5);\n\t\n\ttexColor.rgba *= u_color;\n\ttexColor.a = fullMask;\n\n\tfloat spillVal = pow(clamp(baseMask / u_spill, 0., 1.), 1.5);\n\tfloat desat = clamp(texColor.r * 0.2126 + texColor.g * 0.7152 + texColor.b * 0.0722, 0., 1.);\n\ttexColor.rgb = mix(vec3(desat, desat, desat), texColor.rgb, spillVal);\n\n\tvec4 finColor = CalcColor(texColor);\n\n\tgl_FragColor = finColor;\n}","import { useEffect, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { Size } from \"@react-three/fiber\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { useResolution } from \"../../../utils/useResolution\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\n\nexport class ChromaKeyMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_resolution: { value: THREE.Vector2 };\n      u_keyColor: { value: THREE.Color };\n      u_similarity: { value: number };\n      u_smoothness: { value: number };\n      u_spill: { value: number };\n      u_color: { value: THREE.Vector4 };\n      u_contrast: { value: number };\n      u_brightness: { value: number };\n      u_gamma: { value: number };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number | false;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               u_texture: { value: new THREE.Texture() },\n               u_resolution: { value: new THREE.Vector2() },\n               u_keyColor: { value: new THREE.Color() },\n               u_similarity: { value: 0 },\n               u_smoothness: { value: 0 },\n               u_spill: { value: 0 },\n               u_color: { value: new THREE.Vector4() },\n               u_contrast: { value: 0 },\n               u_brightness: { value: 0 },\n               u_gamma: { value: 0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as ChromaKeyMaterial;\n\n   const resolution = useResolution(size, dpr);\n   setUniform(material, \"u_resolution\", resolution.clone());\n\n   const mesh = useAddObject(scene, geometry, material, THREE.Mesh);\n\n   return { material, mesh };\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type ChromaKeyParams = {\n   /** Process this texture with chroma key , default : `THREE.Texture` */\n   texture?: THREE.Texture;\n   /** key color for chromakey processing , default: `THREE.Color(0x00ff00)` */\n   keyColor?: THREE.Color;\n   /** If the similarity with the key color exceeds this value, it becomes transparent. , default : `0.2` */\n   similarity?: number;\n   /** smoothness , default : `0.1` */\n   smoothness?: number;\n   /** spill , default : `0.2` */\n   spill?: number;\n   /** tone correction , default : `THREE.Vector4(1.0, 1.0, 1.0, 1.0)` */\n   color?: THREE.Vector4;\n   /** contrast , default : `1.0` */\n   contrast?: number;\n   /** brightness , default : `0.0` */\n   brightness?: number;\n   /** gamma correction , default : `1.0` */\n   gamma?: number;\n};\n\nexport type ChromaKeyObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const CHROMAKEY_PARAMS: ChromaKeyParams = Object.freeze({\n   texture: new THREE.Texture(),\n   keyColor: new THREE.Color(0x00ff00),\n   similarity: 0.2,\n   smoothness: 0.1,\n   spill: 0.2,\n   color: new THREE.Vector4(1.0, 1.0, 1.0, 1.0),\n   contrast: 1.0,\n   brightness: 0.0,\n   gamma: 1.0,\n});\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usage\n */\nexport const useChromaKey = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<ChromaKeyParams, ChromaKeyObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const { material, mesh } = useMesh({ scene, size, dpr: _dpr.shader });\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n   });\n\n   const [params, setParams] = useParams<ChromaKeyParams>(CHROMAKEY_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: ChromaKeyParams) => {\n         const { gl } = props;\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"u_texture\", params.texture!);\n         setUniform(material, \"u_keyColor\", params.keyColor!);\n         setUniform(material, \"u_similarity\", params.similarity!);\n         setUniform(material, \"u_smoothness\", params.smoothness!);\n         setUniform(material, \"u_spill\", params.spill!);\n         setUniform(material, \"u_color\", params.color!);\n         setUniform(material, \"u_contrast\", params.contrast!);\n         setUniform(material, \"u_brightness\", params.brightness!);\n         setUniform(material, \"u_gamma\", params.gamma!);\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         mesh: mesh,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport { useAddObject } from \"../../../../utils/useAddObject\";\n\ntype UseCreateObjectProps = {\n   scene: THREE.Scene | false;\n   geometry: THREE.BufferGeometry;\n   material: THREE.ShaderMaterial;\n};\n\nexport type MorphParticlePoints = THREE.Points<\n   THREE.BufferGeometry<THREE.NormalBufferAttributes>,\n   THREE.ShaderMaterial\n>;\nexport type InteractiveMesh = THREE.Mesh<\n   THREE.BufferGeometry<THREE.NormalBufferAttributes>,\n   THREE.ShaderMaterial\n>;\n\nexport const useCreateObject = ({\n   scene,\n   geometry,\n   material,\n}: UseCreateObjectProps) => {\n   const points = useAddObject(\n      scene,\n      geometry,\n      material,\n      THREE.Points\n   ) as MorphParticlePoints;\n\n   // Generate a mesh for pointer\n   const interactiveMesh = useAddObject(\n      scene,\n      useMemo(() => geometry.clone(), [geometry]),\n      useMemo(() => material.clone(), [material]),\n      THREE.Mesh\n   ) as InteractiveMesh;\n   interactiveMesh.visible = false;\n\n   return {\n      points,\n      interactiveMesh,\n   };\n};\n","uniform vec2 uResolution;\nuniform float uMorphProgress;\nuniform float uPointSize;\n\nuniform sampler2D uPicture;\nuniform bool uIsPicture;\nuniform sampler2D uAlphaPicture;\nuniform bool uIsAlphaPicture;\n\nuniform vec3 uColor0;\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform vec3 uColor3;\n\nuniform float uTime;\n\nuniform float uWobblePositionFrequency;\nuniform float uWobbleTimeFrequency;\nuniform float uWobbleStrength;\nuniform float uWarpPositionFrequency;\nuniform float uWarpTimeFrequency;\nuniform float uWarpStrength;\n\nuniform sampler2D uDisplacement;\nuniform bool uIsDisplacement;\nuniform float uDisplacementIntensity;\n\nuniform float uSizeRandomIntensity;\nuniform float uSizeRandomTimeFrequency;\nuniform float uSizeRandomMin;\nuniform float uSizeRandomMax;\n\nuniform float uMapArrayLength;\n\nuniform float uDivergence;\nuniform vec3 uDivergencePoint;\n\nvarying vec3 vColor;\nvarying float vPictureAlpha;\nvarying vec3 vDisplacementColor;\nvarying float vDisplacementIntensity;\nvarying float vMapArrayIndex;\n\n#usf <morphPositions>\n\n#usf <morphUvs>\n\n#usf <getWobble>\n\n\nfloat random3D(vec3 co) {\n    return fract(sin(dot(co.xyz ,vec3(12.9898, 78.233, 45.764))) * 43758.5453);\n}\n\nvoid main() {\n\tvec3 newPosition = position;\n\tvec2 newUv = uv;\n\t#usf <morphPositionTransition>\n\t#usf <morphUvTransition>\n\n\t// displacement for `newPosition`\n\tvec3 displacement = uIsDisplacement ? texture2D(uDisplacement, newUv).rgb : vec3(0.0);\n\tfloat displacementIntensity = smoothstep(0., 1., displacement.g);\n\tvDisplacementColor = displacement;\n\tvDisplacementIntensity = displacementIntensity;\n\n\t// At this point displacement is 0 ~ 1, so normalize it to -1 ~ 1\n\tdisplacement = displacement * 2.-1.;\n\tdisplacement *= displacementIntensity * uDisplacementIntensity;\n\tnewPosition += displacement;\n\n\t// divergence\n\tvec3 divergenceDir = newPosition - uDivergencePoint;\n\tif (uDivergence > 0.0) {\n\t\tnewPosition += normalize(divergenceDir) * uDivergence;\n\t} else if (uDivergence < 0.0) {\n\t\tnewPosition -= normalize(divergenceDir) * abs(uDivergence);\n\t}\n\n\t// Final position\n\tvec4 modelPosition = modelMatrix * vec4(newPosition, 1.0);\n\tvec4 viewPosition = viewMatrix * modelPosition;\n\tvec4 projectedPosition = projectionMatrix * viewPosition;\n\n\t// wobble ※Do not calculate noise if uWobbleStrength is 0\n\tfloat wobble = uWobbleStrength > 0. ? getWobble(projectedPosition.xyz) : 0.0;\n\n\tgl_Position = projectedPosition += wobble;\n\t\n\t// If picture is true then display picture, otherwise 4 color linear interpolation\n\tvColor = uIsPicture ? texture2D(uPicture, newUv).rgb : mix(mix(uColor0, uColor1, newPosition.x), mix(uColor2, uColor3, newPosition.y), newPosition.z);\n\n\t// Set Alpha on picture's g channel\n\tvPictureAlpha = uIsAlphaPicture ? texture2D(uAlphaPicture, newUv).g : 1.;\n\n\t// Multiply the point size by picturAalpha. The size can also be adjusted with alphaMap.\n\t// If uSizeRandomTimeFrequency is greater than 0, the size will be randomly changed\n\tfloat sizeRand = uSizeRandomIntensity > 0. ? mix(uSizeRandomMin,uSizeRandomMax,(simplexNoise4d(vec4(newPosition,uTime * uSizeRandomTimeFrequency))*.5+.5)) * uSizeRandomIntensity : 1.;\n\tgl_PointSize = uPointSize * vPictureAlpha * uResolution.y * sizeRand;\n\tgl_PointSize *= (1.0 / - viewPosition.z);\n\n\t// mapArrayIndex\n\tvMapArrayIndex = uMapArrayLength > 0. ? floor(random3D(position) * uMapArrayLength) : 0.;\n}","precision highp float;\nprecision highp int;\n\nvarying vec3 vColor;\nvarying float vPictureAlpha;\nvarying vec3 vDisplacementColor;\nvarying float vDisplacementIntensity;\nvarying float vMapArrayIndex;\n\nuniform float uBlurAlpha;\nuniform float uBlurRadius;\nuniform sampler2D uMap;\nuniform bool uIsMap;\nuniform sampler2D uAlphaMap;\nuniform bool uIsAlphaMap;\nuniform float uDisplacementColorIntensity;\nuniform float uPointAlpha;\n\n#usf <mapArrayUniforms>\n\nvoid main() {    \n\tvec2 uv = gl_PointCoord;\n\tuv.y = 1.0 - uv.y;\n   \n\t// make it a circle\n\tfloat distanceToCenter = length(uv - .5);\n\tfloat alpha = clamp(uBlurRadius / distanceToCenter - (1.-uBlurAlpha) , 0. , 1.);\n\n\t// Map if there is a map\t\n\tvec4 mapArrayColor;\n\t#usf <mapArraySwitcher>\n\tvec4 mapColor = isMapArray ? mapArrayColor : uIsMap ? texture2D(uMap,uv) : vec4(1.);\n\tvec3 finalColor = isMapArray || uIsMap ? mapColor.rgb : vColor;\n\n\t// Mix with finalColor if displacement is true\n\tfloat mixIntensity = clamp(uDisplacementColorIntensity * vDisplacementIntensity,0.,1.);\n\tfinalColor = vDisplacementIntensity > 0. ? mix(finalColor,vDisplacementColor,mixIntensity) : finalColor;\n\n\t// get alpha map\n\tfloat alphaMap = uIsAlphaMap ? texture2D(uAlphaMap,uv).g : 1.;\n\n\tgl_FragColor = vec4(finalColor,alpha * vPictureAlpha * alphaMap * mapColor.a * uPointAlpha);\n}\n","//\tSimplex 4D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip)\n{\n\tconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n\tvec4 p,s;\n\n\tp.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n\tp.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n\ts = vec4(lessThan(p, vec4(0.0)));\n\tp.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n\treturn p;\n}\n\nfloat simplexNoise4d(vec4 v)\n{\n\tconst vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n\t\t\t\t\t\t\t\t\t0.309016994374947451); // (sqrt(5) - 1)/4   F4\n\t// First corner\n\tvec4 i  = floor(v + dot(v, C.yyyy) );\n\tvec4 x0 = v -   i + dot(i, C.xxxx);\n\n\t// Other corners\n\n\t// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\tvec4 i0;\n\n\tvec3 isX = step( x0.yzw, x0.xxx );\n\tvec3 isYZ = step( x0.zww, x0.yyz );\n\t//  i0.x = dot( isX, vec3( 1.0 ) );\n\ti0.x = isX.x + isX.y + isX.z;\n\ti0.yzw = 1.0 - isX;\n\n\t//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n\ti0.y += isYZ.x + isYZ.y;\n\ti0.zw += 1.0 - isYZ.xy;\n\n\ti0.z += isYZ.z;\n\ti0.w += 1.0 - isYZ.z;\n\n\t// i0 now contains the unique values 0,1,2,3 in each channel\n\tvec4 i3 = clamp( i0, 0.0, 1.0 );\n\tvec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n\tvec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n\t//  x0 = x0 - 0.0 + 0.0 * C \n\tvec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n\tvec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n\tvec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n\tvec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n\t// Permutations\n\ti = mod(i, 289.0); \n\tfloat j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n\tvec4 j1 = permute( permute( permute( permute (\n\t\t\t\t\ti.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n\t\t\t\t+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n\t\t\t\t+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n\t\t\t\t+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\t// Gradients\n\t// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n\t// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n\tvec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n\tvec4 p0 = grad4(j0,   ip);\n\tvec4 p1 = grad4(j1.x, ip);\n\tvec4 p2 = grad4(j1.y, ip);\n\tvec4 p3 = grad4(j1.z, ip);\n\tvec4 p4 = grad4(j1.w, ip);\n\n\t// Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tp4 *= taylorInvSqrt(dot(p4,p4));\n\n\t// Mix contributions from the five corners\n\tvec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n\tvec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n\tm0 = m0 * m0;\n\tm1 = m1 * m1;\n\treturn 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n\t\t\t\t\t\t+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\nfloat getWobble(vec3 position)\n{\n\tvec3 warpedPosition = position;\n\twarpedPosition += simplexNoise4d(\n\t\tvec4(\n\t\t\t\tposition * uWarpPositionFrequency,\n\t\t\t\tuTime * uWarpTimeFrequency\n\t\t)\n\t) * uWarpStrength;\n\n\treturn simplexNoise4d(vec4(\n\t\twarpedPosition * uWobblePositionFrequency, // XYZ\n\t\tuTime * uWobbleTimeFrequency         // W\n\t)) * uWobbleStrength;\n}","export const ISDEV = process.env.NODE_ENV === \"development\";\n","import * as THREE from \"three\";\nimport { ISDEV } from \"../../../../libs/constants\";\n\nexport const rewriteVertexShader = (\n   modifeidAttributes: Float32Array[],\n   targetGeometry: THREE.BufferGeometry,\n   targetAttibute: \"position\" | \"uv\",\n   vertexShader: string,\n   itemSize: number\n) => {\n   const vTargetName =\n      targetAttibute === \"position\" ? \"positionTarget\" : \"uvTarget\";\n   const vAttributeRewriteKey =\n      targetAttibute === \"position\"\n         ? \"#usf <morphPositions>\"\n         : \"#usf <morphUvs>\";\n   const vTransitionRewriteKey =\n      targetAttibute === \"position\"\n         ? \"#usf <morphPositionTransition>\"\n         : \"#usf <morphUvTransition>\";\n   const vListName =\n      targetAttibute === \"position\" ? \"positionsList\" : \"uvsList\";\n   const vMorphTransition =\n      targetAttibute === \"position\"\n         ? `\n\t\t\t\tfloat scaledProgress = uMorphProgress * ${modifeidAttributes.length - 1}.;\n\t\t\t\tint baseIndex = int(floor(scaledProgress));\t\t\n\t\t\t\tbaseIndex = clamp(baseIndex, 0, ${modifeidAttributes.length - 1});\t\t\n\t\t\t\tfloat progress = fract(scaledProgress);\n\t\t\t\tint nextIndex = baseIndex + 1;\n\t\t\t\tnewPosition = mix(positionsList[baseIndex], positionsList[nextIndex], progress);\n\t\t\t`\n         : \"newUv = mix(uvsList[baseIndex], uvsList[nextIndex], progress);\";\n\n   if (modifeidAttributes.length > 0) {\n      // Delete the position at initialization and add the position after normalization\n      targetGeometry.deleteAttribute(targetAttibute);\n      targetGeometry.setAttribute(\n         targetAttibute,\n         new THREE.BufferAttribute(modifeidAttributes[0], itemSize)\n      );\n\n      let stringToAddToMorphAttibutes = \"\";\n      let stringToAddToMorphAttibutesList = \"\";\n\n      modifeidAttributes.forEach((target, index) => {\n         targetGeometry.setAttribute(\n            `${vTargetName}${index}`,\n            new THREE.BufferAttribute(target, itemSize)\n         );\n         stringToAddToMorphAttibutes += `attribute vec${itemSize} ${vTargetName}${index};\\n`;\n         if (index === 0) {\n            stringToAddToMorphAttibutesList += `${vTargetName}${index}`;\n         } else {\n            stringToAddToMorphAttibutesList += `,${vTargetName}${index}`;\n         }\n      });\n\n      vertexShader = vertexShader.replace(\n         `${vAttributeRewriteKey}`,\n         stringToAddToMorphAttibutes\n      );\n      vertexShader = vertexShader.replace(\n         `${vTransitionRewriteKey}`,\n         `vec${itemSize} ${vListName}[${modifeidAttributes.length}] = vec${itemSize}[](${stringToAddToMorphAttibutesList});\n\t\t\t\t${vMorphTransition}\n\t\t\t`\n      );\n   } else {\n      vertexShader = vertexShader.replace(`${vAttributeRewriteKey}`, \"\");\n      vertexShader = vertexShader.replace(`${vTransitionRewriteKey}`, \"\");\n      if (!targetGeometry?.attributes[targetAttibute]?.array) {\n         ISDEV &&\n            console.error(\n               `use-shader-fx:geometry.attributes.${targetAttibute}.array is not found`\n            );\n      }\n   }\n\n   return vertexShader;\n};\n","import * as THREE from \"three\";\n\n/**\n * Calculate the maximum length of attribute (position and uv) to match the length of all lists. Randomly map missing attributes when matching to maximum length\n * */\nexport const modifyAttributes = (\n   attribute: Float32Array[] | undefined,\n   targetGeometry: THREE.BufferGeometry,\n   targetAttibute: \"position\" | \"uv\",\n   itemSize: number\n) => {\n   let modifiedAttribute: Float32Array[] = [];\n   if (attribute && attribute.length > 0) {\n      if (targetGeometry?.attributes[targetAttibute]?.array) {\n         modifiedAttribute = [\n            targetGeometry.attributes[targetAttibute].array as Float32Array,\n            ...attribute,\n         ];\n      } else {\n         modifiedAttribute = attribute;\n      }\n\n      const maxLength = Math.max(...modifiedAttribute.map((arr) => arr.length));\n\n      modifiedAttribute.forEach((arr, i) => {\n         if (arr.length < maxLength) {\n            const diff = (maxLength - arr.length) / itemSize;\n            const addArray = [];\n            const oldArray = Array.from(arr);\n            for (let i = 0; i < diff; i++) {\n               const randomIndex =\n                  Math.floor((arr.length / itemSize) * Math.random()) *\n                  itemSize;\n               for (let j = 0; j < itemSize; j++) {\n                  addArray.push(oldArray[randomIndex + j]);\n               }\n            }\n            modifiedAttribute[i] = new Float32Array([...oldArray, ...addArray]);\n         }\n      });\n   }\n   return modifiedAttribute;\n};\n","import * as THREE from \"three\";\n\nexport const rewriteFragmentShader = (\n   mapArray: THREE.Texture[] | undefined,\n   fragmentShader: string\n) => {\n   let mapArrayShader = \"\";\n   const mapArrayUniforms: any = {};\n   let textureSwitcherCode = \"mapArrayColor = \";\n\n   if (mapArray && mapArray.length > 0) {\n      mapArray.forEach((map, index) => {\n         const condition = `vMapArrayIndex < ${index}.1`; // Comparison with a number with .1 added as the handling of floating points may vary between GPU drivers\n         const action = `texture2D(uMapArray${index}, uv)`;\n         textureSwitcherCode += `( ${condition} ) ? ${action} : `;\n         mapArrayShader += `\n        uniform sampler2D uMapArray${index};\n      `;\n         mapArrayUniforms[`uMapArray${index}`] = { value: map };\n      });\n      textureSwitcherCode += \"vec4(1.);\";\n      mapArrayShader += `bool isMapArray = true;`;\n      mapArrayUniforms[\"uMapArrayLength\"] = { value: mapArray.length };\n   } else {\n      textureSwitcherCode += \"vec4(1.0);\";\n      mapArrayShader += `bool isMapArray = false;`;\n      mapArrayUniforms[\"uMapArrayLength\"] = { value: 0 };\n   }\n   const rewritedFragmentShader = fragmentShader\n      .replace(`#usf <mapArraySwitcher>`, textureSwitcherCode)\n      .replace(`#usf <mapArrayUniforms>`, mapArrayShader);\n\n   return { rewritedFragmentShader, mapArrayUniforms };\n};\n","import * as THREE from \"three\";\nimport { useEffect, useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\nimport { useResolution } from \"../../../../utils/useResolution\";\nimport { setUniform } from \"../../../../utils/setUniforms\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/main.frag\";\nimport getWobble from \"../../../../libs/shaders/getWobble.glsl\";\nimport { MORPHPARTICLES_PARAMS } from \"..\";\nimport { ISDEV } from \"../../../../libs/constants\";\nimport { rewriteVertexShader } from \"./rewriteVertexShader\";\nimport { modifyAttributes } from \"./modifyAttributes\";\nimport { rewriteFragmentShader } from \"./rewriteFragmentShader\";\n\nexport class MorphParticlesMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uResolution: { value: THREE.Vector2 };\n      uMorphProgress: { value: number };\n      uBlurAlpha: { value: number };\n      uBlurRadius: { value: number };\n      uPointSize: { value: number };\n      uPointAlpha: { value: number };\n      uPicture: { value: THREE.Texture };\n      uIsPicture: { value: boolean };\n      uAlphaPicture: { value: THREE.Texture };\n      uIsAlphaPicture: { value: boolean };\n      uColor0: { value: THREE.Color };\n      uColor1: { value: THREE.Color };\n      uColor2: { value: THREE.Color };\n      uColor3: { value: THREE.Color };\n      uMap: { value: THREE.Texture };\n      uIsMap: { value: boolean };\n      uAlphaMap: { value: THREE.Texture };\n      uIsAlphaMap: { value: boolean };\n      uTime: { value: number };\n      uWobblePositionFrequency: { value: number };\n      uWobbleTimeFrequency: { value: number };\n      uWobbleStrength: { value: number };\n      uWarpPositionFrequency: { value: number };\n      uWarpTimeFrequency: { value: number };\n      uWarpStrength: { value: number };\n      uDisplacement: { value: THREE.Texture };\n      uIsDisplacement: { value: boolean };\n      uDisplacementIntensity: { value: number };\n      uDisplacementColorIntensity: { value: number };\n      uSizeRandomIntensity: { value: number };\n      uSizeRandomTimeFrequency: { value: number };\n      uSizeRandomMin: { value: number };\n      uSizeRandomMax: { value: number };\n      uDivergence: { value: number };\n      uDivergencePoint: { value: THREE.Vector3 };\n   };\n}\n\nexport const useMaterial = ({\n   size,\n   dpr,\n   geometry,\n   positions,\n   uvs,\n   mapArray,\n}: {\n   size: Size;\n   dpr: number | false;\n   geometry: THREE.BufferGeometry;\n   positions?: Float32Array[];\n   uvs?: Float32Array[];\n   mapArray?: THREE.Texture[];\n}) => {\n   const modifiedPositions = useMemo(\n      () => modifyAttributes(positions, geometry, \"position\", 3),\n      [positions, geometry]\n   );\n\n   const modifiedUvs = useMemo(\n      () => modifyAttributes(uvs, geometry, \"uv\", 2),\n      [uvs, geometry]\n   );\n\n   const material = useMemo(() => {\n      if (modifiedPositions.length !== modifiedUvs.length) {\n         ISDEV &&\n            console.log(\"use-shader-fx:positions and uvs are not matched\");\n      }\n\n      // vertex\n      const rewritedVertexShader = rewriteVertexShader(\n         modifiedUvs,\n         geometry,\n         \"uv\",\n         rewriteVertexShader(\n            modifiedPositions,\n            geometry,\n            \"position\",\n            vertexShader,\n            3\n         ),\n         2\n      ).replace(`#usf <getWobble>`, getWobble);\n\n      // fragment\n      const mapArraySwitch = rewriteFragmentShader(mapArray, fragmentShader);\n\n      return new THREE.ShaderMaterial({\n         vertexShader: rewritedVertexShader,\n         fragmentShader: mapArraySwitch.rewritedFragmentShader,\n         depthTest: false,\n         depthWrite: false,\n         transparent: true,\n         blending: THREE.AdditiveBlending,\n         uniforms: {\n            uResolution: { value: new THREE.Vector2(0, 0) },\n            uMorphProgress: { value: MORPHPARTICLES_PARAMS.morphProgress },\n            uBlurAlpha: { value: MORPHPARTICLES_PARAMS.blurAlpha },\n            uBlurRadius: { value: MORPHPARTICLES_PARAMS.blurRadius },\n            uPointSize: { value: MORPHPARTICLES_PARAMS.pointSize },\n            uPointAlpha: { value: MORPHPARTICLES_PARAMS.pointAlpha },\n            uPicture: { value: new THREE.Texture() },\n            uIsPicture: { value: false },\n            uAlphaPicture: { value: new THREE.Texture() },\n            uIsAlphaPicture: { value: false },\n            uColor0: { value: MORPHPARTICLES_PARAMS.color0 },\n            uColor1: { value: MORPHPARTICLES_PARAMS.color1 },\n            uColor2: { value: MORPHPARTICLES_PARAMS.color2 },\n            uColor3: { value: MORPHPARTICLES_PARAMS.color3 },\n            uMap: { value: new THREE.Texture() },\n            uIsMap: { value: false },\n            uAlphaMap: { value: new THREE.Texture() },\n            uIsAlphaMap: { value: false },\n            uTime: { value: 0 },\n            uWobblePositionFrequency: {\n               value: MORPHPARTICLES_PARAMS.wobblePositionFrequency,\n            },\n            uWobbleTimeFrequency: {\n               value: MORPHPARTICLES_PARAMS.wobbleTimeFrequency,\n            },\n            uWobbleStrength: { value: MORPHPARTICLES_PARAMS.wobbleStrength },\n            uWarpPositionFrequency: {\n               value: MORPHPARTICLES_PARAMS.warpPositionFrequency,\n            },\n            uWarpTimeFrequency: {\n               value: MORPHPARTICLES_PARAMS.warpTimeFrequency,\n            },\n            uWarpStrength: { value: MORPHPARTICLES_PARAMS.warpStrength },\n            uDisplacement: { value: new THREE.Texture() },\n            uIsDisplacement: { value: false },\n            uDisplacementIntensity: {\n               value: MORPHPARTICLES_PARAMS.displacementIntensity,\n            },\n            uDisplacementColorIntensity: {\n               value: MORPHPARTICLES_PARAMS.displacementColorIntensity,\n            },\n            uSizeRandomIntensity: {\n               value: MORPHPARTICLES_PARAMS.sizeRandomIntensity,\n            },\n            uSizeRandomTimeFrequency: {\n               value: MORPHPARTICLES_PARAMS.sizeRandomTimeFrequency,\n            },\n            uSizeRandomMin: { value: MORPHPARTICLES_PARAMS.sizeRandomMin },\n            uSizeRandomMax: { value: MORPHPARTICLES_PARAMS.sizeRandomMax },\n            uDivergence: { value: MORPHPARTICLES_PARAMS.divergence },\n            uDivergencePoint: { value: MORPHPARTICLES_PARAMS.divergencePoint },\n            ...mapArraySwitch.mapArrayUniforms,\n         },\n      });\n   }, [\n      geometry,\n      modifiedPositions,\n      modifiedUvs,\n      mapArray,\n   ]) as MorphParticlesMaterial;\n\n   const resolution = useResolution(size, dpr);\n   setUniform(material, \"uResolution\", resolution.clone());\n\n   return { material, modifiedPositions, modifiedUvs };\n};\n","import * as THREE from \"three\";\nimport { Size, RootState } from \"@react-three/fiber\";\nimport {\n   InteractiveMesh,\n   MorphParticlePoints,\n   useCreateObject,\n} from \"./utils/useCreateObject\";\nimport { useMaterial } from \"./utils/useMaterial\";\nimport { MorphParticlesParams } from \".\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { useCallback, useMemo } from \"react\";\nimport { Create3DHooksProps } from \"../types\";\nimport { Dpr } from \"../../types\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type UseCreateMorphParticlesProps = {\n   size: Size;\n   dpr: Dpr;\n   /** default : `THREE.SphereGeometry(1, 32, 32)` */\n   geometry?: THREE.BufferGeometry;\n   positions?: Float32Array[];\n   uvs?: Float32Array[];\n   /** Array of textures to map to points. Mapped at random. */\n   mapArray?: THREE.Texture[];\n};\n\ntype UpdateUniform = (\n   props: RootState | null,\n   params?: MorphParticlesParams\n) => void;\n\ntype UseCreateMorphParticlesReturn = [\n   UpdateUniform,\n   {\n      points: MorphParticlePoints;\n      interactiveMesh: InteractiveMesh;\n      positions: Float32Array[];\n      uvs: Float32Array[];\n   }\n];\n\nexport const useCreateMorphParticles = ({\n   size,\n   dpr,\n   scene = false,\n   geometry,\n   positions,\n   uvs,\n   mapArray,\n}: Create3DHooksProps &\n   UseCreateMorphParticlesProps): UseCreateMorphParticlesReturn => {\n   const _dpr = getDpr(dpr);\n\n   const morphGeometry = useMemo(() => {\n      const geo = geometry || new THREE.SphereGeometry(1, 32, 32);\n      geo.setIndex(null);\n      // Since it is a particle, normal is not necessary\n      geo.deleteAttribute(\"normal\");\n      return geo;\n   }, [geometry]);\n\n   const { material, modifiedPositions, modifiedUvs } = useMaterial({\n      size,\n      dpr: _dpr.shader,\n      geometry: morphGeometry,\n      positions,\n      uvs,\n      mapArray,\n   });\n\n   const { points, interactiveMesh } = useCreateObject({\n      scene,\n      geometry: morphGeometry,\n      material,\n   });\n\n   const updateUniform = useCallback<UpdateUniform>(\n      (props, params) => {\n         if (props) {\n            setUniform(\n               material,\n               \"uTime\",\n               params?.beat || props.clock.getElapsedTime()\n            );\n         }\n         if (params === undefined) {\n            return;\n         }\n         setUniform(material, \"uMorphProgress\", params.morphProgress);\n         setUniform(material, \"uBlurAlpha\", params.blurAlpha);\n         setUniform(material, \"uBlurRadius\", params.blurRadius);\n         setUniform(material, \"uPointSize\", params.pointSize);\n         setUniform(material, \"uPointAlpha\", params.pointAlpha);\n         if (params.picture) {\n            setUniform(material, \"uPicture\", params.picture);\n            setUniform(material, \"uIsPicture\", true);\n         } else if (params.picture === false) {\n            setUniform(material, \"uIsPicture\", false);\n         }\n         if (params.alphaPicture) {\n            setUniform(material, \"uAlphaPicture\", params.alphaPicture);\n            setUniform(material, \"uIsAlphaPicture\", true);\n         } else if (params.alphaPicture === false) {\n            setUniform(material, \"uIsAlphaPicture\", false);\n         }\n         setUniform(material, \"uColor0\", params.color0);\n         setUniform(material, \"uColor1\", params.color1);\n         setUniform(material, \"uColor2\", params.color2);\n         setUniform(material, \"uColor3\", params.color3);\n         if (params.map) {\n            setUniform(material, \"uMap\", params.map);\n            setUniform(material, \"uIsMap\", true);\n         } else if (params.map === false) {\n            setUniform(material, \"uIsMap\", false);\n         }\n         if (params.alphaMap) {\n            setUniform(material, \"uAlphaMap\", params.alphaMap);\n            setUniform(material, \"uIsAlphaMap\", true);\n         } else if (params.alphaMap === false) {\n            setUniform(material, \"uIsAlphaMap\", false);\n         }\n         setUniform(material, \"uWobbleStrength\", params.wobbleStrength);\n         setUniform(\n            material,\n            \"uWobblePositionFrequency\",\n            params.wobblePositionFrequency\n         );\n         setUniform(\n            material,\n            \"uWobbleTimeFrequency\",\n            params.wobbleTimeFrequency\n         );\n         setUniform(material, \"uWarpStrength\", params.warpStrength);\n         setUniform(\n            material,\n            \"uWarpPositionFrequency\",\n            params.warpPositionFrequency\n         );\n         setUniform(material, \"uWarpTimeFrequency\", params.warpTimeFrequency);\n         if (params.displacement) {\n            setUniform(material, \"uDisplacement\", params.displacement);\n            setUniform(material, \"uIsDisplacement\", true);\n         } else if (params.displacement === false) {\n            setUniform(material, \"uIsDisplacement\", false);\n         }\n         setUniform(\n            material,\n            \"uDisplacementIntensity\",\n            params.displacementIntensity\n         );\n         setUniform(\n            material,\n            \"uDisplacementColorIntensity\",\n            params.displacementColorIntensity\n         );\n         setUniform(\n            material,\n            \"uSizeRandomIntensity\",\n            params.sizeRandomIntensity\n         );\n         setUniform(\n            material,\n            \"uSizeRandomTimeFrequency\",\n            params.sizeRandomTimeFrequency\n         );\n         setUniform(material, \"uSizeRandomMin\", params.sizeRandomMin);\n         setUniform(material, \"uSizeRandomMax\", params.sizeRandomMax);\n         setUniform(material, \"uDivergence\", params.divergence);\n         setUniform(material, \"uDivergencePoint\", params.divergencePoint);\n      },\n      [material]\n   );\n\n   return [\n      updateUniform,\n      {\n         points,\n         interactiveMesh,\n         positions: modifiedPositions,\n         uvs: modifiedUvs,\n      },\n   ];\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { HooksReturn } from \"../../types\";\nimport {\n   useCreateMorphParticles,\n   UseCreateMorphParticlesProps,\n} from \"./useCreateMorphParticles\";\nimport { HooksProps3D } from \"../types\";\nimport { InteractiveMesh, MorphParticlePoints } from \"./utils/useCreateObject\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type MorphParticlesParams = {\n   /** progress value to morph vertices,0~1 */\n   morphProgress?: number;\n   blurAlpha?: number;\n   blurRadius?: number;\n   pointSize?: number;\n   /** default : `1` */\n   pointAlpha?: number;\n   /** Since the color is extracted based on the attribute `uv`, the intended behavior will not occur if there is no uv in the attribute. */\n   picture?: THREE.Texture | false;\n   /** The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). use the green channel when sampling this texture. It also affects the size of the point. default : `false` */\n   alphaPicture?: THREE.Texture | false;\n   color0?: THREE.Color;\n   color1?: THREE.Color;\n   color2?: THREE.Color;\n   color3?: THREE.Color;\n   /** This maps to point,texture */\n   map?: THREE.Texture | false;\n   /** The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). use the green channel when sampling this texture. default : `false` */\n   alphaMap?: THREE.Texture | false;\n   /** If ​​wobbleStrength is set to 0, wobble will stop. It will also affect noise calculation, default : `0` */\n   wobbleStrength?: number;\n   wobblePositionFrequency?: number;\n   wobbleTimeFrequency?: number;\n   /** default : `0` */\n   warpStrength?: number;\n   warpPositionFrequency?: number;\n   warpTimeFrequency?: number;\n   /** Manipulate the vertices using the color channels of this texture. The strength of the displacement changes depending on the g channel of this texture */\n   displacement?: THREE.Texture | false;\n   /** Strength of displacement. The strength of displacement depends on g ch, but is the value multiplied by it , default : `1` */\n   displacementIntensity?: number;\n   /** Strength to reflect color ch of displacement texture */\n   displacementColorIntensity?: number;\n   /** If set to 0, noise calculation stops, default : `0` */\n   sizeRandomIntensity?: number;\n   sizeRandomTimeFrequency?: number;\n   sizeRandomMin?: number;\n   sizeRandomMax?: number;\n   /** Divergence rate of a point. Negative cases are dense, positive cases are divergent, default : `0` */\n   divergence?: number;\n   /** Divergence centre point, default : `THREE.Vector3(0)` */\n   divergencePoint?: THREE.Vector3;\n   /** you can get into the rhythm ♪ , default : `false` */\n   beat?: number | false;\n};\n\nexport type MorphParticlesObject = {\n   scene: THREE.Scene;\n   points: MorphParticlePoints;\n   interactiveMesh: InteractiveMesh;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n   positions: Float32Array[];\n   uvs: Float32Array[];\n};\n\nexport const MORPHPARTICLES_PARAMS: MorphParticlesParams = Object.freeze({\n   morphProgress: 0,\n   blurAlpha: 0.9,\n   blurRadius: 0.05,\n   pointSize: 0.05,\n   pointAlpha: 1,\n   picture: false,\n   alphaPicture: false,\n   color0: new THREE.Color(0xff0000),\n   color1: new THREE.Color(0x00ff00),\n   color2: new THREE.Color(0x0000ff),\n   color3: new THREE.Color(0xffff00),\n   map: false,\n   alphaMap: false,\n   wobbleStrength: 0.0,\n   wobblePositionFrequency: 0.5,\n   wobbleTimeFrequency: 0.5,\n   warpStrength: 0.0,\n   warpPositionFrequency: 0.5,\n   warpTimeFrequency: 0.5,\n   displacement: false,\n   displacementIntensity: 1,\n   displacementColorIntensity: 0,\n   sizeRandomIntensity: 0,\n   sizeRandomTimeFrequency: 0.2,\n   sizeRandomMin: 0.5,\n   sizeRandomMax: 1.5,\n   divergence: 0,\n   divergencePoint: new THREE.Vector3(0),\n   beat: false,\n});\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx\n */\nexport const useMorphParticles = ({\n   size,\n   dpr,\n   samples = 0,\n   camera,\n   geometry,\n   positions,\n   uvs,\n}: HooksProps3D & UseCreateMorphParticlesProps): HooksReturn<\n   MorphParticlesParams,\n   MorphParticlesObject\n> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n\n   const [\n      updateUniform,\n      {\n         points,\n         interactiveMesh,\n         positions: generatedPositions,\n         uvs: generatedUvs,\n      },\n   ] = useCreateMorphParticles({ scene, size, dpr, geometry, positions, uvs });\n\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n      depthBuffer: true,\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: MorphParticlesParams) => {\n         updateUniform(props, updateParams);\n         return updateRenderTarget(props.gl);\n      },\n      [updateRenderTarget, updateUniform]\n   );\n\n   const setParams = useCallback(\n      (updateParams: MorphParticlesParams) => {\n         updateUniform(null, updateParams);\n      },\n      [updateUniform]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene,\n         points,\n         interactiveMesh,\n         renderTarget,\n         output: renderTarget.texture,\n         positions: generatedPositions,\n         uvs: generatedUvs,\n      },\n   ];\n};\n","import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\nexport {\n  computeMorphedAttributes,\n  estimateBytesUsed,\n  interleaveAttributes,\n  mergeBufferAttributes,\n  mergeBufferGeometries,\n  mergeVertices,\n  toCreasedNormals,\n  toTrianglesDrawMode\n};\n//# sourceMappingURL=BufferGeometryUtils.js.map\n","// <www.shadertoy.com/view/XsX3zB>\n//\tby Nikita Miropolskiy\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n\n\tvec3 s = floor(p + dot(p, vec3(F3)));\n\tvec3 x = p - s + dot(s, vec3(G3));\n\t\n\tvec3 e = step(vec3(0.0), x - x.yzx);\n\tvec3 i1 = e*(1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n \t\n\tvec3 x1 = x - i1 + G3;\n\tvec3 x2 = x - i2 + 2.0*G3;\n\tvec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\tvec4 w, d;\n\t \n\tw.x = dot(x, x);\n\tw.y = dot(x1, x1);\n\tw.z = dot(x2, x2);\n\tw.w = dot(x3, x3);\n\t \n\tw = max(0.6 - w, 0.0);\n\t \n\td.x = dot(random3(s), x);\n\td.y = dot(random3(s + i1), x1);\n\td.z = dot(random3(s + i2), x2);\n\td.w = dot(random3(s + 1.0), x3);\n\t \n\tw *= w;\n\tw *= w;\n\td *= w;\n\t \n\treturn dot(d, vec4(52.0));\n}\n\nfloat snoiseFractal(vec3 m) {\n\treturn   0.5333333* snoise(m)\n\t\t\t\t+0.2666667* snoise(2.0*m)\n\t\t\t\t+0.1333333* snoise(4.0*m)\n\t\t\t\t+0.0666667* snoise(8.0*m);\n}","#ifdef USE_TRANSMISSION\n\n\t// Transmission code is based on glTF-Sampler-Viewer\n\t// https://github.com/KhronosGroup/glTF-Sample-Viewer\n\n\tuniform float _transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\tuniform sampler2D transmissionMap;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tuniform sampler2D thicknessMap;\n\n\t#endif\n\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\n\tvarying vec3 vWorldPosition;\n\n\t// Mipped Bicubic Texture Filtering by N8\n\t// https://www.shadertoy.com/view/Dl2SDW\n\n\tfloat w0( float a ) {\n\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\n\t}\n\n\tfloat w1( float a ) {\n\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\n\t}\n\n\tfloat w2( float a ){\n\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\n\t}\n\n\tfloat w3( float a ) {\n\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\n\t}\n\n\t// g0 and g1 are the two amplitude functions\n\tfloat g0( float a ) {\n\n\t\treturn w0( a ) + w1( a );\n\n\t}\n\n\tfloat g1( float a ) {\n\n\t\treturn w2( a ) + w3( a );\n\n\t}\n\n\t// h0 and h1 are the two offset functions\n\tfloat h0( float a ) {\n\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\n\t}\n\n\tfloat h1( float a ) {\n\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\n\t}\n\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\n\t\tuv = uv * texelSize.zw + 0.5;\n\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\n\t}\n\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\n\t}\n\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\n\t\t// Direction of refracted light.\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\n\t\t// Compute rotation-independant scaling of the model matrix.\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t// The thickness is specified in local space.\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\n\t}\n\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\n\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\n\t}\n\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\n\t}\n\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\n\t\tif ( isinf( attenuationDistance ) ) {\n\n\t\t\t// Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.\n\t\t\treturn vec3( 1.0 );\n\n\t\t} else {\n\n\t\t\t// Compute light attenuation using Beer's law.\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n\t\t\treturn transmittance;\n\n\t\t}\n\n\t}\n\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\n\t\t// Get the specular component.\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\n\t\t// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job \n\t\t// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\n\t}\n#endif","#ifdef USE_TRANSMISSION\n\nmaterial.transmission = _transmission;\nmaterial.transmissionAlpha = 1.0;\nmaterial.thickness = thickness;\nmaterial.attenuationDistance = attenuationDistance;\nmaterial.attenuationColor = attenuationColor;\n\n#ifdef USE_TRANSMISSIONMAP\n\n\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\n#endif\n\n#ifdef USE_THICKNESSMAP\n\n\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\n#endif\n\nvec3 pos = vWorldPosition;\n\nvec3 v = normalize( cameraPosition - pos );\nvec3 n = inverseTransformDirection( normal, viewMatrix );\n\nvec4 transmitted = getIBLVolumeRefraction(\n\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\tmaterial.attenuationColor, material.attenuationDistance );\n\nmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\n// Custom from here\nfloat runningSeed = 0.0;\nvec3 transmission = vec3(0.0);\nfloat transmissionR, transmissionB, transmissionG;\nfloat randomCoords = rand(runningSeed++);\nfloat thickness_smear = thickness * max(pow(roughnessFactor, 0.33), uAnisotropicBlur);\nvec3 distortionNormal = vec3(0.0);\nvec3 temporalOffset = vec3(uTime, -uTime, -uTime) * uTemporalDistortion;\n\nif (uDistortion > 0.0) {\n\tdistortionNormal = uDistortion * vec3(snoiseFractal(vec3((pos * uDistortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * uDistortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * uDistortionScale + temporalOffset)));\n}\n\nfor (float i = 0.0; i < uSamples; i ++) {\n\tvec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5)) * pow(rand(runningSeed++), 0.33) + distortionNormal);\n\t\n\ttransmissionR = getIBLVolumeRefraction(\n\t\tsampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / uSamples,\n\t\tmaterial.attenuationColor, material.attenuationDistance\n\t).r;\n\ttransmissionG = getIBLVolumeRefraction(\n\t\tsampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + uChromaticAberration * (i + randomCoords) / uSamples) , material.thickness + thickness_smear * (i + randomCoords) / uSamples,\n\t\tmaterial.attenuationColor, material.attenuationDistance\n\t).g;\n\ttransmissionB = getIBLVolumeRefraction(\n\t\tsampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * uChromaticAberration * (i + randomCoords) / uSamples), material.thickness + thickness_smear * (i + randomCoords) / uSamples,\n\t\tmaterial.attenuationColor, material.attenuationDistance\n\t).b;\n\ttransmission.r += transmissionR;\n\ttransmission.g += transmissionG;\n\ttransmission.b += transmissionB;\n}\n\ntransmission /= uSamples;\n// to here\n\ntotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n\n#endif","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport getWobble from \"../../../libs/shaders/getWobble.glsl\";\nimport snoise from \"../../../libs/shaders/snoise.glsl\";\nimport transmission_pars_fragment from \"./shaders/transmission_pars_fragment.glsl\";\nimport transmission_fragment from \"./shaders/transmission_fragment.glsl\";\nimport { WOBBLE3D_PARAMS } from \".\";\n\nexport class Wobble3DMaterial extends THREE.Material {\n   uniforms!: {\n      uTime: { value: number };\n      uWobblePositionFrequency: { value: number };\n      uWobbleTimeFrequency: { value: number };\n      uWobbleStrength: { value: number };\n      uWarpPositionFrequency: { value: number };\n      uWarpTimeFrequency: { value: number };\n      uWarpStrength: { value: number };\n      uWobbleShine: { value: number };\n      uColor0: { value: THREE.Color };\n      uColor1: { value: THREE.Color };\n      uColor2: { value: THREE.Color };\n      uColor3: { value: THREE.Color };\n      uColorMix: { value: number };\n      uChromaticAberration: { value: number };\n      uAnisotropicBlur: { value: number };\n      uDistortion: { value: number };\n      uDistortionScale: { value: number };\n      uTemporalDistortion: { value: number };\n      uSamples: { value: number };\n   };\n}\n\n/** You also need to rewrite the vertext shader of depthMaterial */\nconst rewriteVertex = (vertex: string) => {\n   let shader = vertex;\n   shader = shader.replace(\n      \"#include <beginnormal_vertex>\",\n      `\n\t\tvec3 objectNormal = usf_Normal;\n\t\t#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t\t#endif`\n   );\n   // position\n   shader = shader.replace(\n      \"#include <begin_vertex>\",\n      `\n\t\tvec3 transformed = usf_Position;`\n   );\n\n   // uniforms\n   shader = shader.replace(\n      \"void main() {\",\n      `\n\t\tuniform float uTime;\n\t\tuniform float uWobblePositionFrequency;\n\t\tuniform float uWobbleTimeFrequency;\n\t\tuniform float uWobbleStrength;\n\t\tuniform float uWarpPositionFrequency;\n\t\tuniform float uWarpTimeFrequency;\n\t\tuniform float uWarpStrength;\n\t\tattribute vec4 tangent;\n\t\tvarying float vWobble;\n\t\tvarying vec2 vPosition;\n\t\t// #usf <getWobble>\n\t\tvoid main() {`\n   );\n\n   // wobble\n   shader = shader.replace(\"// #usf <getWobble>\", `${getWobble}`);\n\n   // vert\n   shader = shader.replace(\n      \"void main() {\",\n      `\n\t\tvoid main() {\n\t\tvec3 usf_Position = position;\n\t\tvec3 usf_Normal = normal;\n\t\tvec3 biTangent = cross(normal, tangent.xyz);\n\t\t\n\t\t// Neighbours positions\n\t\tfloat shift = 0.01;\n\t\tvec3 positionA = usf_Position + tangent.xyz * shift;\n\t\tvec3 positionB = usf_Position + biTangent * shift;\n\t\t// Wobble\n\t\tfloat wobble = getWobble(usf_Position);\n\t\tusf_Position += wobble * normal;\n\t\tpositionA    += getWobble(positionA) * normal;\n\t\tpositionB    += getWobble(positionB) * normal;\n\t\t// Compute normal\n\t\tvec3 toA = normalize(positionA - usf_Position);\n\t\tvec3 toB = normalize(positionB - usf_Position);\n\t\tusf_Normal = cross(toA, toB);\n\t\t// Varying\n\t\tvPosition = usf_Position.xy;\n\t\tvWobble = wobble / uWobbleStrength;`\n   );\n   return shader;\n};\n\nexport type WobbleMaterialConstructor = new (opts: {\n   [key: string]: any;\n}) => THREE.Material;\ntype MaterialParams<T extends WobbleMaterialConstructor> =\n   ConstructorParameters<T>[0];\nexport type WobbleMaterialProps<T extends WobbleMaterialConstructor> = {\n   /** default:THREE.MeshPhysicalMaterial */\n   baseMaterial?: T;\n   materialParameters?: MaterialParams<T>;\n};\n\nexport const useMaterial = <T extends WobbleMaterialConstructor>({\n   baseMaterial,\n   materialParameters,\n}: WobbleMaterialProps<T>) => {\n   const { material, depthMaterial } = useMemo(() => {\n      const mat = new (baseMaterial || THREE.MeshPhysicalMaterial)(\n         materialParameters || {}\n      );\n      const hasRoughness =\n         mat.type === \"MeshPhysicalMaterial\" ||\n         mat.type === \"MeshStandardMaterial\";\n\n      const hasTransmission = mat.type === \"MeshPhysicalMaterial\";\n\n      Object.assign(mat.userData, {\n         uniforms: {\n            uTime: { value: 0 },\n            uWobblePositionFrequency: {\n               value: WOBBLE3D_PARAMS.wobblePositionFrequency,\n            },\n            uWobbleTimeFrequency: {\n               value: WOBBLE3D_PARAMS.wobbleTimeFrequency,\n            },\n            uWobbleStrength: { value: WOBBLE3D_PARAMS.wobbleStrength },\n            uWarpPositionFrequency: {\n               value: WOBBLE3D_PARAMS.warpPositionFrequency,\n            },\n            uWarpTimeFrequency: { value: WOBBLE3D_PARAMS.warpTimeFrequency },\n            uWarpStrength: { value: WOBBLE3D_PARAMS.warpStrength },\n            uWobbleShine: { value: WOBBLE3D_PARAMS.wobbleShine },\n            uColor0: { value: WOBBLE3D_PARAMS.color0 },\n            uColor1: { value: WOBBLE3D_PARAMS.color1 },\n            uColor2: { value: WOBBLE3D_PARAMS.color2 },\n            uColor3: { value: WOBBLE3D_PARAMS.color3 },\n            uColorMix: { value: WOBBLE3D_PARAMS.colorMix },\n            uChromaticAberration: {\n               value: WOBBLE3D_PARAMS.chromaticAberration,\n            },\n            uAnisotropicBlur: { value: WOBBLE3D_PARAMS.anisotropicBlur },\n            uDistortion: { value: WOBBLE3D_PARAMS.distortion },\n            uDistortionScale: { value: WOBBLE3D_PARAMS.distortionScale },\n            uTemporalDistortion: { value: WOBBLE3D_PARAMS.temporalDistortion },\n            uSamples: { value: WOBBLE3D_PARAMS.samples },\n            transmission: { value: 0 },\n            _transmission: { value: 1 },\n            transmissionMap: { value: null },\n         },\n      });\n\n      mat.onBeforeCompile = (shader) => {\n         Object.assign(shader.uniforms, mat.userData.uniforms);\n\n         /********************\n\t\t\tvert\n\t\t\t********************/\n         shader.vertexShader = rewriteVertex(shader.vertexShader);\n\n         /********************\n\t\t\tfrag\n\t\t\t********************/\n         // diffuse color , Manipulate color mixing ratio with `uColorMix`\n         shader.fragmentShader = shader.fragmentShader.replace(\n            \"#include <color_fragment>\",\n            `\n\t\t\t\t#include <color_fragment>\n\t\t\t\tdiffuseColor = mix(diffuseColor,usf_DiffuseColor,uColorMix);`\n         );\n\n         // roughness\n         if (hasRoughness) {\n            shader.fragmentShader = shader.fragmentShader.replace(\n               \"#include <roughnessmap_fragment>\",\n               `\n\t\t\t\t\t#include <roughnessmap_fragment>\n\t\t\t\t\troughnessFactor = usf_Roughness;`\n            );\n         }\n\n         // frag\n         shader.fragmentShader = shader.fragmentShader.replace(\n            \"void main() {\",\n            `\n\t\t\t\tuniform vec3 uColor0;\n\t\t\t\tuniform vec3 uColor1;\n\t\t\t\tuniform vec3 uColor2;\n\t\t\t\tuniform vec3 uColor3;\n\t\t\t\tuniform float uColorMix;\n\t\t\t\tuniform float uWobbleShine;\n\t\t\t\t\n\t\t\t\t// transmission\n\t\t\t\tuniform float uChromaticAberration;         \n\t\t\t\tuniform float uAnisotropicBlur;      \n\t\t\t\tuniform float uTime;\n\t\t\t\tuniform float uDistortion;\n\t\t\t\tuniform float uDistortionScale;\n\t\t\t\tuniform float uTemporalDistortion;\n\t\t\t\tuniform float uSamples;\n\t\t\t\t\n\t\t\t\tfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\t\t\t\t${snoise}\n\n\t\t\t\tvarying float vWobble;\n\t\t\t\tvarying vec2 vPosition;\n\t\t\t\tvoid main(){\n\t\t\t\t\tvec4 usf_DiffuseColor = vec4(1.0);\n\t\t\t\t\t${hasRoughness ? \"float usf_Roughness = roughness;\" : \"\"}\n\t\t\t\t\tfloat colorWobbleMix = smoothstep(-1.,1.,vWobble);\n\t\t\t\t\tvec2 colorPosMix = vec2(smoothstep(-1.,1.,vPosition.x),smoothstep(-1.,1.,vPosition.y));\n\t\t\t\t\n\t\t\t\t\tusf_DiffuseColor.rgb = mix(mix(uColor0, uColor1, colorPosMix.x), mix(uColor2, uColor3, colorPosMix.y), colorWobbleMix);\n\n\t\t\t\t\t${\n                  hasRoughness\n                     ? \"usf_Roughness = max(roughness - colorWobbleMix * uWobbleShine,0.);\"\n                     : \"\"\n               }`\n         );\n\n         // transmission\n         if (hasTransmission) {\n            shader.fragmentShader = shader.fragmentShader.replace(\n               \"#include <transmission_pars_fragment>\",\n               `${transmission_pars_fragment}`\n            );\n\n            shader.fragmentShader = shader.fragmentShader.replace(\n               \"#include <transmission_fragment>\",\n               `${transmission_fragment}`\n            );\n         }\n      };\n      mat.needsUpdate = true;\n\n      /*===============================================\n\t\tdepthMaterial\n\t\t===============================================*/\n      const depthMat = new THREE.MeshDepthMaterial({\n         depthPacking: THREE.RGBADepthPacking,\n      });\n      depthMat.onBeforeCompile = (shader) => {\n         Object.assign(shader.uniforms, mat.userData.uniforms);\n         shader.vertexShader = rewriteVertex(shader.vertexShader);\n      };\n      depthMat.needsUpdate = true;\n\n      return { material: mat, depthMaterial: depthMat };\n   }, [materialParameters, baseMaterial]);\n\n   return {\n      material: material as Wobble3DMaterial,\n      depthMaterial,\n   };\n};\n","import * as THREE from \"three\";\nimport { RootState } from \"@react-three/fiber\";\nimport { mergeVertices } from \"three-stdlib\";\nimport {\n   useMaterial,\n   Wobble3DMaterial,\n   WobbleMaterialProps,\n   WobbleMaterialConstructor,\n} from \"./useMaterial\";\nimport { Wobble3DParams } from \".\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { useCallback, useMemo } from \"react\";\nimport { useAddObject } from \"../../../utils/useAddObject\";\nimport { Create3DHooksProps } from \"../types\";\n\nexport type UseCreateWobble3DProps = {\n   /** default : `THREE.IcosahedronGeometry(2,20)` */\n   geometry?: THREE.BufferGeometry;\n};\n\ntype UpdateUniform = (props: RootState | null, params?: Wobble3DParams) => void;\ntype UseCreateWobble3DReturn<T> = [\n   UpdateUniform,\n   {\n      mesh: THREE.Mesh;\n      depthMaterial: THREE.MeshDepthMaterial;\n   }\n];\n\nexport const useCreateWobble3D = <T extends WobbleMaterialConstructor>({\n   scene = false,\n   geometry,\n   baseMaterial,\n   materialParameters,\n}: UseCreateWobble3DProps &\n   Create3DHooksProps &\n   WobbleMaterialProps<T>): UseCreateWobble3DReturn<T> => {\n   const wobbleGeometry = useMemo(() => {\n      let geo = geometry || new THREE.IcosahedronGeometry(2, 20);\n      geo = mergeVertices(geo);\n      geo.computeTangents();\n      return geo;\n   }, [geometry]);\n   const { material, depthMaterial } = useMaterial({\n      baseMaterial,\n      materialParameters,\n   });\n\n   const mesh = useAddObject(scene, wobbleGeometry, material, THREE.Mesh);\n\n   const updateUniform = useCallback<UpdateUniform>(\n      (props, params) => {\n         const userData = material.userData as Wobble3DMaterial;\n         if (props) {\n            setUniform(\n               userData,\n               \"uTime\",\n               params?.beat || props.clock.getElapsedTime()\n            );\n         }\n         if (params === undefined) {\n            return;\n         }\n         setUniform(userData, \"uWobbleStrength\", params.wobbleStrength);\n         setUniform(\n            userData,\n            \"uWobblePositionFrequency\",\n            params.wobblePositionFrequency\n         );\n         setUniform(\n            userData,\n            \"uWobbleTimeFrequency\",\n            params.wobbleTimeFrequency\n         );\n         setUniform(userData, \"uWarpStrength\", params.warpStrength);\n         setUniform(\n            userData,\n            \"uWarpPositionFrequency\",\n            params.warpPositionFrequency\n         );\n         setUniform(userData, \"uWarpTimeFrequency\", params.warpTimeFrequency);\n         setUniform(userData, \"uWobbleShine\", params.wobbleShine);\n         setUniform(userData, \"uSamples\", params.samples);\n         setUniform(userData, \"uColor0\", params.color0);\n         setUniform(userData, \"uColor1\", params.color1);\n         setUniform(userData, \"uColor2\", params.color2);\n         setUniform(userData, \"uColor3\", params.color3);\n         setUniform(userData, \"uColorMix\", params.colorMix);\n         setUniform(\n            userData,\n            \"uChromaticAberration\",\n            params.chromaticAberration\n         );\n         setUniform(userData, \"uAnisotropicBlur\", params.anisotropicBlur);\n         setUniform(userData, \"uDistortion\", params.distortion);\n         setUniform(userData, \"uDistortionScale\", params.distortionScale);\n         setUniform(userData, \"uTemporalDistortion\", params.temporalDistortion);\n      },\n      [material]\n   );\n\n   return [\n      updateUniform,\n      {\n         mesh,\n         depthMaterial,\n      },\n   ];\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { HooksReturn } from \"../../types\";\nimport { useCreateWobble3D, UseCreateWobble3DProps } from \"./useCreateWobble3D\";\nimport { WobbleMaterialProps, WobbleMaterialConstructor } from \"./useMaterial\";\nimport { HooksProps3D } from \"../types\";\nimport { getDpr } from \"../../../utils/getDpr\";\n\nexport type Wobble3DParams = {\n   wobbleStrength?: number;\n   wobblePositionFrequency?: number;\n   wobbleTimeFrequency?: number;\n   /** The roughness is attenuated by the strength of the wobble. It has no meaning if the roughness is set to 0 or if the material does not have a roughness param ,default : `0` */\n   wobbleShine?: number;\n   warpStrength?: number;\n   warpPositionFrequency?: number;\n   warpTimeFrequency?: number;\n   /** Refraction samples, default : `6`  */\n   samples?: number;\n   color0?: THREE.Color;\n   color1?: THREE.Color;\n   color2?: THREE.Color;\n   color3?: THREE.Color;\n   /** Mixing ratio with the material's original output color, 0~1 , defaulat : `1` */\n   colorMix?: number;\n   /** valid only for MeshPhysicalMaterial , default : `0.5` */\n   chromaticAberration?: number;\n   /** valid only for MeshPhysicalMaterial , default : `0.1` */\n   anisotropicBlur?: number;\n   /** valid only for MeshPhysicalMaterial , default : `0.1` */\n   distortion?: number;\n   /** valid only for MeshPhysicalMaterial , default : `0.1` */\n   distortionScale?: number;\n   /** valid only for MeshPhysicalMaterial , default : `0.1` */\n   temporalDistortion?: number;\n   /** you can get into the rhythm ♪ , default : `false` */\n   beat?: number | false;\n};\n\nexport type Wobble3DObject = {\n   scene: THREE.Scene;\n   mesh: THREE.Mesh;\n   depthMaterial: THREE.MeshDepthMaterial;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const WOBBLE3D_PARAMS: Wobble3DParams = Object.freeze({\n   beat: false,\n   wobbleStrength: 0.3,\n   wobblePositionFrequency: 0.5,\n   wobbleTimeFrequency: 0.4,\n   wobbleShine: 0,\n   warpStrength: 1.7,\n   warpPositionFrequency: 0.38,\n   warpTimeFrequency: 0.12,\n   samples: 6,\n   color0: new THREE.Color(0xff0000),\n   color1: new THREE.Color(0x00ff00),\n   color2: new THREE.Color(0x0000ff),\n   color3: new THREE.Color(0xffff00),\n   colorMix: 1,\n   chromaticAberration: 0.5,\n   anisotropicBlur: 0.1,\n   distortion: 0.1,\n   distortionScale: 0.1,\n   temporalDistortion: 0.1,\n});\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx\n */\nexport const useWobble3D = <T extends WobbleMaterialConstructor>({\n   size,\n   dpr,\n   samples = 0,\n   camera,\n   geometry,\n   baseMaterial,\n   materialParameters,\n}: HooksProps3D & UseCreateWobble3DProps & WobbleMaterialProps<T>): HooksReturn<\n   Wobble3DParams,\n   Wobble3DObject\n> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n\n   const [updateUniform, { mesh, depthMaterial }] = useCreateWobble3D({\n      baseMaterial,\n      materialParameters,\n      scene,\n      geometry,\n   });\n\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n      depthBuffer: true,\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: Wobble3DParams) => {\n         updateUniform(props, updateParams);\n         return updateRenderTarget(props.gl);\n      },\n      [updateRenderTarget, updateUniform]\n   );\n\n   const setParams = useCallback(\n      (updateParams: Wobble3DParams) => {\n         updateUniform(null, updateParams);\n      },\n      [updateUniform]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene,\n         mesh,\n         depthMaterial,\n         renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","import * as THREE from \"three\";\nimport { useEffect, useMemo } from \"react\";\n\n/** Generate mesh from geometry and material and add to scene */\nexport const useAddMesh = (\n   scene: THREE.Scene,\n   geometry: THREE.BufferGeometry,\n   material: THREE.Material\n) => {\n   const mesh = useMemo(() => {\n      const mesh = new THREE.Mesh(geometry, material);\n      scene.add(mesh);\n      return mesh;\n   }, [geometry, material, scene]);\n\n   useEffect(() => {\n      return () => {\n         scene.remove(mesh);\n         geometry.dispose();\n         material.dispose();\n      };\n   }, [scene, geometry, material, mesh]);\n\n   return mesh;\n};\n","export type EasingTypes =\n   | \"easeInSine\"\n   | \"easeOutSine\"\n   | \"easeInOutSine\"\n   | \"easeInQuad\"\n   | \"easeOutQuad\"\n   | \"easeInOutQuad\"\n   | \"easeInCubic\"\n   | \"easeOutCubic\"\n   | \"easeInOutCubic\"\n   | \"easeInQuart\"\n   | \"easeOutQuart\"\n   | \"easeInOutQuart\"\n   | \"easeInQuint\"\n   | \"easeOutQuint\"\n   | \"easeInOutQuint\"\n   | \"easeInExpo\"\n   | \"easeOutExpo\"\n   | \"easeInOutExpo\"\n   | \"easeInCirc\"\n   | \"easeOutCirc\"\n   | \"easeInOutCirc\"\n   | \"easeInBack\"\n   | \"easeOutBack\"\n   | \"easeInOutBack\"\n   | \"easeInElastic\"\n   | \"easeOutElastic\"\n   | \"easeInOutElastic\"\n   | \"easeInBounce\"\n   | \"easeOutBounce\"\n   | \"easeInOutBounce\";\n\ntype EasingFunctions = {\n   [K in EasingTypes]: (x: number) => number;\n};\n\n/**\n * from https://github.com/ai/easings.net\n */\nexport const Easing: EasingFunctions = Object.freeze({\n   easeInSine(x: number): number {\n      return 1 - Math.cos((x * Math.PI) / 2);\n   },\n   easeOutSine(x: number): number {\n      return Math.sin((x * Math.PI) / 2);\n   },\n   easeInOutSine(x: number): number {\n      return -(Math.cos(Math.PI * x) - 1) / 2;\n   },\n   easeInQuad(x: number): number {\n      return x * x;\n   },\n   easeOutQuad(x: number): number {\n      return 1 - (1 - x) * (1 - x);\n   },\n   easeInOutQuad(x: number): number {\n      return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;\n   },\n   easeInCubic(x: number): number {\n      return x * x * x;\n   },\n   easeOutCubic(x: number): number {\n      return 1 - Math.pow(1 - x, 3);\n   },\n   easeInOutCubic(x: number): number {\n      return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;\n   },\n   easeInQuart(x: number): number {\n      return x * x * x * x;\n   },\n   easeOutQuart(x: number): number {\n      return 1 - Math.pow(1 - x, 4);\n   },\n   easeInOutQuart(x: number): number {\n      return x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2;\n   },\n   easeInQuint(x: number): number {\n      return x * x * x * x * x;\n   },\n   easeOutQuint(x: number): number {\n      return 1 - Math.pow(1 - x, 5);\n   },\n   easeInOutQuint(x: number): number {\n      return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;\n   },\n   easeInExpo(x: number): number {\n      return x === 0 ? 0 : Math.pow(2, 10 * x - 10);\n   },\n   easeOutExpo(x: number): number {\n      return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);\n   },\n   easeInOutExpo(x: number): number {\n      return x === 0\n         ? 0\n         : x === 1\n         ? 1\n         : x < 0.5\n         ? Math.pow(2, 20 * x - 10) / 2\n         : (2 - Math.pow(2, -20 * x + 10)) / 2;\n   },\n   easeInCirc(x: number): number {\n      return 1 - Math.sqrt(1 - Math.pow(x, 2));\n   },\n   easeOutCirc(x: number): number {\n      return Math.sqrt(1 - Math.pow(x - 1, 2));\n   },\n   easeInOutCirc(x: number): number {\n      return x < 0.5\n         ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2\n         : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;\n   },\n   easeInBack(x: number): number {\n      const c1 = 1.70158;\n      const c3 = c1 + 1;\n\n      return c3 * x * x * x - c1 * x * x;\n   },\n   easeOutBack(x: number): number {\n      const c1 = 1.70158;\n      const c3 = c1 + 1;\n\n      return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);\n   },\n   easeInOutBack(x: number): number {\n      const c1 = 1.70158;\n      const c2 = c1 * 1.525;\n\n      return x < 0.5\n         ? (Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n         : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n   },\n   easeInElastic(x: number): number {\n      const c4 = (2 * Math.PI) / 3;\n\n      return x === 0\n         ? 0\n         : x === 1\n         ? 1\n         : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4);\n   },\n   easeOutElastic(x: number): number {\n      const c4 = (2 * Math.PI) / 3;\n\n      return x === 0\n         ? 0\n         : x === 1\n         ? 1\n         : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;\n   },\n   easeInOutElastic(x: number): number {\n      const c5 = (2 * Math.PI) / 4.5;\n\n      return x === 0\n         ? 0\n         : x === 1\n         ? 1\n         : x < 0.5\n         ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2\n         : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) / 2 +\n           1;\n   },\n   easeInBounce(x: number): number {\n      return 1 - Easing.easeOutBounce(1 - x);\n   },\n   easeOutBounce(x: number): number {\n      const n1 = 7.5625;\n      const d1 = 2.75;\n\n      if (x < 1 / d1) {\n         return n1 * x * x;\n      } else if (x < 2 / d1) {\n         return n1 * (x -= 1.5 / d1) * x + 0.75;\n      } else if (x < 2.5 / d1) {\n         return n1 * (x -= 2.25 / d1) * x + 0.9375;\n      } else {\n         return n1 * (x -= 2.625 / d1) * x + 0.984375;\n      }\n   },\n   easeInOutBounce(x: number): number {\n      return x < 0.5\n         ? (1 - Easing.easeOutBounce(1 - 2 * x)) / 2\n         : (1 + Easing.easeOutBounce(2 * x - 1)) / 2;\n   },\n});\n","import * as THREE from \"three\";\nimport { Easing, EasingTypes } from \"../libs/easing\";\nimport { useCallback } from \"react\";\n\n/** Returns a unique hash specific to the beat */\nfunction getHash(input: number) {\n   let n = Math.sin(input * 12.9898) * 43758.5453;\n   return n - Math.floor(n);\n}\n\ntype BeatValues = {\n   beat: number;\n   floor: number;\n   fract: number;\n   /** unique hash specific to the beat */\n   hash: number;\n};\n\n/**\n * @param ease easing functions are referenced from https://github.com/ai/easings.net , default : \"easeOutQuart\"\n */\nexport const useBeat = (bpm: number, ease: EasingTypes = \"easeOutQuart\") => {\n   const rhythm = bpm / 60;\n   const easing = Easing[ease];\n   const updateBeat = useCallback(\n      (clock: THREE.Clock) => {\n         let beat = clock.getElapsedTime() * rhythm;\n         const floor = Math.floor(beat);\n         const fract = easing(beat - floor);\n         beat = fract + floor;\n         const hash = getHash(floor);\n         return {\n            beat,\n            floor,\n            fract,\n            hash,\n         } as BeatValues;\n      },\n      [rhythm, easing]\n   );\n   return updateBeat;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo, useRef } from \"react\";\n\n/**\n * @param fps FPS you want to limit , default : `60`\n *\n * ```tsx\n * const limiter = useFPSLimiter(fps);\n * useFrame((props) => {\n *     if (limiter(props.clock)) {\n *\t\t    //some code\n *     }\n * });\n * ```\n */\nexport const useFPSLimiter = (fps: number = 60) => {\n   const interval = useMemo(() => 1 / Math.max(Math.min(fps, 60), 1), [fps]);\n   const prevTime = useRef<number | null>(null);\n\n   const limiter = useCallback(\n      (clock: THREE.Clock) => {\n         const tick = clock.getElapsedTime();\n         if (prevTime.current === null) {\n            prevTime.current = tick;\n            return true;\n         }\n         const deltaTime = tick - prevTime.current;\n         if (deltaTime >= interval) {\n            prevTime.current = tick;\n            return true;\n         }\n         return false;\n      },\n      [interval]\n   );\n\n   return limiter;\n};\n","import { DomSyncerParams } from \"..\";\n\nexport const errorHandler = (params: DomSyncerParams) => {\n   const domLength = params.dom?.length;\n   const textureLength = params.texture?.length;\n\n   if (!domLength || !textureLength) {\n      return true;\n   }\n\n   if (domLength !== textureLength) {\n      return true;\n   }\n\n   return false;\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D u_texture;\nuniform vec2 u_textureResolution;\nuniform vec2 u_resolution;\nuniform float u_borderRadius;\n\nvoid main() {\n\t// texuture color\n\tfloat screenAspect = u_resolution.x / u_resolution.y;\n\tfloat textureAspect = u_textureResolution.x / u_textureResolution.y;\n\tvec2 ratio = vec2(\n\t\tmin(screenAspect / textureAspect, 1.0),\n\t\tmin(textureAspect / screenAspect, 1.0)\n\t);\n\n\tvec2 adjustedUv = vUv * ratio + (1.0 - ratio) * 0.5;\n\tvec3 textureColor = texture2D(u_texture, adjustedUv).rgb;\n\tfloat textureAlpha = texture2D(u_texture, adjustedUv).a;\n\n\t// Based on https://mofu-dev.com/en/blog/three-dom-alignment/\n\tfloat maxSide = max(u_resolution.x, u_resolution.y);\n\tfloat minSide = min(u_resolution.x, u_resolution.y);\n\tvec2 aspect = u_resolution / maxSide;\n\tvec2 alphaUv = vUv - 0.5;\n\n\tfloat borderRadius = min(u_borderRadius, minSide * 0.5);\n\tvec2 offset = vec2(borderRadius) / u_resolution;\n\tvec2 alphaXY = smoothstep(vec2(0.5 - offset), vec2(0.5 - offset - 0.001), abs(alphaUv));\n\tfloat alpha = min(1.0, alphaXY.x + alphaXY.y);\n\n\tvec2 alphaUv2 = abs(vUv - 0.5);\n\tfloat radius = borderRadius / maxSide;\n\talphaUv2 = (alphaUv2 - 0.5) * aspect + radius;\n\tfloat roundAlpha = smoothstep(radius + 0.001, radius, length(alphaUv2));\n\n\talpha = min(1.0, alpha + roundAlpha);\n\n\t// multiply texture alpha\n\talpha *= textureAlpha;\n\n\tgl_FragColor = vec4(textureColor, alpha);\n}\n","import * as THREE from \"three\";\nimport { DomSyncerParams } from \"../\";\nimport { Size } from \"@react-three/fiber\";\nimport vertexShader from \"../shader/main.vert\";\nimport fragmentShader from \"../shader/main.frag\";\n\nexport class DomSyncerMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_textureResolution: { value: THREE.Vector2 };\n      u_resolution: { value: THREE.Vector2 };\n      u_borderRadius: { value: number };\n   };\n}\n\nexport const createMesh = ({\n   params,\n   size,\n   scene,\n}: {\n   params: DomSyncerParams;\n   size: Size;\n   scene: THREE.Scene;\n}) => {\n   if (scene.children.length > 0) {\n      scene.children.forEach((child) => {\n         if (child instanceof THREE.Mesh) {\n            child.geometry.dispose();\n            child.material.dispose();\n         }\n      });\n      scene.remove(...scene.children);\n   }\n\n   params.texture!.forEach((texture, i) => {\n      const mesh = new THREE.Mesh(\n         new THREE.PlaneGeometry(1, 1),\n         new THREE.ShaderMaterial({\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            transparent: true,\n            uniforms: {\n               u_texture: { value: texture },\n               u_textureResolution: {\n                  value: new THREE.Vector2(0, 0),\n               },\n               u_resolution: { value: new THREE.Vector2(0, 0) },\n               u_borderRadius: {\n                  value: params.boderRadius![i] ? params.boderRadius![i] : 0.0,\n               },\n            },\n         })\n      );\n      scene.add(mesh);\n   });\n};\n","import { useCallback, useRef } from \"react\";\nimport { DomSyncerParams } from \"..\";\n\nexport const useIntersectionHandler = () => {\n   const intersectionObserverRef = useRef<IntersectionObserver[]>([]);\n   const intersectionDomRef = useRef<(HTMLElement | Element | null)[]>([]);\n\n   const intersectionHandler = useCallback(\n      ({\n         isIntersectingRef,\n         isIntersectingOnceRef,\n         params,\n      }: {\n         isIntersectingRef: React.MutableRefObject<boolean[]>;\n         isIntersectingOnceRef: React.MutableRefObject<boolean[]>;\n         params: DomSyncerParams;\n      }) => {\n         if (intersectionObserverRef.current.length > 0) {\n            intersectionObserverRef.current.forEach((observer, i) => {\n               observer.unobserve(intersectionDomRef.current[i]!);\n            });\n         }\n\n         intersectionDomRef.current = [];\n         intersectionObserverRef.current = [];\n\n         const newArr = new Array(params.dom!.length).fill(false);\n         isIntersectingRef.current = [...newArr];\n         isIntersectingOnceRef.current = [...newArr];\n\n         params.dom!.forEach((dom, i) => {\n            const callback = (entries: IntersectionObserverEntry[]) => {\n               entries.forEach((entry) => {\n                  params.onIntersect![i] && params.onIntersect![i](entry);\n                  // Update the judgment after execution so that the judgment of isIntersectin can be used when executing onIntersect\n                  isIntersectingRef.current[i] = entry.isIntersecting;\n               });\n            };\n            const observer = new IntersectionObserver(callback, {\n               rootMargin: \"0px\",\n               threshold: 0,\n            });\n            observer.observe(dom!);\n            intersectionObserverRef.current.push(observer);\n            intersectionDomRef.current.push(dom!);\n         });\n      },\n      []\n   );\n\n   return intersectionHandler;\n};\n","import * as THREE from \"three\";\nimport { DomSyncerParams } from \"..\";\nimport { Size } from \"@react-three/fiber\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { DomSyncerMaterial } from \"./createMesh\";\nimport { useCallback, useRef } from \"react\";\n\ntype UpdateDomRect = ({\n   params,\n   size,\n   resolutionRef,\n   scene,\n   isIntersectingRef,\n}: {\n   params: DomSyncerParams;\n   size: Size;\n   resolutionRef: React.MutableRefObject<THREE.Vector2>;\n   scene: THREE.Scene;\n   isIntersectingRef: React.MutableRefObject<boolean[]>;\n}) => void;\n\ntype UseUpdateDomRectReturn = [DOMRect[], UpdateDomRect];\n\nexport const useUpdateDomRect = (): UseUpdateDomRectReturn => {\n   const domRects = useRef<DOMRect[]>([]);\n\n   const updateDomRects: UpdateDomRect = useCallback(\n      ({ params, size, resolutionRef, scene, isIntersectingRef }) => {\n         // Initialize domRects if the number of children in the scene is different from the number of DOMRect\n         if (scene.children.length !== domRects.current!.length) {\n            domRects.current = new Array(scene.children.length);\n         }\n\n         scene.children.forEach((mesh, i) => {\n            const domElement = params.dom![i];\n            if (!domElement) {\n               return;\n            }\n\n            // DOMRect is updated even outside the intersection\n            const rect = domElement.getBoundingClientRect();\n            domRects.current[i] = rect;\n\n            // Intersection cannot be determined accurately depending on the mobile navigation bar, so it seems better to update it constantly\n            mesh.scale.set(rect.width, rect.height, 1.0);\n            mesh.position.set(\n               rect.left + rect.width * 0.5 - size.width * 0.5,\n               -rect.top - rect.height * 0.5 + size.height * 0.5,\n               0.0\n            );\n\n            if (isIntersectingRef.current[i]) {\n               if (params.rotation![i]) {\n                  mesh.rotation.copy(params.rotation![i]);\n               }\n\n               if (mesh instanceof THREE.Mesh) {\n                  const material: DomSyncerMaterial = mesh.material;\n                  setUniform(material, \"u_texture\", params.texture![i]);\n                  setUniform(material, \"u_textureResolution\", [\n                     params.texture![i]?.source?.data?.width || 0,\n                     params.texture![i]?.source?.data?.height || 0,\n                  ]);\n                  setUniform(\n                     material,\n                     \"u_resolution\",\n                     resolutionRef.current.set(rect.width, rect.height)\n                  );\n                  setUniform(\n                     material,\n                     \"u_borderRadius\",\n                     params.boderRadius![i] ? params.boderRadius![i] : 0.0\n                  );\n               }\n            }\n         });\n      },\n      []\n   );\n\n   return [domRects.current, updateDomRects];\n};\n","import { useCallback, useRef } from \"react\";\n\nexport type IsIntersecting = (\n   index: number,\n   once?: boolean\n) => boolean[] | boolean;\n\nexport const useIsIntersecting = () => {\n   const isIntersectingRef = useRef<boolean[]>([]);\n   const isIntersectingOnceRef = useRef<boolean[]>([]);\n\n   const isIntersecting: IsIntersecting = useCallback((index, once = false) => {\n      isIntersectingRef.current.forEach((value, i) => {\n         if (value) {\n            isIntersectingOnceRef.current[i] = true;\n         }\n      });\n      const temp = once\n         ? [...isIntersectingOnceRef.current]\n         : [...isIntersectingRef.current];\n      return index < 0 ? temp : temp[index];\n   }, []);\n\n   return {\n      isIntersectingRef,\n      isIntersectingOnceRef,\n      isIntersecting,\n   };\n};\n","import { useEffect, useRef } from \"react\";\n\nexport type UseDomViewProps = {\n   onView?: () => void;\n   onHidden?: () => void;\n};\n\nexport type UseDomView = (props: UseDomViewProps) => void;\n\nexport const createUseDomView = (\n   isIntersectingRef: React.MutableRefObject<boolean[]>\n): UseDomView => {\n   const useDomView = ({ onView, onHidden }: UseDomViewProps) => {\n      const isView = useRef<boolean>(false);\n      useEffect(() => {\n         let id: number;\n         const filterIntersection = () => {\n            if (isIntersectingRef.current.some((item) => item)) {\n               if (!isView.current) {\n                  onView && onView();\n                  isView.current = true;\n               }\n            } else {\n               if (isView.current) {\n                  onHidden && onHidden();\n                  isView.current = false;\n               }\n            }\n            id = requestAnimationFrame(filterIntersection);\n         };\n         id = requestAnimationFrame(filterIntersection);\n         return () => {\n            cancelAnimationFrame(id);\n         };\n      }, [onView, onHidden]);\n   };\n   return useDomView;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo, useRef, useState, Key } from \"react\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { HooksProps, HooksReturn } from \"../../fxs/types\";\nimport { useParams } from \"../../utils/useParams\";\nimport { errorHandler } from \"./utils/errorHandler\";\nimport { createMesh } from \"./utils/createMesh\";\nimport { useIntersectionHandler } from \"./utils/useIntersectionHandler\";\nimport { useUpdateDomRect } from \"./utils/useUpdateDomRect\";\nimport { useIsIntersecting, IsIntersecting } from \"./utils/useIsIntersecting\";\nimport { UseDomView, createUseDomView } from \"./utils/createUseDomView\";\nimport { getDpr } from \"../../utils/getDpr\";\n\nexport type DomSyncerParams = {\n   /** DOM array you want to synchronize */\n   dom?: (HTMLElement | Element | null)[];\n   /** Texture array that you want to synchronize with the DOM rectangle */\n   texture?: THREE.Texture[];\n   /** default : `0.0[]` */\n   boderRadius?: number[];\n   /** the angle you want to rotate */\n   rotation?: THREE.Euler[];\n   /** Array of callback functions when crossed */\n   onIntersect?: ((entry: IntersectionObserverEntry) => void)[];\n   /** Because DOM rendering and React updates occur asynchronously, there may be a lag between updating dependent arrays and setting DOM arrays. That's what the Key is for. If the dependent array is updated but the Key is not, the loop will skip and return an empty texture. By updating the timing key when DOM acquisition is complete, you can perfectly synchronize DOM and Mesh updates.updateKey must be a unique value for each update, for example `performance.now()`.*/\n   updateKey?: Key;\n};\n\nexport type DomSyncerObject = {\n   scene: THREE.Scene;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n   /**\n    * A function that returns a determination whether the DOM intersects or not.\n    * The boolean will be updated after executing the onIntersect function.\n    * @param index - Index of the dom for which you want to return an intersection decision. -1 will return the entire array.\n    * @param once - If set to true, it will continue to return true once crossed.\n    */\n   isIntersecting: IsIntersecting;\n   /** target's DOMRect[] */\n   DOMRects: DOMRect[];\n   /** target's intersetions boolean[] */\n   intersections: boolean[];\n   /** You can set callbacks for when at least one DOM is visible and when it is completely hidden. */\n   useDomView: UseDomView;\n};\n\nexport const DOMSYNCER_PARAMS: DomSyncerParams = {\n   texture: [],\n   dom: [],\n   boderRadius: [],\n   rotation: [],\n   onIntersect: [],\n};\n\n/**\n * @link https://github.com/FunTechInc/use-shader-fx?tab=readme-ov-file#usedomsyncer\n * @param dependencies - When this dependency array is changed, the mesh and intersection judgment will be updated according to the passed DOM array.\n */\nexport const useDomSyncer = (\n   { size, dpr, samples = 0 }: HooksProps,\n   dependencies: React.DependencyList = []\n): HooksReturn<DomSyncerParams, DomSyncerObject> => {\n   const _dpr = getDpr(dpr);\n\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr: _dpr.fbo,\n      samples,\n      isSizeUpdate: true,\n   });\n   const [params, setParams] = useParams<DomSyncerParams>({\n      ...DOMSYNCER_PARAMS,\n      updateKey: performance.now(),\n   });\n\n   const [DOMRects, updateDomRects] = useUpdateDomRect();\n\n   // Avoid instancing vec2 every frame\n   const resolutionRef = useRef<THREE.Vector2>(new THREE.Vector2(0, 0));\n\n   // Update monitored doms according to the dependency array\n   const [refreshTrigger, setRefreshTrigger] = useState(true);\n   useMemo(\n      () => setRefreshTrigger(true),\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      dependencies\n   );\n\n   // If the dependencies have been updated but the key has not been updated, skip processing and return an empty texture\n   const updateKey = useRef<Key | null>(null);\n   const emptyTexture = useMemo(() => new THREE.Texture(), []);\n\n   // set intersection\n   const intersectionHandler = useIntersectionHandler();\n   const { isIntersectingOnceRef, isIntersectingRef, isIntersecting } =\n      useIsIntersecting();\n\n   // create useDomView\n   const useDomView = createUseDomView(isIntersectingRef);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: DomSyncerParams) => {\n         const { gl, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         if (errorHandler(params)) {\n            return emptyTexture;\n         }\n\n         if (refreshTrigger) {\n            if (updateKey.current === params.updateKey) {\n               return emptyTexture;\n            } else {\n               updateKey.current = params.updateKey!;\n            }\n         }\n\n         if (refreshTrigger) {\n            createMesh({\n               params,\n               size,\n               scene,\n            });\n\n            intersectionHandler({\n               isIntersectingRef,\n               isIntersectingOnceRef,\n               params,\n            });\n\n            setRefreshTrigger(false);\n         }\n\n         updateDomRects({\n            params,\n            size,\n            resolutionRef,\n            scene,\n            isIntersectingRef,\n         });\n\n         return updateRenderTarget(gl);\n      },\n      [\n         updateRenderTarget,\n         setParams,\n         intersectionHandler,\n         updateDomRects,\n         refreshTrigger,\n         scene,\n         params,\n         isIntersectingOnceRef,\n         isIntersectingRef,\n         emptyTexture,\n      ]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene,\n         camera,\n         renderTarget,\n         output: renderTarget.texture,\n         isIntersecting,\n         DOMRects,\n         intersections: isIntersectingRef.current,\n         useDomView,\n      },\n   ];\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { useResolution } from \"../utils/useResolution\";\nimport { UseFboProps, renderFBO, FBO_OPTION } from \"../utils/useSingleFBO\";\n\ntype UpdateCopyFunction = (\n   gl: THREE.WebGLRenderer,\n   index: number,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({ read }: { read: THREE.Texture }) => void\n) => THREE.Texture;\n\ntype UseCopyTextureReturn = [THREE.WebGLRenderTarget[], UpdateCopyFunction];\n\n/**\n * Generate an FBO array to copy the texture.\n * @param dpr If dpr is set, dpr will be multiplied, default : `false`\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default : `false`\n * @param length The number of FBOs to create\n * @returns [THREE.WebGLRenderTarget[] , updateCopyTexture] - Receives the RenderTarget array as the first argument and the update function as the second argument. `updateCopyTexture()` receives gl as the first argument and the index of the texture you want to copy as the second argument.\n */\nexport const useCopyTexture = (\n   {\n      scene,\n      camera,\n      size,\n      dpr = false,\n      isSizeUpdate = false,\n      samples = 0,\n      depthBuffer = false,\n      depthTexture = false,\n   }: UseFboProps,\n   length: number\n): UseCopyTextureReturn => {\n   const renderTargetArr = useRef<THREE.WebGLRenderTarget[]>([]);\n   const resolution = useResolution(size, dpr);\n\n   renderTargetArr.current = useMemo(() => {\n      return Array.from({ length }, () => {\n         const target = new THREE.WebGLRenderTarget(\n            resolution.x,\n            resolution.y,\n            {\n               ...FBO_OPTION,\n               samples,\n               depthBuffer,\n            }\n         );\n         if (depthTexture) {\n            target.depthTexture = new THREE.DepthTexture(\n               resolution.x,\n               resolution.y,\n               THREE.FloatType\n            );\n         }\n         return target;\n      });\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, [length]);\n\n   if (isSizeUpdate) {\n      renderTargetArr.current.forEach((fbo) =>\n         fbo.setSize(resolution.x, resolution.y)\n      );\n   }\n\n   useEffect(() => {\n      const temp = renderTargetArr.current;\n      return () => {\n         temp.forEach((fbo) => fbo.dispose());\n      };\n   }, [length]);\n\n   const updateCopyTexture: UpdateCopyFunction = useCallback(\n      (gl, index, onBeforeRender) => {\n         const fbo = renderTargetArr.current[index];\n         renderFBO({\n            gl,\n            scene,\n            camera,\n            fbo,\n            onBeforeRender: () =>\n               onBeforeRender && onBeforeRender({ read: fbo.texture }),\n         });\n         return fbo.texture;\n      },\n      [scene, camera]\n   );\n\n   return [renderTargetArr.current, updateCopyTexture];\n};\n"],"names":["main_default","useResolution","size","dpr","_width","_height","useMemo","THREE","setUniform","material","key","value","useAddObject","scene","geometry","Proto","object3D","obj","useEffect","useMesh","vertexShader","fragmentShader","resolution","mesh","getCameraProps","width","height","frustumSize","aspect","w","h","useCamera","cameraType","near","far","usePointer","lerp","prevPointer","useRef","diffPointer","lerpPointer","lastUpdateTime","velocity","isMoved","useCallback","currentPointer","now","current","deltaTime","isUpdate","prevTemp","useParams","params","isContainsFunctions","paramsRef","setParams","updateParams","paramKey","FBO_OPTION","renderFBO","gl","fbo","camera","onBeforeRender","onSwap","useSingleFBO","isSizeUpdate","samples","depthBuffer","depthTexture","renderTarget","target","_a","temp","updateRenderTarget","useDoubleFBO","initRenderTargets","read","write","_b","getDpr","BRUSH_PARAMS","useBrush","_dpr","updatePointer","pressureEnd","props","pointer","pointerValues","color","init_default","useInitialMaterial","advection_default","useAdvectionMaterial","divergence_default","useDivergenceMaterial","pressure_default","usePressureMaterial","curl_default","useCurlMaterial","vorticity_default","useVorticityMaterial","clear_default","useClearMaterial","gradientSubtract_default","useGradientSubtractMaterial","splat_default","useSplateMaterial","initialMaterial","updateMaterial","curlMaterial","vorticityMaterial","advectionMaterial","divergenceMaterial","pressureMaterial","clearMaterial","gradientSubtractMaterial","splatMaterial","materials","setMeshMaterial","FLUID_PARAMS","useFluid","fboProps","velocityFBO","updateVelocityFBO","densityFBO","updateDensityFBO","curlFBO","updateCurlFBO","divergenceFBO","updateDivergenceFBO","pressureFBO","updatePressureFBO","lastTime","scaledDiffVec","spaltVec","clock","dt","velocityTex","densityTex","scaledDiff","curlTex","divergenceTex","pressureTexTemp","i","scale","max","texture","meshArr","RIPPLE_PARAMS","useRipple","currentWave","NOISE_PARAMS","useNoise","COLORSTRATA_PARAMS","useColorStrata","MARBLE_PARAMS","useMarble","COSPALETTE_PARAMS","useCosPalette","DUOTONE_PARAMS","useDuoTone","BLENDING_PARAMS","useBlending","FXTEXTURE_PARAMS","useFxTexture","tex0Res","_d","_c","tex1Res","_f","_e","_h","_g","interpolatedResolution","index","BRIGHTNESSPICKER_PARAMS","useBrightnessPicker","FXBLENDING_PARAMS","useFxBlending","ALPHABLENDING_PARAMS","useAlphaBlending","HSV_PARAMS","useHSV","COVERTEXTURE_PARAMS","useCoverTexture","SIMPLEBLUR_PARAMS","useSimpleBlur","_","updateTempTexture","_tempTexture","iterations","WAVE_PARAMS","useWave","CHROMAKEY_PARAMS","useChromaKey","useCreateObject","points","interactiveMesh","getWobble_default","ISDEV","rewriteVertexShader","modifeidAttributes","targetGeometry","targetAttibute","itemSize","vTargetName","vAttributeRewriteKey","vTransitionRewriteKey","vListName","vMorphTransition","stringToAddToMorphAttibutes","stringToAddToMorphAttibutesList","modifyAttributes","attribute","modifiedAttribute","maxLength","arr","diff","addArray","oldArray","randomIndex","j","rewriteFragmentShader","mapArray","mapArrayShader","mapArrayUniforms","textureSwitcherCode","map","condition","action","useMaterial","positions","uvs","modifiedPositions","modifiedUvs","rewritedVertexShader","getWobble","mapArraySwitch","MORPHPARTICLES_PARAMS","useCreateMorphParticles","morphGeometry","geo","useMorphParticles","updateUniform","generatedPositions","generatedUvs","updateFx","mergeVertices","tolerance","hashToIndex","indices","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","getters","l","name","morphAttr","decimalShift","shiftMultiplier","hash","k","newarray","newMorphArrays","getterFunc","m","ml","result","oldAttribute","buffer","BufferAttribute","oldMorphAttribute","buffer2","morphAttribute","snoise_default","transmission_pars_fragment_default","transmission_fragment_default","rewriteVertex","vertex","shader","baseMaterial","materialParameters","depthMaterial","mat","hasRoughness","hasTransmission","WOBBLE3D_PARAMS","snoise","transmission_pars_fragment","transmission_fragment","depthMat","useCreateWobble3D","wobbleGeometry","userData","useWobble3D","useAddMesh","Easing","x","c2","c4","c5","getHash","input","n","useBeat","bpm","ease","rhythm","easing","beat","floor","fract","useFPSLimiter","fps","interval","prevTime","tick","errorHandler","domLength","textureLength","createMesh","child","useIntersectionHandler","intersectionObserverRef","intersectionDomRef","isIntersectingRef","isIntersectingOnceRef","observer","newArr","dom","callback","entries","entry","useUpdateDomRect","domRects","updateDomRects","resolutionRef","domElement","rect","useIsIntersecting","isIntersecting","once","createUseDomView","onView","onHidden","isView","id","filterIntersection","item","DOMSYNCER_PARAMS","useDomSyncer","dependencies","DOMRects","refreshTrigger","setRefreshTrigger","useState","updateKey","emptyTexture","intersectionHandler","useDomView","useCopyTexture","length","renderTargetArr","updateCopyTexture"],"mappings":"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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAAA,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAAuM,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QCAAC,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QCiCA,MAAMC,G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","x_google_ignoreList":[107]}