{"version":3,"file":"use-shader-fx.umd.cjs","sources":["../src/hooks/useBrush/shader/main.vert","../src/hooks/useBrush/shader/main.frag","../src/utils/useResolution.ts","../src/utils/useAddMesh.ts","../src/utils/setUniforms.ts","../src/hooks/useBrush/useMesh.ts","../src/utils/useCamera.ts","../src/utils/useSingleFBO.ts","../src/utils/useDoubleFBO.ts","../src/utils/usePointer.ts","../src/utils/useParams.ts","../src/hooks/useBrush/index.ts","../src/hooks/useDuoTone/shader/main.vert","../src/hooks/useDuoTone/shader/main.frag","../src/hooks/useDuoTone/useMesh.ts","../src/hooks/useDuoTone/index.ts","../src/hooks/useFogProjection/shader/main.vert","../src/hooks/useFogProjection/shader/main.frag","../src/hooks/useFogProjection/useMesh.ts","../src/hooks/useFogProjection/index.ts","../src/hooks/useFluid/shaders/main.vert","../src/hooks/useFluid/shaders/init.frag","../src/hooks/useFluid/materials/useInitialMaterial.ts","../src/hooks/useFluid/shaders/advection.frag","../src/hooks/useFluid/materials/useAdvectionMaterial.ts","../src/hooks/useFluid/shaders/divergence.frag","../src/hooks/useFluid/materials/useDivergenceMaterial.ts","../src/hooks/useFluid/shaders/pressure.frag","../src/hooks/useFluid/materials/usePressureMaterial.ts","../src/hooks/useFluid/shaders/curl.frag","../src/hooks/useFluid/materials/useCurlMaterial.ts","../src/hooks/useFluid/shaders/vorticity.frag","../src/hooks/useFluid/materials/useVorticityMaterial.ts","../src/hooks/useFluid/shaders/clear.frag","../src/hooks/useFluid/materials/useClearMaterial.ts","../src/hooks/useFluid/shaders/gradientSubtract.frag","../src/hooks/useFluid/materials/useGradientSubtractMaterial.ts","../src/hooks/useFluid/shaders/splat.frag","../src/hooks/useFluid/materials/useSplatMaterial.ts","../src/hooks/useFluid/useMesh.ts","../src/hooks/useFluid/index.ts","../src/hooks/useRipple/useMesh.ts","../src/hooks/useRipple/index.ts","../src/hooks/useFxTexture/shader/main.vert","../src/hooks/useFxTexture/shader/main.frag","../src/hooks/useFxTexture/useMesh.ts","../src/hooks/useFxTexture/index.ts","../src/hooks/useNoise/shader/main.vert","../src/hooks/useNoise/shader/main.frag","../src/hooks/useNoise/useMesh.ts","../src/hooks/useNoise/index.ts","../src/hooks/useDomSyncer/utils/errorHandler.ts","../src/hooks/useDomSyncer/shader/main.vert","../src/hooks/useDomSyncer/shader/main.frag","../src/hooks/useDomSyncer/utils/createMesh.ts","../src/hooks/useDomSyncer/utils/useIntersectionHandler.ts","../src/hooks/useDomSyncer/utils/updateRect.ts","../src/hooks/useDomSyncer/utils/useIsIntersecting.ts","../src/hooks/useDomSyncer/index.ts","../src/hooks/useSimpleBlur/shader/main.vert","../src/hooks/useSimpleBlur/shader/main.frag","../src/hooks/useSimpleBlur/useMesh.ts","../src/hooks/useSimpleBlur/index.ts","../src/hooks/useWave/shader/main.vert","../src/hooks/useWave/shader/main.frag","../src/hooks/useWave/useMesh.ts","../src/hooks/useWave/index.ts","../src/utils/useCopyTexture.ts"],"sourcesContent":["varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nuniform sampler2D uMap;\nuniform sampler2D uTexture;\nuniform float uRadius;\nuniform float uDissipation;\nuniform vec2 uResolution;\nuniform float uSmudge;\nuniform float uAspect;\nuniform vec2 uMouse;\nuniform vec2 uPrevMouse;\nuniform vec2 uVelocity;\nuniform vec3 uColor;\nuniform float uMotionBlur;\nuniform int uMotionSample;\n\nvarying vec2 vUv;\n\nfloat isOnLine(vec2 point, vec2 start, vec2 end, float width, float aspect) {\n\t// make circle\n\tpoint.x *= aspect;\n\tstart.x *= aspect;\n\tend.x *= aspect;\n\n\t// unit vector in direction\n\tvec2 dir = normalize(end - start);\n\t\n\t// unit vector perpendicular to the line segment\n\tvec2 n = vec2(dir.y, -dir.x);\n\n\tvec2 p0 = point - start;\n\t\n\t// calculate distance on a line\n\tfloat distToLine = abs(dot(p0, n));\n\tfloat distAlongLine = dot(p0, dir);\n\tfloat totalLength = length(end - start);\n\n\t// Include the radius of the circle at the start and end points in the range\n\tfloat distFromStart = length(point - start);\n\tfloat distFromEnd = length(point - end);\n\t\n\tbool withinLine = (distToLine < width && distAlongLine > 0.0 && distAlongLine < totalLength) || distFromStart < width || distFromEnd < width;\n\n\treturn float(withinLine);\n}\n\nvec4 createSmudge(){\n\tvec2 offsets[9];\n\toffsets[0] = vec2(-1, -1); offsets[1] = vec2( 0, -1); offsets[2] = vec2( 1, -1);\n\toffsets[3] = vec2(-1,  0); offsets[4] = vec2( 0,  0); offsets[5] = vec2( 1,  0);\n\toffsets[6] = vec2(-1,  1); offsets[7] = vec2( 0,  1); offsets[8] = vec2( 1,  1);\n\t// Scale offset to texture size\n\tfor(int i = 0; i < 9; i++) {\n\t\toffsets[i] = (offsets[i] * uSmudge) / uResolution;\n\t}\t\n\tvec4 smudgedColor = vec4(0.0);\n\tfor(int i = 0; i < 9; i++) {\n\t\tsmudgedColor += texture2D(uMap, vUv + offsets[i]);\n\t}\n\treturn smudgedColor / 9.0;\n}\n\nvec4 createMotionBlur(vec4 baseColor, vec2 velocity, float motion, int samples) {\n\tvec4 motionBlurredColor = baseColor;\n\tvec2 scaledVelocity = velocity * motion;\n\tfor(int i = 1; i < samples; i++) {\n\t\tfloat t = float(i) / float(samples - 1);\n\t\tvec2 offset = t * scaledVelocity / uResolution;\n\t\tmotionBlurredColor += texture2D(uMap, vUv + offset);\n\t}\n\treturn motionBlurredColor / float(samples);\n}\n\n\nvoid main() {\n\t// Convert UV coordinates to range [-1, 1]\n\tvec2 st = vUv * 2.0 - 1.0;\n\t\n\t// velocity vector\n\tvec2 velocity = uVelocity * uResolution;\n\n\t// add smudge\n\tvec4 smudgedColor = createSmudge();\n\t\n\t// add motion blur\n\tvec4 motionBlurredColor = createMotionBlur(smudgedColor, velocity, uMotionBlur,uMotionSample);\n\n\tvec4 bufferColor = motionBlurredColor * uDissipation;\n\n\t// radius\n\tfloat modifiedRadius = max(0.0,uRadius);\n\n\t//\tcolor \n\tvec3 color = uColor;\n\n\t// map texture to color\n\tvec4 textureColor = texture2D(uTexture, vUv);\n\tvec3 finalColor = mix(color, textureColor.rgb, textureColor.a);\n\n\tfloat onLine = isOnLine(st, uPrevMouse, uMouse, modifiedRadius, uAspect);\n\tbufferColor.rgb = mix(bufferColor.rgb, finalColor, onLine);\n\t\n\tgl_FragColor = vec4(bufferColor.rgb,1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\n/**\n * @params dpr if dpr is set, it returns the resolution which is size multiplied by dpr.\n */\nexport const useResolution = (size: Size, dpr: number | false = false) => {\n   const _width = dpr ? size.width * dpr : size.width;\n   const _height = dpr ? size.height * dpr : size.height;\n   const resolution = useMemo(\n      () => new THREE.Vector2(_width, _height),\n      [_width, _height]\n   );\n   return resolution;\n};\n","import * as THREE from \"three\";\nimport { useEffect, useMemo } from \"react\";\n\n/** Generate mesh from geometry and material and add to scene */\nexport const useAddMesh = (\n   scene: THREE.Scene,\n   geometry: THREE.BufferGeometry,\n   material: THREE.Material\n) => {\n   const mesh = useMemo(\n      () => new THREE.Mesh(geometry, material),\n      [geometry, material]\n   );\n\n   useEffect(() => {\n      scene.add(mesh);\n   }, [scene, mesh]);\n\n   useEffect(() => {\n      return () => {\n         scene.remove(mesh);\n         geometry.dispose();\n         material.dispose();\n      };\n   }, [scene, geometry, material, mesh]);\n\n   return mesh;\n};\n","type UniformValue =\n   | THREE.CubeTexture\n   | THREE.Texture\n   | Int32Array\n   | Float32Array\n   | THREE.Matrix4\n   | THREE.Matrix3\n   | THREE.Quaternion\n   | THREE.Vector4\n   | THREE.Vector3\n   | THREE.Vector2\n   | THREE.Color\n   | number\n   | boolean\n   | Array<any>\n   | null;\ntype UniformObject = { [key: string]: { value: UniformValue } };\n\nexport const setUniform = <T extends UniformObject>(\n   material: { uniforms: T },\n   key: keyof T,\n   value: UniformValue\n) => {\n   if (\n      material.uniforms &&\n      material.uniforms[key] &&\n      value !== undefined &&\n      value !== null\n   ) {\n      material.uniforms[key].value = value;\n   } else {\n      console.error(\n         `Uniform key \"${String(\n            key\n         )}\" does not exist in the material. or \"${String(\n            key\n         )}\" is null | undefined`\n      );\n   }\n};\n","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useEffect, useMemo } from \"react\";\nimport { useResolution } from \"../../utils/useResolution\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\nexport class BrushMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uMap: { value: THREE.Texture };\n      uResolution: { value: THREE.Texture };\n      uAspect: { value: number };\n      uTexture: { value: THREE.Texture };\n      uRadius: { value: number };\n      uSmudge: { value: number };\n      uDissipation: { value: number };\n      uMotionBlur: { value: number };\n      uMotionSample: { value: number };\n      uMouse: { value: number };\n      uPrevMouse: { value: number };\n      uVelocity: { value: number };\n      uColor: { value: THREE.Color };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uMap: { value: new THREE.Texture() },\n               uResolution: { value: new THREE.Vector2(0, 0) },\n               uAspect: { value: 0.0 },\n               uTexture: { value: new THREE.Texture() },\n               uRadius: { value: 0.0 },\n               uSmudge: { value: 0.0 },\n               uDissipation: { value: 0.0 },\n               uMotionBlur: { value: 0.0 },\n               uMotionSample: { value: 0 },\n               uMouse: { value: new THREE.Vector2(0, 0) },\n               uPrevMouse: { value: new THREE.Vector2(0, 0) },\n               uVelocity: { value: new THREE.Vector2(0, 0) },\n               uColor: { value: new THREE.Color(0xffffff) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(material, \"uAspect\", resolution.width / resolution.height);\n      setUniform(material, \"uResolution\", resolution.clone());\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material as BrushMaterial;\n};\n","import * as THREE from \"three\";\nimport { useResolution } from \"./useResolution\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\nconst getCameraProps = (width: number, height: number) => {\n   const frustumSize = height;\n   const aspect = width / height;\n   const [w, h] = [(frustumSize * aspect) / 2, frustumSize / 2];\n   return { width: w, height: h, near: -1000, far: 1000 };\n};\n\nexport const useCamera = (size: Size) => {\n   const resolution = useResolution(size);\n   const { width, height, near, far } = getCameraProps(\n      resolution.x,\n      resolution.y\n   );\n   const camera = useMemo(\n      () =>\n         new THREE.OrthographicCamera(\n            -width,\n            width,\n            height,\n            -height,\n            near,\n            far\n         ),\n      [width, height, near, far]\n   );\n   return camera;\n};\n","import * as THREE from \"three\";\nimport {\n   useCallback,\n   useEffect,\n   useLayoutEffect,\n   useMemo,\n   useRef,\n} from \"react\";\nimport { useResolution } from \"./useResolution\";\nimport { UseFboProps } from \"./types\";\n\nexport const FBO_OPTION = {\n   minFilter: THREE.LinearFilter,\n   magFilter: THREE.LinearFilter,\n   type: THREE.HalfFloatType,\n   depthBuffer: false,\n   stencilBuffer: false,\n};\n\ntype FBOUpdateFunction = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({ read }: { read: THREE.Texture }) => void\n) => THREE.Texture;\n\ntype UseSingleFBOReturn = [THREE.WebGLRenderTarget, FBOUpdateFunction];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [THREE.WebGLRenderTarget , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useSingleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n}: UseFboProps): UseSingleFBOReturn => {\n   const renderTarget = useRef<THREE.WebGLRenderTarget>();\n\n   const resolution = useResolution(size, dpr);\n   renderTarget.current = useMemo(\n      () => new THREE.WebGLRenderTarget(resolution.x, resolution.y, FBO_OPTION),\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      []\n   );\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current?.setSize(resolution.x, resolution.y);\n      }\n   }, [resolution, isSizeUpdate]);\n\n   useEffect(() => {\n      const currentRenderTarget = renderTarget.current;\n      return () => {\n         currentRenderTarget?.dispose();\n      };\n   }, []);\n\n   const updateRenderTarget: FBOUpdateFunction = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current!;\n         gl.setRenderTarget(fbo);\n         onBeforeRender && onBeforeRender({ read: fbo.texture });\n         gl.render(scene, camera);\n         gl.setRenderTarget(null);\n         gl.clear();\n         return fbo.texture;\n      },\n      [scene, camera]\n   );\n\n   return [renderTarget.current, updateRenderTarget];\n};\n","import * as THREE from \"three\";\nimport {\n   useCallback,\n   useEffect,\n   useLayoutEffect,\n   useMemo,\n   useRef,\n} from \"react\";\nimport { FBO_OPTION } from \"./useSingleFBO\";\nimport { useResolution } from \"./useResolution\";\nimport { DoubleRenderTarget, UseFboProps } from \"./types\";\n\ninterface RenderTarget extends DoubleRenderTarget {\n   swap: () => void;\n}\n\ntype FBOUpdateFunction = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({\n      read,\n      write,\n   }: {\n      read: THREE.Texture;\n      write: THREE.Texture;\n   }) => void\n) => THREE.Texture;\n\ntype UseDoubleFBOReturn = [\n   { read: THREE.WebGLRenderTarget; write: THREE.WebGLRenderTarget },\n   FBOUpdateFunction\n];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [{read:THREE.WebGLRenderTarget,write:THREE.WebGLRenderTarget} , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useDoubleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n}: UseFboProps): UseDoubleFBOReturn => {\n   const renderTarget = useRef<RenderTarget>({\n      read: null,\n      write: null,\n      swap: function () {\n         let temp = this.read;\n         this.read = this.write;\n         this.write = temp;\n      },\n   });\n\n   const resolution = useResolution(size, dpr);\n   const initRenderTargets = useMemo(() => {\n      const read = new THREE.WebGLRenderTarget(\n         resolution.x,\n         resolution.y,\n         FBO_OPTION\n      );\n      const write = new THREE.WebGLRenderTarget(\n         resolution.x,\n         resolution.y,\n         FBO_OPTION\n      );\n      return { read, write };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, []);\n   renderTarget.current.read = initRenderTargets.read;\n   renderTarget.current.write = initRenderTargets.write;\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current.read?.setSize(resolution.x, resolution.y);\n         renderTarget.current.write?.setSize(resolution.x, resolution.y);\n      }\n   }, [resolution, isSizeUpdate]);\n\n   useEffect(() => {\n      const currentRenderTarget = renderTarget.current;\n      return () => {\n         currentRenderTarget.read?.dispose();\n         currentRenderTarget.write?.dispose();\n      };\n   }, []);\n\n   const updateRenderTarget: FBOUpdateFunction = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current;\n         gl.setRenderTarget(fbo.write);\n         onBeforeRender &&\n            onBeforeRender({\n               read: fbo.read!.texture,\n               write: fbo.write!.texture,\n            });\n         gl.render(scene, camera);\n         fbo.swap();\n         gl.setRenderTarget(null);\n         gl.clear();\n         return fbo.read?.texture as THREE.Texture;\n      },\n      [scene, camera]\n   );\n\n   return [\n      { read: renderTarget.current.read, write: renderTarget.current.write },\n      updateRenderTarget,\n   ];\n};\n","import * as THREE from \"three\";\nimport { useCallback, useRef } from \"react\";\n\ntype UpdatePointer = (currentPointer: THREE.Vector2) => {\n   currentPointer: THREE.Vector2;\n   prevPointer: THREE.Vector2;\n   diffPointer: THREE.Vector2;\n   velocity: THREE.Vector2;\n   isVelocityUpdate: boolean;\n};\n\n/** When given the pointer vector2 from r3f's RootState, it generates an update function that returns {currentPointer, prevPointer, diffPointer, isVelocityUpdate, velocity}. */\nexport const usePointer = (): UpdatePointer => {\n   const prevPointer = useRef(new THREE.Vector2(0, 0));\n   const diffPointer = useRef(new THREE.Vector2(0, 0));\n   const lastUpdateTime = useRef<number>(0);\n   const velocity = useRef(new THREE.Vector2(0, 0));\n   const isMoved = useRef(false);\n\n   const updatePointer = useCallback((currentPointer: THREE.Vector2) => {\n      const now = performance.now();\n      const current = currentPointer.clone();\n\n      // first frame\n      if (lastUpdateTime.current === 0) {\n         lastUpdateTime.current = now;\n         prevPointer.current = current;\n      }\n      const deltaTime = Math.max(1, now - lastUpdateTime.current);\n      lastUpdateTime.current = now;\n\n      // get velocity\n      velocity.current\n         .copy(current)\n         .sub(prevPointer.current)\n         .divideScalar(deltaTime);\n      const isUpdate = velocity.current.length() > 0;\n\n      //set prev temp pos\n      const prevTemp = isMoved.current ? prevPointer.current.clone() : current;\n      if (!isMoved.current && isUpdate) {\n         isMoved.current = true;\n      }\n      prevPointer.current = current;\n\n      return {\n         currentPointer: current,\n         prevPointer: prevTemp,\n         diffPointer: diffPointer.current.subVectors(current, prevTemp),\n         velocity: velocity.current,\n         isVelocityUpdate: isUpdate,\n      };\n   }, []);\n\n   return updatePointer;\n};\n","import { useCallback, useRef } from \"react\";\n\ntype UseParamsReturn<T> = [T, (params: Partial<T>) => void];\n\n/**\n * @param params Receives an initial value object. With structuredClone, deep copy and set, but if the object contains a function, just set it.\n */\nexport const useParams = <T extends object>(params: T): UseParamsReturn<T> => {\n   const isContainsFunctions = (obj: object): boolean =>\n      Object.values(obj).some((value) => typeof value === \"function\");\n   const paramsRef = useRef(\n      isContainsFunctions(params) ? params : structuredClone(params)\n   );\n\n   const setParams = useCallback((updateParams: Partial<T>) => {\n      for (const key in updateParams) {\n         const paramKey = key as keyof T;\n         if (\n            paramKey in paramsRef.current &&\n            updateParams[paramKey] !== undefined &&\n            updateParams[paramKey] !== null\n         ) {\n            paramsRef.current[paramKey] = updateParams[paramKey]!;\n         } else {\n            console.error(\n               `\"${String(\n                  paramKey\n               )}\" does not exist in the params. or \"${String(\n                  paramKey\n               )}\" is null | undefined`\n            );\n         }\n      }\n   }, []);\n   return [paramsRef.current, setParams];\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { useDoubleFBO } from \"../../utils/useDoubleFBO\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { usePointer } from \"../../utils/usePointer\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\nimport { DoubleRenderTarget } from \"../../utils/types\";\n\nexport type BrushParams = {\n   /** Texture applied to the brush.Mixed with the value of a , default:THREE.Texture() */\n   texture?: THREE.Texture;\n   /** size of the stamp, percentage of the size ,default:0.05 */\n   radius?: number;\n   /** Strength of smudge effect , default:0.0*/\n   smudge?: number;\n   /** dissipation rate. If set to 1, it will remain. ,default:1.0 */\n   dissipation?: number;\n   /** Strength of motion blur , default:0.0 */\n   motionBlur?: number;\n   /** Number of motion blur samples. Affects performance default: 5 */\n   motionSample?: number;\n   /** brush color , default:THREE.Color(0xffffff) */\n   color?: THREE.Color;\n};\n\nexport type BrushObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: DoubleRenderTarget;\n};\n\nexport const BRUSH_PARAMS: BrushParams = {\n   texture: new THREE.Texture(),\n   radius: 0.05,\n   smudge: 0.0,\n   dissipation: 1.0,\n   motionBlur: 0.0,\n   motionSample: 5,\n   color: new THREE.Color(0xffffff),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useBrush = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<BrushParams, BrushObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useDoubleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n   });\n\n   const [params, setParams] = useParams<BrushParams>(BRUSH_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: BrushParams) => {\n         const { gl, pointer } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uRadius\", params.radius!);\n         setUniform(material, \"uSmudge\", params.smudge!);\n         setUniform(material, \"uDissipation\", params.dissipation!);\n         setUniform(material, \"uMotionBlur\", params.motionBlur!);\n         setUniform(material, \"uMotionSample\", params.motionSample!);\n         setUniform(material, \"uColor\", params.color!);\n\n         const { currentPointer, prevPointer, velocity } =\n            updatePointer(pointer);\n         setUniform(material, \"uMouse\", currentPointer);\n         setUniform(material, \"uPrevMouse\", prevPointer);\n         setUniform(material, \"uVelocity\", velocity);\n\n         const bufferTexture = updateRenderTarget(gl, ({ read }) => {\n            setUniform(material, \"uMap\", read);\n         });\n\n         return bufferTexture;\n      },\n      [material, updatePointer, updateRenderTarget, params, setParams]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\n\nuniform vec3 uColor0;\nuniform vec3 uColor1;\n\nvoid main() {\n\tvec2 uv = vUv;\n\tvec4 texColor = texture2D(uTexture, uv);\n\tfloat grayscale = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n\tvec3 duotone = mix(uColor0, uColor1, grayscale);\n\tgl_FragColor = vec4(duotone, texColor.a);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\n\nexport class DuoToneMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      uColor0: { value: THREE.Color };\n      uColor1: { value: THREE.Color };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uColor0: { value: new THREE.Color(0xffffff) },\n               uColor1: { value: new THREE.Color(0x000000) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as DuoToneMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { DuoToneMaterial, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\n\nexport type DuoToneParams = {\n   /** Make this texture duotone , Default:new THREE.Texture() */\n   texture?: THREE.Texture;\n   /** 1st color ,ã€€Default:new THREE.Color(0xffffff) */\n   color0?: THREE.Color;\n   /** 2nd color , Default: new THREE.Color(0x000000) */\n   color1?: THREE.Color;\n};\n\nexport type DuoToneObject = {\n   scene: THREE.Scene;\n   material: DuoToneMaterial;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const DUOTONE_PARAMS: DuoToneParams = {\n   texture: new THREE.Texture(),\n   color0: new THREE.Color(0xffffff),\n   color1: new THREE.Color(0x000000),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useDuoTone = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<DuoToneParams, DuoToneObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n   });\n\n   const [params, setParams] = useParams<DuoToneParams>(DUOTONE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: DuoToneParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uColor0\", params.color0!);\n         setUniform(material, \"uColor1\", params.color1!);\n\n         const bufferTexture = updateRenderTarget(gl);\n\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform float uTime;\nuniform sampler2D uTexture;\nuniform sampler2D uNoiseMap;\nuniform float distortionStrength;\nuniform float fogEdge0;\nuniform float fogEdge1;\nuniform vec3 fogColor;\n\nvoid main() {\n\tvec2 uv = vUv;\n\n\tfloat noiseMap = texture2D(uNoiseMap,uv).r;\n\t\n\tfloat noiseTextureMap = noiseMap*2.0-1.0;\n\tuv += noiseTextureMap * distortionStrength;\n\tvec3 textureMap = texture2D(uTexture, uv).rgb;\n\n\tfloat edge0 = fogEdge0;\n\tfloat edge1 = fogEdge1;\n\tfloat blendValue = smoothstep(edge0, edge1, noiseMap);\n\n\tvec3 outputColor = blendValue * fogColor + (1.0 - blendValue) * textureMap;\n\tgl_FragColor = vec4(outputColor, 1.0);\n}\n\n\n","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\n\nexport class FogProjectionMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTime: { value: number };\n      uTexture: { value: THREE.Texture };\n      uNoiseMap: { value: THREE.Texture };\n      distortionStrength: { value: number };\n      fogEdge0: { value: number };\n      fogEdge1: { value: number };\n      fogColor: { value: THREE.Color };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTime: { value: 0.0 },\n               uTexture: { value: new THREE.Texture() },\n               uNoiseMap: { value: new THREE.Texture() },\n               distortionStrength: { value: 0.0 },\n               fogEdge0: { value: 0.0 },\n               fogEdge1: { value: 0.9 },\n               fogColor: { value: new THREE.Color(0xffffff) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as FogProjectionMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\n\nexport type FogProjectionParams = {\n   /** Make this texture FogProjection , default:THREE.Texture */\n   texture?: THREE.Texture;\n   /** noise texture to map, default:THREE.Texture */\n   noiseMap?: THREE.Texture;\n   /** distortion strength , default:0.03 */\n   distortionStrength?: number;\n   /** value that reflects noise , default:0.0 */\n   fogEdge0?: number;\n   /** value that reflects noise , default:0.9  */\n   fogEdge1?: number;\n   /** fog color , default: THREE.Color(0xffffff) */\n   fogColor?: THREE.Color;\n};\n\nexport type FogProjectionObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const FOGPROJECTION_PARAMS: FogProjectionParams = {\n   texture: new THREE.Texture(),\n   noiseMap: new THREE.Texture(),\n   distortionStrength: 0.03,\n   fogEdge0: 0.0,\n   fogEdge1: 0.9,\n   fogColor: new THREE.Color(0xffffff),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useFogProjection = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<FogProjectionParams, FogProjectionObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n   });\n\n   const [params, setParams] =\n      useParams<FogProjectionParams>(FOGPROJECTION_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FogProjectionParams) => {\n         const { gl, clock } = props;\n         updateParams && setParams(updateParams);\n         setUniform(material, \"uTime\", clock.getElapsedTime());\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uNoiseMap\", params.noiseMap!);\n         setUniform(material, \"distortionStrength\", params.distortionStrength!);\n         setUniform(material, \"fogEdge0\", params.fogEdge0!);\n         setUniform(material, \"fogEdge1\", params.fogEdge1!);\n         setUniform(material, \"fogColor\", params.fogColor!);\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform vec2 texelSize;\n\nvoid main () {\n\tvUv = uv;\n\tvL = vUv - vec2(texelSize.x, 0.0);\n\tvR = vUv + vec2(texelSize.x, 0.0);\n\tvT = vUv + vec2(0.0, texelSize.y);\n\tvB = vUv - vec2(0.0, texelSize.y);\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvoid main(){\n\tgl_FragColor = vec4(0.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/init.frag\";\n\nexport const useInitialMaterial = () => {\n   const initialMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      []\n   );\n\n   return initialMaterial as THREE.ShaderMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D uVelocity;\nuniform sampler2D uSource;\nuniform vec2 texelSize;\nuniform float dt;\nuniform float dissipation;\n\nvoid main () {\n\tvec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n\tgl_FragColor = dissipation * texture2D(uSource, coord);\n\tgl_FragColor.a = 1.0;\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/advection.frag\";\n\nexport class AdvectionMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uVelocity: { value: THREE.Texture };\n      uSource: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n      dt: { value: number };\n      dissipation: { value: number };\n   };\n}\n\nexport const useAdvectionMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: new THREE.Texture() },\n               uSource: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n               dt: { value: 0.0 },\n               dissipation: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as AdvectionMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvec2 sampleVelocity (in vec2 uv) {\n\tvec2 multiplier = vec2(1.0, 1.0);\n\tif (uv.x < 0.0) { uv.x = 0.0; multiplier.x = -1.0; }\n\tif (uv.x > 1.0) { uv.x = 1.0; multiplier.x = -1.0; }\n\tif (uv.y < 0.0) { uv.y = 0.0; multiplier.y = -1.0; }\n\tif (uv.y > 1.0) { uv.y = 1.0; multiplier.y = -1.0; }\n\treturn multiplier * texture2D(uVelocity, uv).xy;\n}\n\nvoid main () {\n\tfloat L = sampleVelocity(vL).x;\n\tfloat R = sampleVelocity(vR).x;\n\tfloat T = sampleVelocity(vT).y;\n\tfloat B = sampleVelocity(vB).y;\n\tfloat div = 0.5 * (R - L + T - B);\n\tgl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/divergence.frag\";\n\nexport class DivergenceMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uVelocity: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useDivergenceMaterial = () => {\n   const divergenceMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return divergenceMaterial as DivergenceMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uDivergence;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tfloat C = texture2D(uPressure, vUv).x;\n\tfloat divergence = texture2D(uDivergence, vUv).x;\n\tfloat pressure = (L + R + B + T - divergence) * 0.25;\n\tgl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/pressure.frag\";\n\nexport class PressureMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uPressure: { value: THREE.Texture };\n      uDivergence: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const usePressureMaterial = () => {\n   const pressureMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: null },\n               uDivergence: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return pressureMaterial as PressureMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvoid main () {\n\tfloat L = texture2D(uVelocity, vL).y;\n\tfloat R = texture2D(uVelocity, vR).y;\n\tfloat T = texture2D(uVelocity, vT).x;\n\tfloat B = texture2D(uVelocity, vB).x;\n\tfloat vorticity = R - L - T + B;\n\tgl_FragColor = vec4(vorticity, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/curl.frag\";\n\nexport class CurlMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uVelocity: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useCurlMaterial = () => {\n   const curlMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return curlMaterial as CurlMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\nuniform sampler2D uCurl;\nuniform float curl;\nuniform float dt;\n\nvoid main () {\n\tfloat T = texture2D(uCurl, vT).x;\n\tfloat B = texture2D(uCurl, vB).x;\n\tfloat C = texture2D(uCurl, vUv).x;\n\tvec2 force = vec2(abs(T) - abs(B), 0.0);\n\tforce *= 1.0 / length(force + 0.00001) * curl * C;\n\tvec2 vel = texture2D(uVelocity, vUv).xy;\n\tgl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/vorticity.frag\";\n\nexport class VorticityMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uVelocity: { value: THREE.Texture };\n      uCurl: { value: THREE.Texture };\n      curl: { value: number };\n      dt: { value: number };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useVorticityMaterial = () => {\n   const vorticityMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               uCurl: { value: null },\n               curl: { value: 0 },\n               dt: { value: 0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return vorticityMaterial as VorticityMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform float value;\n\nvoid main () {\n\tgl_FragColor = value * texture2D(uTexture, vUv);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/clear.frag\";\n\nexport class ClearMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      value: { value: number };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useClearMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               value: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as ClearMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uVelocity;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tvec2 velocity = texture2D(uVelocity, vUv).xy;\n\tvelocity.xy -= vec2(R - L, T - B);\n\tgl_FragColor = vec4(velocity, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/gradientSubtract.frag\";\n\nexport class GradientSubtractMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uPressure: { value: THREE.Texture };\n      uVelocity: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useGradientSubtractMaterial = () => {\n   const gradientSubtractMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: new THREE.Texture() },\n               uVelocity: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return gradientSubtractMaterial as GradientSubtractMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D uTarget;\nuniform float aspectRatio;\nuniform vec3 color;\nuniform vec2 point;\nuniform float radius;\n\nvoid main () {\n\tvec2 nPoint = (point + vec2(1.0)) * 0.5;\n\tvec2 p = vUv - nPoint.xy;\n\tp.x *= aspectRatio;\n\tvec3 splat = exp(-dot(p, p) / radius) * color;\n\tvec3 base = texture2D(uTarget, vUv).xyz;\n\tgl_FragColor = vec4(base + splat, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/splat.frag\";\n\nexport class SplatMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTarget: { value: THREE.Texture };\n      aspectRatio: { value: number };\n      color: { value: THREE.Vector3 };\n      point: { value: THREE.Vector2 };\n      radius: { value: number };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useSplateMaterial = () => {\n   const splatMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTarget: { value: new THREE.Texture() },\n               aspectRatio: { value: 0 },\n               color: { value: new THREE.Vector3() },\n               point: { value: new THREE.Vector2() },\n               radius: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return splatMaterial as SplatMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo } from \"react\";\nimport { useInitialMaterial } from \"./materials/useInitialMaterial\";\nimport {\n   AdvectionMaterial,\n   useAdvectionMaterial,\n} from \"./materials/useAdvectionMaterial\";\nimport {\n   DivergenceMaterial,\n   useDivergenceMaterial,\n} from \"./materials/useDivergenceMaterial\";\nimport {\n   PressureMaterial,\n   usePressureMaterial,\n} from \"./materials/usePressureMaterial\";\nimport { CurlMaterial, useCurlMaterial } from \"./materials/useCurlMaterial\";\nimport {\n   VorticityMaterial,\n   useVorticityMaterial,\n} from \"./materials/useVorticityMaterial\";\nimport { useResolution } from \"../../utils/useResolution\";\nimport { ClearMaterial, useClearMaterial } from \"./materials/useClearMaterial\";\nimport {\n   GradientSubtractMaterial,\n   useGradientSubtractMaterial,\n} from \"./materials/useGradientSubtractMaterial\";\nimport { SplatMaterial, useSplateMaterial } from \"./materials/useSplatMaterial\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TMaterials =\n   | AdvectionMaterial\n   | DivergenceMaterial\n   | CurlMaterial\n   | PressureMaterial\n   | ClearMaterial\n   | GradientSubtractMaterial\n   | SplatMaterial;\n\nexport type FluidMaterials = {\n   vorticityMaterial: VorticityMaterial;\n   curlMaterial: CurlMaterial;\n   advectionMaterial: AdvectionMaterial;\n   divergenceMaterial: DivergenceMaterial;\n   pressureMaterial: PressureMaterial;\n   clearMaterial: ClearMaterial;\n   gradientSubtractMaterial: GradientSubtractMaterial;\n   splatMaterial: SplatMaterial;\n};\ntype TUseMeshReturnType = [FluidMaterials, (material: TMaterials) => void];\n\n/**\n * Returns the material update function in the second argument\n */\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}): TUseMeshReturnType => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const initialMaterial = useInitialMaterial();\n   const updateMaterial = initialMaterial.clone();\n   const curlMaterial = useCurlMaterial();\n   const vorticityMaterial = useVorticityMaterial();\n   const advectionMaterial = useAdvectionMaterial();\n   const divergenceMaterial = useDivergenceMaterial();\n   const pressureMaterial = usePressureMaterial();\n   const clearMaterial = useClearMaterial();\n   const gradientSubtractMaterial = useGradientSubtractMaterial();\n   const splatMaterial = useSplateMaterial();\n   const materials = useMemo(\n      () => ({\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      }),\n      [\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      ]\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(\n         materials.splatMaterial,\n         \"aspectRatio\",\n         resolution.x / resolution.y\n      );\n      for (const material of Object.values(materials)) {\n         setUniform<typeof material.uniforms>(\n            material,\n            \"texelSize\",\n            new THREE.Vector2(1.0 / resolution.x, 1.0 / resolution.y)\n         );\n      }\n   }, [resolution, materials]);\n\n   const mesh = useAddMesh(scene, geometry, initialMaterial);\n   useEffect(() => {\n      initialMaterial.dispose();\n      mesh.material = updateMaterial;\n   }, [initialMaterial, mesh, updateMaterial]);\n\n   useEffect(() => {\n      return () => {\n         for (const material of Object.values(materials)) {\n            material.dispose();\n         }\n      };\n   }, [materials]);\n\n   const setMeshMaterial = useCallback(\n      (material: TMaterials) => {\n         mesh.material = material;\n         mesh.material.needsUpdate = true;\n      },\n      [mesh]\n   );\n\n   return [materials, setMeshMaterial];\n};\n","import * as THREE from \"three\";\nimport { FluidMaterials, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { useDoubleFBO } from \"../../utils/useDoubleFBO\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { usePointer } from \"../../utils/usePointer\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\nimport { DoubleRenderTarget, UseFboProps } from \"../../utils/types\";\n\nexport type FluidParams = {\n   /** density disspation , default:0.98 */\n   density_dissipation?: number;\n   /** velocity dissipation , default:0.99 */\n   velocity_dissipation?: number;\n   /** velocity acceleration , default:10.0 */\n   velocity_acceleration?: number;\n   /** pressure dissipation , default:0.9 */\n   pressure_dissipation?: number;\n   /** pressure iterations. affects performance , default:20 */\n   pressure_iterations?: number;\n   /** curl_strength , default:35 */\n   curl_strength?: number;\n   /** splat radius , default:0.002 */\n   splat_radius?: number;\n   /** Fluid Color.THREE.Vector3 Alternatively, it accepts a function that returns THREE.Vector3.The function takes velocity:THREE.Vector2 as an argument. , default:THREE.Vector3(1.0, 1.0, 1.0) */\n   fluid_color?: ((velocity: THREE.Vector2) => THREE.Vector3) | THREE.Vector3;\n};\n\nexport type FluidObject = {\n   scene: THREE.Scene;\n   materials: FluidMaterials;\n   camera: THREE.Camera;\n   renderTarget: {\n      velocity: DoubleRenderTarget;\n      density: DoubleRenderTarget;\n      curl: THREE.WebGLRenderTarget;\n      divergence: THREE.WebGLRenderTarget;\n      pressure: DoubleRenderTarget;\n   };\n};\n\nexport const FLUID_PARAMS: FluidParams = {\n   density_dissipation: 0.98,\n   velocity_dissipation: 0.99,\n   velocity_acceleration: 10.0,\n   pressure_dissipation: 0.9,\n   pressure_iterations: 20,\n   curl_strength: 35,\n   splat_radius: 0.002,\n   fluid_color: new THREE.Vector3(1.0, 1.0, 1.0),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useFluid = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<FluidParams, FluidObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const [materials, setMeshMaterial] = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n\n   const fboProps = useMemo<UseFboProps>(\n      () => ({\n         scene,\n         camera,\n         size,\n      }),\n      [scene, camera, size]\n   );\n   const [velocityFBO, updateVelocityFBO] = useDoubleFBO(fboProps);\n   const [densityFBO, updateDensityFBO] = useDoubleFBO(fboProps);\n   const [curlFBO, updateCurlFBO] = useSingleFBO(fboProps);\n   const [divergenceFBO, updateDivergenceFBO] = useSingleFBO(fboProps);\n   const [pressureFBO, updatePressureFBO] = useDoubleFBO(fboProps);\n\n   const lastTime = useRef(0);\n   const scaledDiffVec = useRef(new THREE.Vector2(0, 0));\n   const spaltVec = useRef(new THREE.Vector3(0, 0, 0));\n\n   const [params, setParams] = useParams<FluidParams>(FLUID_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FluidParams) => {\n         const { gl, pointer, clock, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         if (lastTime.current === 0) {\n            lastTime.current = clock.getElapsedTime();\n         }\n         const dt = Math.min(\n            (clock.getElapsedTime() - lastTime.current) / 3,\n            0.02\n         );\n         lastTime.current = clock.getElapsedTime();\n\n         // update velocity\n         const velocityTex = updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", read);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(materials.advectionMaterial, \"dt\", dt);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.velocity_dissipation!\n            );\n         });\n\n         // update density\n         const densityTex = updateDensityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", velocityTex);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.density_dissipation!\n            );\n         });\n\n         // update splatting\n         const { currentPointer, diffPointer, isVelocityUpdate, velocity } =\n            updatePointer(pointer);\n         if (isVelocityUpdate) {\n            updateVelocityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               setUniform(materials.splatMaterial, \"point\", currentPointer);\n               const scaledDiff = diffPointer.multiply(\n                  scaledDiffVec.current\n                     .set(size.width, size.height)\n                     .multiplyScalar(params.velocity_acceleration!)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"color\",\n                  spaltVec.current.set(scaledDiff.x, scaledDiff.y, 1.0)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"radius\",\n                  params.splat_radius!\n               );\n            });\n            updateDensityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               const color: THREE.Vector3 =\n                  typeof params.fluid_color === \"function\"\n                     ? params.fluid_color(velocity)\n                     : params.fluid_color!;\n               setUniform(materials.splatMaterial, \"color\", color);\n            });\n         }\n\n         // update curl\n         const curlTex = updateCurlFBO(gl, () => {\n            setMeshMaterial(materials.curlMaterial);\n            setUniform(materials.curlMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update vorticity\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.vorticityMaterial);\n            setUniform(materials.vorticityMaterial, \"uVelocity\", read);\n            setUniform(materials.vorticityMaterial, \"uCurl\", curlTex);\n            setUniform(\n               materials.vorticityMaterial,\n               \"curl\",\n               params.curl_strength!\n            );\n            setUniform(materials.vorticityMaterial, \"dt\", dt);\n         });\n\n         // update divergence\n         const divergenceTex = updateDivergenceFBO(gl, () => {\n            setMeshMaterial(materials.divergenceMaterial);\n            setUniform(materials.divergenceMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update pressure\n         updatePressureFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.clearMaterial);\n            setUniform(materials.clearMaterial, \"uTexture\", read);\n            setUniform(\n               materials.clearMaterial,\n               \"value\",\n               params.pressure_dissipation!\n            );\n         });\n\n         // solve pressure iterative (Gauss-Seidel)\n         setMeshMaterial(materials.pressureMaterial);\n         setUniform(materials.pressureMaterial, \"uDivergence\", divergenceTex);\n         let pressureTexTemp: THREE.Texture;\n         for (let i = 0; i < params.pressure_iterations!; i++) {\n            pressureTexTemp = updatePressureFBO(gl, ({ read }) => {\n               setUniform(materials.pressureMaterial, \"uPressure\", read);\n            });\n         }\n\n         // update gradienSubtract\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.gradientSubtractMaterial);\n            setUniform(\n               materials.gradientSubtractMaterial,\n               \"uPressure\",\n               pressureTexTemp\n            );\n            setUniform(materials.gradientSubtractMaterial, \"uVelocity\", read);\n         });\n\n         return densityTex;\n      },\n      [\n         materials,\n         setMeshMaterial,\n         updateCurlFBO,\n         updateDensityFBO,\n         updateDivergenceFBO,\n         updatePointer,\n         updatePressureFBO,\n         updateVelocityFBO,\n         setParams,\n         params,\n      ]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         materials: materials,\n         camera: camera,\n         renderTarget: {\n            velocity: velocityFBO,\n            density: densityFBO,\n            curl: curlFBO,\n            divergence: divergenceFBO,\n            pressure: pressureFBO,\n         },\n      },\n   ];\n};\n","import { useEffect, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\n\ntype UseMeshProps = {\n   scale: number;\n   max: number;\n   texture?: THREE.Texture;\n   scene: THREE.Scene;\n};\n\nexport const useMesh = ({ scale, max, texture, scene }: UseMeshProps) => {\n   const meshArr = useRef<THREE.Mesh[]>([]);\n   const geometry = useMemo(\n      () => new THREE.PlaneGeometry(scale, scale),\n      [scale]\n   );\n   const material = useMemo(\n      () =>\n         new THREE.MeshBasicMaterial({\n            map: texture ?? null,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      [texture]\n   );\n\n   useEffect(() => {\n      for (let i = 0; i < max; i++) {\n         const mesh = new THREE.Mesh(geometry.clone(), material.clone());\n         mesh.rotateZ(2 * Math.PI * Math.random());\n         mesh.visible = false;\n         scene.add(mesh);\n         meshArr.current.push(mesh);\n      }\n   }, [geometry, material, scene, max]);\n\n   useEffect(() => {\n      return () => {\n         meshArr.current.forEach((mesh) => {\n            mesh.geometry.dispose();\n            if (Array.isArray(mesh.material)) {\n               mesh.material.forEach((material) => material.dispose());\n            } else {\n               mesh.material.dispose();\n            }\n            scene.remove(mesh);\n         });\n         meshArr.current = [];\n      };\n   }, [scene]);\n\n   return meshArr.current;\n};\n","import { useCallback, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { usePointer } from \"../../utils/usePointer\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\n\nexport type RippleParams = {\n   /** How often ripples appear,default:0.01 */\n   frequency?: number;\n   /** rotation rate,default:0.05 */\n   rotation?: number;\n   /** fadeout speed,default:0.9 */\n   fadeout_speed?: number;\n   /** scale rate,default:0.3 */\n   scale?: number;\n   /** alpha,default:0.6 */\n   alpha?: number;\n};\n\nexport type RippleObject = {\n   scene: THREE.Scene;\n   meshArr: THREE.Mesh[];\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const RIPPLE_PARAMS: RippleParams = {\n   frequency: 0.01,\n   rotation: 0.05,\n   fadeout_speed: 0.9,\n   scale: 0.3,\n   alpha: 0.6,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useRipple = ({\n   texture,\n   scale = 64,\n   max = 100,\n   size,\n}: {\n   /** texture applied to ripple */\n   texture: THREE.Texture;\n   /** ripple size, default:64 */\n   scale?: number;\n   /** ripple max length, default:100 */\n   max?: number;\n   size: Size;\n}): HooksReturn<RippleParams, RippleObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const meshArr = useMesh({\n      scale: scale,\n      max: max,\n      texture,\n      scene,\n   });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<RippleParams>(RIPPLE_PARAMS);\n\n   const currentWave = useRef(0);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: RippleParams) => {\n         const { gl, pointer, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         const { currentPointer, diffPointer } = updatePointer(pointer);\n         if (params.frequency! < diffPointer.length()) {\n            const mesh = meshArr[currentWave.current];\n            mesh.visible = true;\n            mesh.position.set(\n               currentPointer.x * (size.width / 2),\n               currentPointer.y * (size.height / 2),\n               0\n            );\n            mesh.scale.x = mesh.scale.y = 0.0;\n            (mesh.material as THREE.MeshBasicMaterial).opacity = params.alpha!;\n            currentWave.current = (currentWave.current + 1) % max;\n         }\n         meshArr.forEach((mesh) => {\n            if (mesh.visible) {\n               const material = mesh.material as THREE.MeshBasicMaterial;\n               mesh.rotation.z += params.rotation!;\n               material.opacity *= params.fadeout_speed!;\n               mesh.scale.x =\n                  params.fadeout_speed! * mesh.scale.x + params.scale!;\n               mesh.scale.y = mesh.scale.x;\n               if (material.opacity < 0.002) mesh.visible = false;\n            }\n         });\n\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, meshArr, updatePointer, max, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         camera: camera,\n         meshArr: meshArr,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform vec2 uResolution;\nuniform vec2 uTextureResolution;\nuniform sampler2D uTexture0;\nuniform sampler2D uTexture1;\nuniform sampler2D uMap;\nuniform float mapIntensity;\nuniform float edgeIntensity;\nuniform float progress;\nuniform float dirX;\nuniform float dirY;\nuniform vec2 epicenter;\nuniform float padding;\n\nbool isInPaddingArea(vec2 uv) {\n   return uv.x < padding || uv.x > 1.0 - padding || uv.y < padding || uv.y > 1.0 - padding;\n}\n\nvoid main() {\n\tvec2 bgRatio=vec2(\n\t\tmin((uResolution.x/uResolution.y)/(uTextureResolution.x/uTextureResolution.y),1.),\n\t\tmin((uResolution.y/uResolution.x)/(uTextureResolution.y/uTextureResolution.x),1.)\n\t);\n\tvec2 uv=vec2(\n\t\tvUv.x*bgRatio.x+(1.-bgRatio.x)*.5,\n\t\tvUv.y*bgRatio.y+(1.-bgRatio.y)*.5\n\t);\n\n\t// fx map\n\tvec2 map = texture2D(uMap, uv).rg;\n\tvec2 normalizedMap = map * 2.0 - 1.0;\n\n\t// multiply edge fx\n\tuv = uv * 2.0 - 1.0;\n\tuv *= map * distance(epicenter, uv) * edgeIntensity + 1.0;\n\tuv = (uv + 1.0) / 2.0;\n\n\t// padding\n\tif (isInPaddingArea(uv)) {\n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n\t}\n\tvec2 paddedUV = uv * (1.0 - 2.0 * padding * -1.) + padding * -1.;\n\n\t// centered uv\n\tvec2 centeredUV = paddedUV - vec2(0.5);\n\n\t// multiply map fx\n\tcenteredUV *= normalizedMap * map * mapIntensity + 1.0;\n\n\t// texture 0\n\tfloat xOffsetTexture0 = 0.5 - dirX * progress;\n\tfloat yOffsetTexture0 = 0.5 - dirY * progress;\n\tvec2 samplePosTexture0 = vec2(xOffsetTexture0, yOffsetTexture0) + centeredUV;\n\n\t//texture 1\n\tfloat xOffsetTexture1 = 0.5 + dirX * (1.0 - progress);\n\tfloat yOffsetTexture1 = 0.5 + dirY * (1.0 - progress);\n\tvec2 samplePosTexture1 = vec2(xOffsetTexture1, yOffsetTexture1) + centeredUV;\n\n\tvec4 color0 = texture2D(uTexture0, samplePosTexture0);\n\tvec4 color1 = texture2D(uTexture1, samplePosTexture1);\n\n\tgl_FragColor = mix(color0, color1, progress);\n\n}","import { useEffect, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useResolution } from \"../../utils/useResolution\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\nimport { Size } from \"@react-three/fiber\";\n\nexport class TransitionBgMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uResolution: { value: THREE.Vector2 };\n      uTextureResolution: { value: THREE.Vector2 };\n      uTexture0: { value: THREE.Texture };\n      uTexture1: { value: THREE.Texture };\n      padding: { value: number };\n      uMap: { value: THREE.Texture };\n      edgeIntensity: { value: number };\n      mapIntensity: { value: number };\n      epicenter: { value: THREE.Vector2 };\n      progress: { value: number };\n      dirX: { value: number };\n      dirY: { value: number };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uResolution: { value: new THREE.Vector2() },\n               uTextureResolution: { value: new THREE.Vector2() },\n               uTexture0: { value: new THREE.Texture() },\n               uTexture1: { value: new THREE.Texture() },\n               padding: { value: 0.0 },\n               uMap: { value: new THREE.Texture() },\n               edgeIntensity: { value: 0.0 },\n               mapIntensity: { value: 0.0 },\n               epicenter: { value: new THREE.Vector2(0.0, 0.0) },\n               progress: { value: 0.0 },\n               dirX: { value: 0.0 },\n               dirY: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      material.uniforms.uResolution.value = resolution.clone();\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material as TransitionBgMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\n\nexport type FxTextureParams = {\n   /** 1st texture , default:THREE.Texture() */\n   texture0?: THREE.Texture;\n   /** 2nd texture , default:THREE.Texture() */\n   texture1?: THREE.Texture;\n   /** background texture resolution , default:THREE.Vector2(0, 0) */\n   textureResolution?: THREE.Vector2;\n   /** add transparent padding, 0.0 ~ 1.0 , default:0.0 */\n   padding?: number;\n   /** The color map. The uv value is affected according to this rbg , default:THREE.Texture() */\n   map?: THREE.Texture;\n   /** intensity of map , default:0.0 */\n   mapIntensity?: number;\n   /** Intensity of effect on edges , default:0.0 */\n   edgeIntensity?: number;\n   /** epicenter of fx, -1 ~ 1 , default:vec2(0.0,0.0)*/\n   epicenter?: THREE.Vector2;\n   /** Switch value to switch between texture0 and texture1 */\n   progress?: number;\n   /** direction of transition , default: THREE.Vector2(0, 0) */\n   dir?: THREE.Vector2;\n};\n\nexport type FxTextureObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const FXTEXTURE_PARAMS: FxTextureParams = {\n   texture0: new THREE.Texture(),\n   texture1: new THREE.Texture(),\n   textureResolution: new THREE.Vector2(0, 0),\n   padding: 0.0,\n   map: new THREE.Texture(),\n   mapIntensity: 0.0,\n   edgeIntensity: 0.0,\n   epicenter: new THREE.Vector2(0, 0),\n   progress: 0.0,\n   dir: new THREE.Vector2(0, 0),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useFxTexture = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<FxTextureParams, FxTextureObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      dpr,\n      size,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] = useParams<FxTextureParams>(FXTEXTURE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FxTextureParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture0\", params.texture0!);\n         setUniform(material, \"uTexture1\", params.texture1!);\n         setUniform(material, \"uTextureResolution\", params.textureResolution!);\n         setUniform(material, \"padding\", params.padding!);\n         setUniform(material, \"uMap\", params.map!);\n         setUniform(material, \"mapIntensity\", params.mapIntensity!);\n         setUniform(material, \"edgeIntensity\", params.edgeIntensity!);\n         setUniform(material, \"epicenter\", params.epicenter!);\n         setUniform(material, \"progress\", params.progress!);\n         setUniform(material, \"dirX\", params.dir!.x);\n         setUniform(material, \"dirY\", params.dir!.y);\n\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform float uTime;\nuniform float timeStrength;\nuniform int noiseOctaves;\nuniform int fbmOctaves;\n\nconst float per  = 0.5;\nconst float PI   = 3.14159265359;\n\nfloat interpolate(float a, float b, float x){\n    float f = (1.0 - cos(x * PI)) * 0.5;\n    return a * (1.0 - f) + b * f;\n}\n\nfloat rnd(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * .1995);\n\tp3 += dot(p3, p3.yzx + 11.28);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat irnd(vec2 p){\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tvec4 v = vec4(rnd(vec2(i.x,i.y)),rnd(vec2(i.x + 1.0,i.y)),rnd(vec2(i.x,i.y + 1.0)),rnd(vec2(i.x + 1.0, i.y + 1.0)));\n\treturn interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);\n}\n\n// Based on The Book of Shaders\n// https://thebookofshaders.com/13/\nfloat noise(vec2 p, float time){\n\tfloat t = 0.0;\n\tfor(int i = 0; i < noiseOctaves; i++){\n\t\tfloat freq = pow(2.0, float(i));\n\t\tfloat amp  = pow(per, float(noiseOctaves - i));\n\t\tt += irnd(vec2(p.y / freq + time, p.x / freq + time)) * amp;\n\t}\n\treturn t;\n}\n\nfloat fbm(vec2 x, float time) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n\tfloat sign = 1.0;\n\tfor (int i = 0; i < fbmOctaves; ++i) {\n\t\tv += a * noise(x, time * sign);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t\tsign *= -1.0;\n\t}\n\treturn v;\n}\n\nvoid main() {\n\tfloat noiseMap = fbm(gl_FragCoord.xy ,uTime * timeStrength);\n\tgl_FragColor = vec4(noiseMap,noiseMap,noiseMap,1.0);\n}\n\n","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\n\nexport class NoiseMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTime: { value: number };\n      timeStrength: { value: number };\n      noiseOctaves: { value: number };\n      fbmOctaves: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTime: { value: 0.0 },\n               timeStrength: { value: 0.0 },\n               noiseOctaves: { value: 0 },\n               fbmOctaves: { value: 0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as NoiseMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { useParams } from \"../../utils/useParams\";\nimport { HooksReturn } from \"../types\";\n\nexport type NoiseParams = {\n   /** time factor default:0.3 */\n   timeStrength?: number;\n   /** noiseOctaves, affects performance default:8 */\n   noiseOctaves?: number;\n   /** fbmOctaves, affects performance default:3 */\n   fbmOctaves?: number;\n};\n\nexport type NoiseObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const NOISE_PARAMS: NoiseParams = {\n   timeStrength: 0.3,\n   noiseOctaves: 8,\n   fbmOctaves: 3,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useNoise = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<NoiseParams, NoiseObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n   });\n\n   const [params, setParams] = useParams<NoiseParams>(NOISE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: NoiseParams) => {\n         const { gl, clock } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"timeStrength\", params.timeStrength!);\n         setUniform(material, \"noiseOctaves\", params.noiseOctaves!);\n         setUniform(material, \"fbmOctaves\", params.fbmOctaves!);\n\n         setUniform(material, \"uTime\", clock.getElapsedTime());\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","import { DomSyncerParams } from \"..\";\n\nexport const errorHandler = (params: DomSyncerParams) => {\n   const domLength = params.dom?.length;\n   const textureLength = params.texture?.length;\n   const resolutionLength = params.resolution?.length;\n\n   if (!domLength || !textureLength || !resolutionLength) {\n      throw new Error(\"No dom or texture or resolution is set\");\n   }\n\n   if (domLength !== textureLength || domLength !== resolutionLength) {\n      throw new Error(\"Match dom, texture and resolution length\");\n   }\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D u_texture;\nuniform vec2 u_textureResolution;\nuniform vec2 u_resolution;\nuniform float u_borderRadius;\n\nvoid main() {\n\t// texuture color\n\tvec2 ratio = vec2(\n\t\tmin((u_resolution.x / u_resolution.y) / (u_textureResolution.x / u_textureResolution.y), 1.0),\n\t\tmin((u_resolution.y / u_resolution.x) / (u_textureResolution.y / u_textureResolution.x), 1.0)\n\t);\n\tvec2 adjustedUv = vUv * ratio + (1.0 - ratio) * 0.5;\n\tvec3 textureColor = texture2D(u_texture, adjustedUv).rgb;\n\tfloat textureAlpha = texture2D(u_texture, adjustedUv).a;\n\n\t// Based on https://mofu-dev.com/en/blog/three-dom-alignment/\n\tfloat maxSide = max(u_resolution.x, u_resolution.y);\n\tfloat minSide = min(u_resolution.x, u_resolution.y);\n\tvec2 aspect = u_resolution / maxSide;\n\tvec2 alphaUv = vUv - 0.5;\n\n\tfloat borderRadius = min(u_borderRadius, minSide * 0.5);\n\tvec2 offset = vec2(borderRadius) / u_resolution;\n\tvec2 alphaXY = smoothstep(vec2(0.5 - offset), vec2(0.5 - offset - 0.001), abs(alphaUv));\n\tfloat alpha = min(1.0, alphaXY.x + alphaXY.y);\n\n\tvec2 alphaUv2 = abs(vUv - 0.5);\n\tfloat radius = borderRadius / maxSide;\n\talphaUv2 = (alphaUv2 - 0.5) * aspect + radius;\n\tfloat roundAlpha = smoothstep(radius + 0.001, radius, length(alphaUv2));\n\n\talpha = min(1.0, alpha + roundAlpha);\n\n\t// multiply texture alpha\n\talpha *= textureAlpha;\n\n\tgl_FragColor = vec4(textureColor, alpha);\n}\n","import * as THREE from \"three\";\nimport { DomSyncerParams } from \"../\";\nimport { Size } from \"@react-three/fiber\";\nimport vertexShader from \"../shader/main.vert\";\nimport fragmentShader from \"../shader/main.frag\";\n\nexport class DomSyncerMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_textureResolution: { value: THREE.Vector2 };\n      u_resolution: { value: THREE.Vector2 };\n      u_borderRadius: { value: number };\n   };\n}\n\nexport const createMesh = ({\n   params,\n   size,\n   scene,\n}: {\n   params: DomSyncerParams;\n   size: Size;\n   scene: THREE.Scene;\n}) => {\n   if (scene.children.length > 0) {\n      scene.children.forEach((child) => {\n         if (child instanceof THREE.Mesh) {\n            child.geometry.dispose();\n            child.material.dispose();\n         }\n      });\n      scene.remove(...scene.children);\n   }\n\n   params.texture!.forEach((texture, i) => {\n      const mesh = new THREE.Mesh(\n         new THREE.PlaneGeometry(1, 1),\n         new THREE.ShaderMaterial({\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            transparent: true,\n            uniforms: {\n               u_texture: { value: texture },\n               u_textureResolution: { value: new THREE.Vector2(0, 0) },\n               u_resolution: { value: new THREE.Vector2(0, 0) },\n               u_borderRadius: {\n                  value: params.boderRadius![i] ? params.boderRadius![i] : 0.0,\n               },\n            },\n         })\n      );\n      scene.add(mesh);\n   });\n};\n","import { useCallback, useRef } from \"react\";\nimport { DomSyncerParams } from \"..\";\n\nexport const useIntersectionHandler = () => {\n   const intersectionObserverRef = useRef<IntersectionObserver[]>([]);\n   const intersectionDomRef = useRef<(HTMLElement | Element | null)[]>([]);\n\n   const intersectionHandler = useCallback(\n      ({\n         isIntersectingRef,\n         isIntersectingOnceRef,\n         params,\n      }: {\n         isIntersectingRef: React.MutableRefObject<boolean[]>;\n         isIntersectingOnceRef: React.MutableRefObject<boolean[]>;\n         params: DomSyncerParams;\n      }) => {\n         if (intersectionObserverRef.current.length > 0) {\n            intersectionObserverRef.current.forEach((observer, i) => {\n               observer.unobserve(intersectionDomRef.current[i]!);\n            });\n         }\n\n         intersectionDomRef.current = [];\n         intersectionObserverRef.current = [];\n\n         const newArr = new Array(params.dom!.length).fill(false);\n         isIntersectingRef.current = [...newArr];\n         isIntersectingOnceRef.current = [...newArr];\n\n         params.dom!.forEach((dom, i) => {\n            const callback = (entries: IntersectionObserverEntry[]) => {\n               entries.forEach((entry) => {\n                  params.onIntersect![i] && params.onIntersect![i](entry);\n                  // Update the judgment after execution so that the judgment of isIntersectin can be used when executing onIntersect\n                  isIntersectingRef.current[i] = entry.isIntersecting;\n               });\n            };\n            const observer = new IntersectionObserver(callback, {\n               rootMargin: \"0px\",\n               threshold: 0,\n            });\n            observer.observe(dom!);\n            intersectionObserverRef.current.push(observer);\n            intersectionDomRef.current.push(dom!);\n         });\n      },\n      []\n   );\n\n   return intersectionHandler;\n};\n","import * as THREE from \"three\";\nimport { DomSyncerParams } from \"../\";\nimport { Size } from \"@react-three/fiber\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { DomSyncerMaterial } from \"./createMesh\";\n\nexport const updateRect = ({\n   params,\n   size,\n   resolutionRef,\n   scene,\n   isIntersectingRef,\n}: {\n   params: DomSyncerParams;\n   size: Size;\n   resolutionRef: React.MutableRefObject<THREE.Vector2>;\n   scene: THREE.Scene;\n   isIntersectingRef: React.MutableRefObject<boolean[]>;\n}) => {\n   scene.children.forEach((mesh, i) => {\n      const domElement = params.dom![i];\n      if (!domElement) {\n         throw new Error(\"DOM is null.\");\n      }\n      if (isIntersectingRef.current[i]) {\n         const rect = domElement.getBoundingClientRect();\n         mesh.scale.set(rect.width, rect.height, 1.0);\n         mesh.position.set(\n            rect.left + rect.width * 0.5 - size.width * 0.5,\n            -rect.top - rect.height * 0.5 + size.height * 0.5,\n            0.0\n         );\n         if (mesh instanceof THREE.Mesh) {\n            const material: DomSyncerMaterial = mesh.material;\n            setUniform(material, \"u_texture\", params.texture![i]);\n            setUniform(material, \"u_textureResolution\", params.resolution![i]);\n            setUniform(\n               material,\n               \"u_resolution\",\n               resolutionRef.current.set(rect.width, rect.height)\n            );\n            setUniform(\n               material,\n               \"u_borderRadius\",\n               params.boderRadius![i] ? params.boderRadius![i] : 0.0\n            );\n         }\n      }\n   });\n};\n","import { useCallback, useRef } from \"react\";\n\nexport type IsIntersecting = (\n   index: number,\n   once?: boolean\n) => boolean[] | boolean;\n\nexport const useIsIntersecting = () => {\n   const isIntersectingRef = useRef<boolean[]>([]);\n   const isIntersectingOnceRef = useRef<boolean[]>([]);\n\n   const isIntersecting: IsIntersecting = useCallback((index, once = false) => {\n      isIntersectingRef.current.forEach((value, i) => {\n         if (value) {\n            isIntersectingOnceRef.current[i] = true;\n         }\n      });\n      const temp = once\n         ? [...isIntersectingOnceRef.current]\n         : [...isIntersectingRef.current];\n      return index < 0 ? temp : temp[index];\n   }, []);\n\n   return {\n      isIntersectingRef,\n      isIntersectingOnceRef,\n      isIntersecting,\n   };\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\nimport { errorHandler } from \"./utils/errorHandler\";\nimport { createMesh } from \"./utils/createMesh\";\nimport { useIntersectionHandler } from \"./utils/useIntersectionHandler\";\nimport { updateRect } from \"./utils/updateRect\";\nimport { useIsIntersecting, IsIntersecting } from \"./utils/useIsIntersecting\";\n\nexport type DomSyncerParams = {\n   /** DOM array you want to synchronize */\n   dom?: (HTMLElement | Element | null)[];\n   /** Texture array that you want to synchronize with the DOM rectangle */\n   texture?: THREE.Texture[];\n   /** Texture resolution array to pass */\n   resolution?: THREE.Vector2[];\n   /** default:0.0[] */\n   boderRadius?: number[];\n   /** Array of callback functions when crossed */\n   onIntersect?: ((entry: IntersectionObserverEntry) => void)[];\n};\n\nexport type DomSyncerObject = {\n   scene: THREE.Scene;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   /**\n    * A function that returns a determination whether the DOM intersects or not.\n    * The boolean will be updated after executing the onIntersect function.\n    * @param index - Index of the dom for which you want to return an intersection decision. -1 will return the entire array.\n    * @param once - If set to true, it will continue to return true once crossed.\n    */\n   isIntersecting: IsIntersecting;\n};\n\nexport const DOMSYNCER_PARAMS: DomSyncerParams = {\n   texture: [],\n   dom: [],\n   resolution: [],\n   boderRadius: [],\n   onIntersect: [],\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useDomSyncer = (\n   {\n      size,\n      dpr,\n   }: {\n      size: Size;\n      dpr: number;\n   },\n   dependencies: React.DependencyList = []\n): HooksReturn<DomSyncerParams, DomSyncerObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      isSizeUpdate: true,\n   });\n   const [params, setParams] = useParams<DomSyncerParams>(DOMSYNCER_PARAMS);\n\n   // Avoid instancing vec2 every frame\n   const resolutionRef = useRef<THREE.Vector2>(new THREE.Vector2(0, 0));\n\n   // Update monitored doms according to the dependency array\n   const [refreshTrigger, setRefreshTrigger] = useState(true);\n   useEffect(() => {\n      setRefreshTrigger(true);\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, dependencies);\n\n   const intersectionHandler = useIntersectionHandler();\n   const { isIntersectingOnceRef, isIntersectingRef, isIntersecting } =\n      useIsIntersecting();\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: DomSyncerParams) => {\n         const { gl, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         errorHandler(params);\n\n         if (refreshTrigger) {\n            createMesh({\n               params,\n               size,\n               scene,\n            });\n\n            intersectionHandler({\n               isIntersectingRef,\n               isIntersectingOnceRef,\n               params,\n            });\n\n            setRefreshTrigger(false);\n         }\n\n         updateRect({\n            params,\n            size,\n            resolutionRef,\n            scene,\n            isIntersectingRef,\n         });\n\n         return updateRenderTarget(gl);\n      },\n      [\n         updateRenderTarget,\n         setParams,\n         intersectionHandler,\n         refreshTrigger,\n         scene,\n         params,\n         isIntersectingOnceRef,\n         isIntersectingRef,\n      ]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         camera: camera,\n         renderTarget: renderTarget,\n         isIntersecting: isIntersecting,\n      },\n   ];\n};\n","precision mediump float;\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uBlurSize;\n\nvoid main() {\n\tvec2 uv = vUv;\t\n\tvec2 perDivSize = uBlurSize / uResolution;\n\n\t// calc average color value from adjacent point\n\tvec4 outColor = vec4(\n\t\ttexture2D(uTexture, uv + perDivSize * vec2(-1.0, -1.0)) +\n\t\ttexture2D(uTexture, uv + perDivSize * vec2(0.0, -1.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(1.0, -1.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(-1.0, 0.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(0.0,  0.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(1.0,  0.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(-1.0, 1.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(0.0,  1.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(1.0,  1.0))\n\t\t) / 9.0;\n\t\n\tgl_FragColor = outColor;\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\n\nimport { useAddMesh } from \"../../utils/useAddMesh\";\n\nexport class SampleMaterial extends THREE.ShaderMaterial {\n   uniforms!: {      \n      uTexture: { value: THREE.Texture };\n      uResolution: { value: THREE.Vector2 };\n      uBlurSize: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uResolution: { value: new THREE.Vector2(0,0) },\n               uBlurSize: { value: 1, }\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as SampleMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useMesh } from \"./useMesh\";\n\nimport { useCamera } from \"../../utils/useCamera\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { useDoubleFBO } from \"../../utils/useDoubleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { useParams } from \"../../utils/useParams\";\n\nimport type { HooksReturn } from \"../types\";\n\nexport type SimpleBlurParams = {\n   /** Make this texture blur , Default:new THREE.Texture() */\n   texture: THREE.Texture;\n   /** blurSize, default:3 */\n   blurSize: number;\n   /** blurPower, affects performance default:5 */\n   blurPower: number;\n};\n\nexport type SimpleBlurObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const SIMPLEBLUR_PARAMS: SimpleBlurParams = {\n   texture: new THREE.Texture(),\n   blurSize: 3,\n   blurPower: 5,\n};\n\nexport const useSimpleBlur = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<SimpleBlurParams, SimpleBlurObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n\n   const fboProps = useMemo(\n      () => ({\n         scene,\n         camera,\n         size,\n         dpr,\n      }),\n      [scene, camera, size, dpr]\n   );\n   const [renderTarget, updateRenderTarget] = useSingleFBO(fboProps);\n   const [tempTexture, updateTempTexture] = useDoubleFBO(fboProps);\n   const [params, setParams] = useParams<SimpleBlurParams>(SIMPLEBLUR_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: SimpleBlurParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture);\n         setUniform(material, \"uResolution\", [\n            params.texture.source.data.width,\n            params.texture.source.data.height,\n         ]);\n         setUniform(material, \"uBlurSize\", params.blurSize);\n\n         let _tempTexture: THREE.Texture = updateTempTexture(gl);\n\n         const iterations = params.blurPower;\n         for (let i = 0; i < iterations; i++) {\n            setUniform(material, \"uTexture\", _tempTexture);\n            _tempTexture = updateTempTexture(gl);\n         }\n\n         const outPutTexture = updateRenderTarget(gl);\n\n         return outPutTexture;\n      },\n      [updateRenderTarget, updateTempTexture, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform vec2 uResolution;\nuniform float uProgress;\nuniform float uStrength;\nuniform float uWidth;\nuniform vec2 uEpicenter;\nuniform int uMode;\n\nfloat PI = 3.141592653589;\n\nvoid main() {\n\tfloat progress = min(uProgress, 1.0);\n\tfloat progressFactor = sin(progress * PI);\n\n\tfloat border = progress - progress * progressFactor * uWidth;\n\tfloat blur = uStrength * progressFactor;\n\t\n\t// 0 ~ 1\n\tvec2 normalizeCenter = (uEpicenter + 1.0) / 2.0;\n\n\t// 0:center 1:horizontal 2:vertical\n\tfloat dist = uMode == 0 ? length(vUv - normalizeCenter) : uMode == 1 ? length(vUv.x - normalizeCenter.x) : length(vUv.y - normalizeCenter.y);\n\n\t// Calculate the maximum distance to the four corners of the screen\n\tfloat maxDistance = max(\n\t\tlength(vec2(0.0, 0.0) - normalizeCenter),\n\t\tmax(\n\t\t\t\tlength(vec2(1.0, 0.0) - normalizeCenter),\n\t\t\t\tmax(\n\t\t\t\t\tlength(vec2(0.0, 1.0) - normalizeCenter),\n\t\t\t\t\tlength(vec2(1.0, 1.0) - normalizeCenter)\n\t\t\t\t)\n\t\t)\n\t);\n\n\t// Scale distance so that waves extend to the edge of the screen\n\tdist = maxDistance > 0.0 ? dist / maxDistance : dist;\n\n\tvec3 color = vec3(smoothstep(border - blur, border, dist) -\n                  smoothstep(progress, progress + blur, dist));\n\t\n\t// Ensure color is 0 when progress is 0,1\n\tcolor *= progressFactor;\n\n\tgl_FragColor = vec4(color, 1.0);\n}\n\n","import * as THREE from \"three\";\nimport { useEffect, useMemo } from \"react\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\nimport { useResolution } from \"../..\";\nimport { Size } from \"@react-three/fiber\";\n\nexport class WaveMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uEpicenter: { value: THREE.Vector2 };\n      uProgress: { value: number };\n      uStrength: { value: number };\n      uWidth: { value: number };\n      uResolution: { value: THREE.Vector2 };\n      uMode: { value: number };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uEpicenter: { value: new THREE.Vector2(0.0, 0.0) },\n               uProgress: { value: 0.0 },\n               uStrength: { value: 0.0 },\n               uWidth: { value: 0.0 },\n               uResolution: { value: new THREE.Vector2() },\n               uMode: { value: 0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      material.uniforms.uResolution.value = resolution.clone();\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material as WaveMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { useMesh } from \"./useMesh\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { useParams } from \"../../utils/useParams\";\nimport { HooksReturn } from \"../types\";\n\nexport type WaveParams = {\n   /** -1.0 ~ 1.0 , default:vec2(0.0,0.0) */\n   epicenter?: THREE.Vector2;\n   /** 0.0 ~ 1.0 , default:0.0 */\n   progress?: number;\n   /** default:0.0 */\n   width?: number;\n   /** default:0.0 */\n   strength?: number;\n   /** default:center */\n   mode?: \"center\" | \"horizontal\" | \"vertical\";\n};\n\nexport type WaveObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const WAVE_PARAMS: WaveParams = {\n   epicenter: new THREE.Vector2(0.0, 0.0),\n   progress: 0.0,\n   width: 0.0,\n   strength: 0.0,\n   mode: \"center\",\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useWave = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<WaveParams, WaveObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] = useParams<WaveParams>(WAVE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: WaveParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uEpicenter\", params.epicenter!);\n         setUniform(material, \"uProgress\", params.progress!);\n         setUniform(material, \"uWidth\", params.width!);\n         setUniform(material, \"uStrength\", params.strength!);\n         setUniform(\n            material,\n            \"uMode\",\n            params.mode! === \"center\"\n               ? 0\n               : params.mode! === \"horizontal\"\n               ? 1\n               : 2\n         );\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","import * as THREE from \"three\";\nimport {\n   useCallback,\n   useEffect,\n   useLayoutEffect,\n   useMemo,\n   useRef,\n} from \"react\";\nimport { useResolution } from \"./useResolution\";\nimport { UseFboProps } from \"./types\";\nimport { FBO_OPTION } from \"./useSingleFBO\";\n\ntype UpdateCopyFunction = (\n   gl: THREE.WebGLRenderer,\n   index: number,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({ read }: { read: THREE.Texture }) => void\n) => THREE.Texture;\n\ntype UseCopyTextureReturn = [THREE.WebGLRenderTarget[], UpdateCopyFunction];\n\n/**\n * Generate an FBO array to copy the texture.\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @param length The number of FBOs to create\n * @returns [THREE.WebGLRenderTarget[] , updateCopyTexture] -Receives the RenderTarget array as the first argument and the update function as the second argument. updateCopyTexture() receives gl as the first argument and the index of the texture you want to copy as the second argument.\n */\nexport const useCopyTexture = (\n   { scene, camera, size, dpr = false, isSizeUpdate = false }: UseFboProps,\n   length: number\n): UseCopyTextureReturn => {\n   const renderTarget = useRef<THREE.WebGLRenderTarget[]>([]);\n   const resolution = useResolution(size, dpr);\n\n   renderTarget.current = useMemo(() => {\n      return Array.from(\n         { length },\n         () =>\n            new THREE.WebGLRenderTarget(resolution.x, resolution.y, FBO_OPTION)\n      );\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, [length]);\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current.forEach((fbo) =>\n            fbo.setSize(resolution.x, resolution.y)\n         );\n      }\n   }, [resolution, isSizeUpdate]);\n\n   useEffect(() => {\n      const currentRenderTarget = renderTarget.current;\n      return () => {\n         currentRenderTarget.forEach((fbo) => fbo.dispose());\n      };\n   }, [length]);\n\n   const updateCopyTexture: UpdateCopyFunction = useCallback(\n      (gl, index, onBeforeRender) => {\n         const fbo = renderTarget.current[index];\n         gl.setRenderTarget(fbo);\n         onBeforeRender && onBeforeRender({ read: fbo.texture });\n         gl.render(scene, camera);\n         gl.setRenderTarget(null);\n         gl.clear();\n         return fbo.texture;\n      },\n      [scene, camera]\n   );\n\n   return [renderTarget.current, updateCopyTexture];\n};\n"],"names":["main_default","useResolution","size","dpr","_width","_height","useMemo","THREE","useAddMesh","scene","geometry","material","mesh","useEffect","setUniform","key","value","useMesh","vertexShader","fragmentShader","resolution","getCameraProps","width","height","frustumSize","aspect","w","h","useCamera","near","far","FBO_OPTION","useSingleFBO","camera","isSizeUpdate","renderTarget","useRef","useLayoutEffect","_a","currentRenderTarget","updateRenderTarget","useCallback","gl","onBeforeRender","fbo","useDoubleFBO","temp","initRenderTargets","read","write","_b","usePointer","prevPointer","diffPointer","lastUpdateTime","velocity","isMoved","currentPointer","now","current","deltaTime","isUpdate","prevTemp","useParams","params","isContainsFunctions","obj","paramsRef","setParams","updateParams","paramKey","BRUSH_PARAMS","useBrush","updatePointer","props","pointer","DUOTONE_PARAMS","useDuoTone","FOGPROJECTION_PARAMS","useFogProjection","clock","init_default","useInitialMaterial","advection_default","useAdvectionMaterial","divergence_default","useDivergenceMaterial","pressure_default","usePressureMaterial","curl_default","useCurlMaterial","vorticity_default","useVorticityMaterial","clear_default","useClearMaterial","gradientSubtract_default","useGradientSubtractMaterial","splat_default","useSplateMaterial","initialMaterial","updateMaterial","curlMaterial","vorticityMaterial","advectionMaterial","divergenceMaterial","pressureMaterial","clearMaterial","gradientSubtractMaterial","splatMaterial","materials","setMeshMaterial","FLUID_PARAMS","useFluid","fboProps","velocityFBO","updateVelocityFBO","densityFBO","updateDensityFBO","curlFBO","updateCurlFBO","divergenceFBO","updateDivergenceFBO","pressureFBO","updatePressureFBO","lastTime","scaledDiffVec","spaltVec","dt","velocityTex","densityTex","isVelocityUpdate","scaledDiff","color","curlTex","divergenceTex","pressureTexTemp","i","scale","max","texture","meshArr","RIPPLE_PARAMS","useRipple","currentWave","FXTEXTURE_PARAMS","useFxTexture","NOISE_PARAMS","useNoise","errorHandler","domLength","textureLength","resolutionLength","_c","createMesh","child","useIntersectionHandler","intersectionObserverRef","intersectionDomRef","isIntersectingRef","isIntersectingOnceRef","observer","newArr","dom","callback","entries","entry","updateRect","resolutionRef","domElement","rect","useIsIntersecting","isIntersecting","index","once","DOMSYNCER_PARAMS","useDomSyncer","dependencies","refreshTrigger","setRefreshTrigger","useState","intersectionHandler","SIMPLEBLUR_PARAMS","useSimpleBlur","tempTexture","updateTempTexture","_tempTexture","iterations","WAVE_PARAMS","useWave","useCopyTexture","length","updateCopyTexture"],"mappings":"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"}