{"version":3,"file":"use-shader-fx.umd.cjs","sources":["../src/hooks/useBrush/shader/main.vert","../src/hooks/useBrush/shader/main.frag","../src/hooks/utils/useResolution.ts","../src/hooks/utils/useAddMesh.ts","../src/hooks/utils/setUniforms.ts","../src/hooks/useBrush/useMesh.ts","../src/hooks/utils/useCamera.ts","../src/hooks/utils/useSingleFBO.ts","../src/hooks/utils/useDoubleFBO.ts","../src/hooks/utils/usePointer.ts","../src/hooks/utils/useParams.ts","../src/hooks/useBrush/index.ts","../src/hooks/useDuoTone/shader/main.vert","../src/hooks/useDuoTone/shader/main.frag","../src/hooks/useDuoTone/useMesh.ts","../src/hooks/useDuoTone/index.ts","../src/hooks/useFlowmap/shader/main.vert","../src/hooks/useFlowmap/shader/main.frag","../src/hooks/useFlowmap/useMesh.ts","../src/hooks/useFlowmap/index.ts","../src/hooks/useFogProjection/shader/main.vert","../src/hooks/useFogProjection/shader/main.frag","../src/hooks/useFogProjection/useMesh.ts","../src/hooks/useFogProjection/index.ts","../src/hooks/useFruid/shaders/main.vert","../src/hooks/useFruid/shaders/init.frag","../src/hooks/useFruid/materials/useInitialMaterial.ts","../src/hooks/useFruid/shaders/advection.frag","../src/hooks/useFruid/materials/useAdvectionMaterial.ts","../src/hooks/useFruid/shaders/divergence.frag","../src/hooks/useFruid/materials/useDivergenceMaterial.ts","../src/hooks/useFruid/shaders/pressure.frag","../src/hooks/useFruid/materials/usePressureMaterial.ts","../src/hooks/useFruid/shaders/curl.frag","../src/hooks/useFruid/materials/useCurlMaterial.ts","../src/hooks/useFruid/shaders/vorticity.frag","../src/hooks/useFruid/materials/useVorticityMaterial.ts","../src/hooks/useFruid/shaders/clear.frag","../src/hooks/useFruid/materials/useClearMaterial.ts","../src/hooks/useFruid/shaders/gradientSubtract.frag","../src/hooks/useFruid/materials/useGradientSubtractMaterial.ts","../src/hooks/useFruid/shaders/splat.frag","../src/hooks/useFruid/materials/useSplatMaterial.ts","../src/hooks/useFruid/useMesh.ts","../src/hooks/useFruid/index.ts","../src/hooks/useRipple/useMesh.ts","../src/hooks/useRipple/index.ts","../src/hooks/useSimpleFruid/shaders/main.vert","../src/hooks/useSimpleFruid/shaders/init.frag","../src/hooks/useSimpleFruid/materials/useInitialMaterial.ts","../src/hooks/useSimpleFruid/shaders/velocity.frag","../src/hooks/useSimpleFruid/materials/useVelocityMaterial.ts","../src/hooks/useSimpleFruid/shaders/advection.frag","../src/hooks/useSimpleFruid/materials/useAdvectionMaterial.ts","../src/hooks/useSimpleFruid/shaders/divergence.frag","../src/hooks/useSimpleFruid/materials/useDivergenceMaterial.ts","../src/hooks/useSimpleFruid/shaders/pressure.frag","../src/hooks/useSimpleFruid/materials/usePressureMaterial.ts","../src/hooks/useSimpleFruid/useMesh.ts","../src/hooks/useSimpleFruid/index.ts","../src/hooks/useTransitionBg/shader/main.vert","../src/hooks/useTransitionBg/shader/main.frag","../src/hooks/useTransitionBg/useMesh.ts","../src/hooks/useTransitionBg/index.ts"],"sourcesContent":["varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nuniform sampler2D uMap;\nuniform sampler2D uTexture;\nuniform float uRadius;\nuniform float uAlpha;\nuniform float uDissipation;\nuniform float uMagnification;\nuniform vec2 uResolution;\nuniform float uSmudge;\nuniform float uAspect;\nuniform vec2 uMouse;\nuniform vec2 uPrevMouse;\nuniform vec2 uVelocity;\n\nuniform float uMotionBlur;\nuniform int uMotionSample;\n\nvarying vec2 vUv;\n\nfloat isOnLine(vec2 point, vec2 start, vec2 end, float width, float aspect) {\n\t//正円にする\n\tpoint.x *= aspect;\n\tstart.x *= aspect;\n\tend.x *= aspect;\n\n\t//方向の単位ベクトル\n\tvec2 dir = normalize(end - start);\n\t//線分に対して垂直の単位ベクトル\n\tvec2 n = vec2(dir.y, -dir.x);\n\t//方向ベクトル\n\tvec2 p0 = point - start;\n\t\n\t//線上の距離を計算する\n\tfloat distToLine = abs(dot(p0, n));\n\tfloat distAlongLine = dot(p0, dir);\n\tfloat totalLength = length(end - start);\n\n\t//始点と終点の円の半径も範囲に含める\n\tfloat distFromStart = length(point - start);\n\tfloat distFromEnd = length(point - end);\n\t\n\tbool withinLine = (distToLine < width && distAlongLine > 0.0 && distAlongLine < totalLength) || distFromStart < width || distFromEnd < width;\n\n\treturn float(withinLine);\n}\n\nvec4 createSmudge(){\n\tvec2 offsets[9];\n\toffsets[0] = vec2(-1, -1); offsets[1] = vec2( 0, -1); offsets[2] = vec2( 1, -1);\n\toffsets[3] = vec2(-1,  0); offsets[4] = vec2( 0,  0); offsets[5] = vec2( 1,  0);\n\toffsets[6] = vec2(-1,  1); offsets[7] = vec2( 0,  1); offsets[8] = vec2( 1,  1);\n\t// オフセットをテクスチャサイズにスケール\n\tfor(int i = 0; i < 9; i++) {\n\t\toffsets[i] = (offsets[i] * uSmudge) / uResolution;\n\t}\t\n\tvec4 smudgedColor = vec4(0.0);\n\tfor(int i = 0; i < 9; i++) {\n\t\tsmudgedColor += texture2D(uMap, vUv + offsets[i]);\n\t}\n\treturn smudgedColor / 9.0;\n}\n\nvec4 createMotionBlur(vec4 baseColor, vec2 velocity, float motion, int samples) {\n\tvec4 motionBlurredColor = baseColor;\n\tvec2 scaledVelocity = velocity * motion;\n\tfor(int i = 1; i < samples; i++) {\n\t\tfloat t = float(i) / float(samples - 1);\n\t\tvec2 offset = t * scaledVelocity / uResolution;\n\t\tmotionBlurredColor += texture2D(uMap, vUv + offset);\n\t}\n\treturn motionBlurredColor / float(samples);\n}\n\n\nvoid main() {\n\t// UV座標を[-1, 1]の範囲に変換\n\tvec2 st = vUv * 2.0 - 1.0;\n\t\n\t//速度ベクトル\n\tvec2 velocity = uVelocity * uResolution;\n\n\t// 滲みを加える\n\tvec4 smudgedColor = createSmudge();\n\t\n\t//モーションブラー\n\tvec4 motionBlurredColor = createMotionBlur(smudgedColor, uVelocity, uMotionBlur,uMotionSample);\n\n\t//バッファーテクスチャー\n\tvec4 bufferColor = motionBlurredColor * uDissipation;\n\n\t// radius\n\tfloat modifiedRadius = uRadius + (length(velocity) * uMagnification);\n\tmodifiedRadius = max(0.0,modifiedRadius);\n\n\t//\tcolor TODO:カラーに速度を反映させるかどうか、最初のフレームのカラーをどうするか\n\t// vec3 color = vec3(velocity * vec2(1, -1), 1.0 - pow(1.0 - min(1.0, length(velocity)), 1.0));\n\tvec3 color = vec3(1.0,1.0,1.0);\n\n\t//カラーにテクスチャーをマッピングする\n\tvec4 textureColor = texture2D(uTexture, vUv);\n\tvec3 finalColor = mix(color, textureColor.rgb, textureColor.a);\n\n\t//始点と終点の直線上を判定する\n\tfloat onLine = isOnLine(st, uPrevMouse, uMouse, modifiedRadius, uAspect);\n\n\t//最終出力\n\tbufferColor.rgb = mix(bufferColor.rgb, finalColor, onLine);\n\tgl_FragColor = bufferColor;\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\n/**\n * @params isDpr Whether to multiply dpr, default:false\n */\nexport const useResolution = (size: Size, dpr: number | false = false) => {\n   const _width = dpr ? size.width * dpr : size.width;\n   const _height = dpr ? size.height * dpr : size.height;\n   const resolution = useMemo(\n      () => new THREE.Vector2(_width, _height),\n      [_width, _height]\n   );\n   return resolution;\n};\n","import * as THREE from \"three\";\nimport { useEffect, useMemo } from \"react\";\n\nexport const useAddMesh = (\n   scene: THREE.Scene,\n   geometry: THREE.PlaneGeometry,\n   material: THREE.Material\n) => {\n   const mesh = useMemo(\n      () => new THREE.Mesh(geometry, material),\n      [geometry, material]\n   );\n   useEffect(() => {\n      scene.add(mesh);\n   }, [scene, mesh]);\n   return mesh;\n};\n","export const setUniform = (\n   material: THREE.ShaderMaterial | THREE.RawShaderMaterial,\n   key: string,\n   value:\n      | number\n      | THREE.Color\n      | THREE.Vector2\n      | THREE.Vector3\n      | THREE.Vector4\n      | THREE.Matrix3\n      | THREE.Matrix4\n      | THREE.Texture\n      | THREE.CubeTexture\n) => {\n   if (\n      material.uniforms &&\n      material.uniforms[key] &&\n      value !== undefined &&\n      value !== null\n   ) {\n      material.uniforms[key].value = value;\n   } else {\n      console.error(\n         `Uniform key \"${key}\" does not exist in the material. or \"${key}\" is null | undefined`\n      );\n   }\n};\n","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useEffect, useMemo } from \"react\";\nimport { useResolution } from \"../utils/useResolution\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\nexport const useMesh = ({\n   scene,\n   size,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uMap: {\n                  value: null,\n               },\n               uResolution: { value: new THREE.Vector2(0, 0) },\n               uAspect: { value: 1 },\n               uTexture: { value: new THREE.Texture() },\n               uRadius: { value: 0.0 },\n               uAlpha: { value: 0.0 },\n               uSmudge: { value: 0.0 },\n               uDissipation: { value: 0.0 },\n               uMagnification: { value: 0.0 },\n               uMotionBlur: { value: 0.0 },\n               uMotionSample: { value: 10 },\n               uMouse: { value: new THREE.Vector2(0, 0) },\n               uPrevMouse: { value: new THREE.Vector2(0, 0) },\n               uVelocity: { value: new THREE.Vector2(0, 0) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size);\n   useEffect(() => {\n      setUniform(material, \"uAspect\", resolution.width / resolution.height);\n      setUniform(material, \"uResolution\", resolution.clone());\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material;\n};\n","import * as THREE from \"three\";\nimport { useResolution } from \"./useResolution\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\nconst getCameraProps = (width: number, height: number) => {\n   const frustumSize = height;\n   const aspect = width / height;\n   const [w, h] = [(frustumSize * aspect) / 2, frustumSize / 2];\n   return { width: w, height: h, near: -1000, far: 1000 };\n};\n\nexport const useCamera = (size: Size) => {\n   const resolution = useResolution(size);\n   const { width, height, near, far } = getCameraProps(\n      resolution.x,\n      resolution.y\n   );\n   const camera = useMemo(\n      () =>\n         new THREE.OrthographicCamera(\n            -width,\n            width,\n            height,\n            -height,\n            near,\n            far\n         ),\n      [width, height, near, far]\n   );\n   return camera;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useLayoutEffect, useMemo, useRef } from \"react\";\nimport { useResolution } from \"./useResolution\";\nimport { UseFboProps } from \"./types\";\n\nexport const FBO_OPTION = {\n   minFilter: THREE.LinearFilter,\n   magFilter: THREE.LinearFilter,\n   type: THREE.HalfFloatType,\n   depthBuffer: false,\n   stencilBuffer: false,\n};\n\ntype FBOUpdateFunction = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({ read }: { read: THREE.Texture }) => void\n) => THREE.Texture;\n\ntype Return = [THREE.WebGLRenderTarget, FBOUpdateFunction];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [THREE.WebGLRenderTarget , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useSingleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n}: UseFboProps): Return => {\n   const renderTarget = useRef<THREE.WebGLRenderTarget>();\n\n   const resolution = useResolution(size, dpr);\n   renderTarget.current = useMemo(\n      () => new THREE.WebGLRenderTarget(resolution.x, resolution.y, FBO_OPTION),\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      []\n   );\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current?.setSize(resolution.x, resolution.y);\n      }\n   }, [resolution, isSizeUpdate]);\n\n   const updateRenderTarget: FBOUpdateFunction = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current!;\n         gl.setRenderTarget(fbo);\n         onBeforeRender && onBeforeRender({ read: fbo.texture });\n         gl.render(scene, camera);\n         gl.setRenderTarget(null);\n         gl.clear();\n         return fbo.texture;\n      },\n      [scene, camera]\n   );\n\n   return [renderTarget.current, updateRenderTarget];\n};\n","import * as THREE from \"three\";\nimport { useCallback, useLayoutEffect, useMemo, useRef } from \"react\";\nimport { FBO_OPTION } from \"./useSingleFBO\";\nimport { useResolution } from \"./useResolution\";\nimport { DoubleRenderTarget, UseFboProps } from \"./types\";\n\ninterface RenderTarget extends DoubleRenderTarget {\n   swap: () => void;\n}\n\ntype FBOUpdateFunction = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({\n      read,\n      write,\n   }: {\n      read: THREE.Texture;\n      write: THREE.Texture;\n   }) => void\n) => THREE.Texture;\n\ntype Return = [\n   { read: THREE.WebGLRenderTarget; write: THREE.WebGLRenderTarget },\n   FBOUpdateFunction\n];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [{read:THREE.WebGLRenderTarget,write:THREE.WebGLRenderTarget} , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useDoubleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n}: UseFboProps): Return => {\n   const renderTarget = useRef<RenderTarget>({\n      read: null,\n      write: null,\n      swap: function () {\n         let temp = this.read;\n         this.read = this.write;\n         this.write = temp;\n      },\n   });\n\n   const resolution = useResolution(size, dpr);\n   const initRenderTargets = useMemo(() => {\n      const read = new THREE.WebGLRenderTarget(\n         resolution.x,\n         resolution.y,\n         FBO_OPTION\n      );\n      const write = new THREE.WebGLRenderTarget(\n         resolution.x,\n         resolution.y,\n         FBO_OPTION\n      );\n      return { read, write };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, []);\n   renderTarget.current.read = initRenderTargets.read;\n   renderTarget.current.write = initRenderTargets.write;\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current.read?.setSize(resolution.x, resolution.y);\n         renderTarget.current.write?.setSize(resolution.x, resolution.y);\n      }\n   }, [resolution, isSizeUpdate]);\n\n   const updateRenderTarget: FBOUpdateFunction = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current;\n         gl.setRenderTarget(fbo.write);\n         onBeforeRender &&\n            onBeforeRender({\n               read: fbo.read!.texture,\n               write: fbo.write!.texture,\n            });\n         gl.render(scene, camera);\n         fbo.swap();\n         gl.setRenderTarget(null);\n         gl.clear();\n         return fbo.read?.texture as THREE.Texture;\n      },\n      [scene, camera]\n   );\n\n   return [\n      { read: renderTarget.current.read, write: renderTarget.current.write },\n      updateRenderTarget,\n   ];\n};\n","import * as THREE from \"three\";\nimport { useCallback, useRef } from \"react\";\n\n/**\n * @returns updatePointer frameで呼び出す更新関数を返す\n */\nexport const usePointer = () => {\n   const prevPointer = useRef(new THREE.Vector2(0, 0));\n   const diffPointer = useRef(new THREE.Vector2(0, 0));\n   const lastUpdateTime = useRef<number>(0);\n   const velocity = useRef(new THREE.Vector2(0, 0));\n   const isMoved = useRef(false);\n\n   const updatePointer = useCallback((currentPointer: THREE.Vector2) => {\n      const now = performance.now();\n      const current = currentPointer.clone();\n\n      // first frame\n      if (lastUpdateTime.current === 0) {\n         lastUpdateTime.current = now;\n         prevPointer.current = current;\n      }\n      const deltaTime = Math.max(1, now - lastUpdateTime.current);\n      lastUpdateTime.current = now;\n\n      // get velocity\n      velocity.current\n         .copy(current)\n         .sub(prevPointer.current)\n         .divideScalar(deltaTime);\n      const isUpdate = velocity.current.length() > 0;\n\n      //set prev temp pos\n      const prevTemp = isMoved.current ? prevPointer.current.clone() : current;\n      if (!isMoved.current && isUpdate) {\n         isMoved.current = true;\n      }\n      prevPointer.current = current;\n\n      return {\n         currentPointer: current,\n         prevPointer: prevTemp,\n         diffPointer: diffPointer.current.subVectors(current, prevTemp),\n         velocity: velocity.current,\n         isVelocityUpdate: isUpdate,\n      };\n   }, []);\n\n   return updatePointer;\n};\n","import { useCallback, useRef } from \"react\";\n\ntype Return<T> = [T, (params: Partial<T>) => void];\n\nexport const useParams = <T extends object>(params: T): Return<T> => {\n   const paramsRef = useRef(params);\n   const setParams = useCallback((updateParams: Partial<T>) => {\n      for (const key in updateParams) {\n         const paramKey = key as keyof T;\n         if (\n            paramKey in paramsRef.current &&\n            updateParams[paramKey] !== undefined &&\n            updateParams[paramKey] !== null\n         ) {\n            paramsRef.current[paramKey] = updateParams[paramKey]!;\n         } else {\n            console.error(\n               `\"${String(\n                  paramKey\n               )}\" does not exist in the params. or \"${String(\n                  paramKey\n               )}\" is null | undefined`\n            );\n         }\n      }\n   }, []);\n   return [paramsRef.current, setParams];\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { useDoubleFBO } from \"../utils/useDoubleFBO\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { usePointer } from \"../utils/usePointer\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\nimport { DoubleRenderTarget } from \"../utils/types\";\n\nexport type BrushParams = {\n   /** ブラシに適用するテクスチャー */\n   texture?: THREE.Texture;\n   /** size of the stamp, percentage of the size */\n   radius?: number;\n   /** opacity TODO*これバグってるいので修正 */\n   alpha?: number;\n   /** 滲み効果の強さ */\n   smudge?: number;\n   /** 拡散率。1にすると残り続ける */\n   dissipation?: number;\n   /** 拡大率 */\n   magnification?: number;\n   /** モーションブラーの強さ */\n   motionBlur?: number;\n   /** モーションブラーのサンプル数 これを高くするとパフォーマンスへの影響大 */\n   motionSample?: number;\n};\n\nexport type BrushObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: DoubleRenderTarget;\n};\n\nexport const useBrush = ({\n   size,\n}: {\n   size: Size;\n}): HooksReturn<BrushParams, BrushObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useDoubleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<BrushParams>({\n      texture: new THREE.Texture(),\n      radius: 0.0,\n      alpha: 0.0,\n      smudge: 0.0,\n      dissipation: 0.0,\n      magnification: 0.0,\n      motionBlur: 0.0,\n      motionSample: 10,\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: BrushParams) => {\n         const { gl, pointer } = props;\n\n         setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uRadius\", params.radius!);\n         setUniform(material, \"uAlpha\", params.alpha!);\n         setUniform(material, \"uSmudge\", params.smudge!);\n         setUniform(material, \"uDissipation\", params.dissipation!);\n         setUniform(material, \"uMagnification\", params.magnification!);\n         setUniform(material, \"uMotionBlur\", params.motionBlur!);\n         setUniform(material, \"uMotionSample\", params.motionSample!);\n\n         const { currentPointer, prevPointer, velocity } =\n            updatePointer(pointer);\n         setUniform(material, \"uMouse\", currentPointer);\n         setUniform(material, \"uPrevMouse\", prevPointer);\n         setUniform(material, \"uVelocity\", velocity);\n\n         const bufferTexture = updateRenderTarget(gl, ({ read }) => {\n            setUniform(material, \"uMap\", read);\n         });\n\n         return bufferTexture;\n      },\n      [material, updatePointer, updateRenderTarget, params, setParams]\n   );\n\n   return {\n      updateFx,\n      setParams,\n      fxObject: {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   };\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\n\nuniform vec3 uColor0;\nuniform vec3 uColor1;\n\nvoid main() {\n\tvec2 uv = vUv;\n\tvec4 texColor = texture2D(uTexture, uv);\n\tfloat grayscale = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n\tvec3 duotone = mix(uColor0, uColor1, grayscale);\n\tgl_FragColor = vec4(duotone, texColor.a);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\n\ntype TUniforms = {\n   uTexture: { value: THREE.Texture };\n   uColor0: { value: THREE.Color };\n   uColor1: { value: THREE.Color };\n};\n\nexport class MetamorphoseMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uColor0: { value: new THREE.Color(0xffffff) },\n               uColor1: { value: new THREE.Color(0x000000) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as MetamorphoseMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../utils/useSingleFBO\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\n\nexport type DuoToneParams = {\n   texture?: THREE.Texture;\n   color0?: THREE.Color;\n   color1?: THREE.Color;\n};\n\nexport type DuoToneObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const useDuoTone = ({\n   size,\n}: {\n   size: Size;\n}): HooksReturn<DuoToneParams, DuoToneObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<DuoToneParams>({\n      texture: new THREE.Texture(),\n      color0: new THREE.Color(0xffffff),\n      color1: new THREE.Color(0x000000),\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: DuoToneParams) => {\n         const { gl } = props;\n\n         setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uColor0\", params.color0!);\n         setUniform(material, \"uColor1\", params.color1!);\n\n         const bufferTexture = updateRenderTarget(gl);\n\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return {\n      updateFx,\n      setParams,\n      fxObject: {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   };\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nuniform sampler2D uMap;\nuniform float uRadius;\nuniform float uAlpha;\nuniform float uDissipation;\nuniform float uMagnification;\nuniform vec2 uResolution;\n\nuniform float uAspect;\nuniform vec2 uMouse;\nuniform vec2 uVelocity;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec2 st = vUv * 2.0 - 1.0; // UV座標を[-1, 1]の範囲に変換\n\n\tvec2 vel = uVelocity * uResolution;\n\n\t// buffer color\n\tvec4 bufferColor = texture2D(uMap, vUv) * uDissipation;\n\t\n\t//\tcolor\n\tvec3 color = vec3(vel * vec2(1, -1), 1.0 - pow(1.0 - min(1.0, length(vel)), 1.0));\n\t// vec3 color = vec3(1.0,1.0,1.0);\n\n\t// cursor\n\tvec2 nMouse = (uMouse + vec2(1.0)) * 0.5;\n\tvec2 cursor = vUv - nMouse;\n\tcursor.x *= uAspect;\n\n\t// radius\n\tfloat modifiedRadius = uRadius + (length(vel) * uMagnification);\n\tmodifiedRadius = max(0.0,modifiedRadius);\n\tfloat finalBrush = smoothstep(modifiedRadius,0.0,length(cursor)) * uAlpha;\n\n\t// mix buffer and current color\n\tbufferColor.rgb = mix(bufferColor.rgb, color, vec3(finalBrush));\n\n\tgl_FragColor = bufferColor;\n}","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useEffect, useMemo } from \"react\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\nimport { useResolution } from \"../utils/useResolution\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\nexport const useMesh = ({\n   scene,\n   size,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uMap: { value: null },\n               uResolution: { value: new THREE.Vector2(0, 0) },\n               uAspect: { value: 1 },\n               uRadius: { value: 0.0 },\n               uAlpha: { value: 0.0 },\n               uDissipation: { value: 0.0 },\n               uMagnification: { value: 0.0 },\n               uMouse: { value: new THREE.Vector2(0, 0) },\n               uVelocity: { value: new THREE.Vector2(0, 0) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size);\n\n   useEffect(() => {\n      setUniform(material, \"uAspect\", resolution.width / resolution.height);\n      setUniform(material, \"uResolution\", resolution.clone());\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material;\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { useDoubleFBO } from \"../utils/useDoubleFBO\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { usePointer } from \"../utils/usePointer\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\nimport { DoubleRenderTarget } from \"../utils/types\";\n\nexport type FlowmapParams = {\n   /** size of the stamp, percentage of the size */\n   radius?: number;\n   /** 拡大率 */\n   magnification?: number;\n   /** opacity */\n   alpha?: number;\n   /** 拡散率。1にすると残り続ける */\n   dissipation?: number;\n};\n\nexport type FlowmapObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: DoubleRenderTarget;\n};\n\nexport const useFlowmap = ({\n   size,\n}: {\n   size: Size;\n}): HooksReturn<FlowmapParams, FlowmapObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useDoubleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<FlowmapParams>({\n      radius: 0.0,\n      magnification: 0.0,\n      alpha: 0.0,\n      dissipation: 0.0,\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: FlowmapParams) => {\n         const { gl, pointer } = props;\n\n         setParams(updateParams);\n\n         setUniform(material, \"uRadius\", params.radius!);\n         setUniform(material, \"uAlpha\", params.alpha!);\n         setUniform(material, \"uDissipation\", params.dissipation!);\n         setUniform(material, \"uMagnification\", params.magnification!);\n\n         const { currentPointer, velocity } = updatePointer(pointer);\n         setUniform(material, \"uMouse\", currentPointer);\n         setUniform(material, \"uVelocity\", velocity);\n\n         const bufferTexture = updateRenderTarget(gl, ({ read }) => {\n            setUniform(material, \"uMap\", read);\n         });\n\n         return bufferTexture;\n      },\n      [material, updatePointer, updateRenderTarget, params, setParams]\n   );\n   return {\n      updateFx,\n      setParams,\n      fxObject: {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   };\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform float uTime;\nuniform sampler2D uTexture;\nuniform float timeStrength;\nuniform float distortionStrength;\nuniform float fogEdge0;\nuniform float fogEdge1;\nuniform vec3 fogColor;\nuniform int noiseOct; //noiseの振幅回数\nuniform int fbmOct; //fbmの振幅回数\n\nconst float per  = 0.5;\nconst float PI   = 3.1415926;\n\nfloat interpolate(float a, float b, float x){\n    float f = (1.0 - cos(x * PI)) * 0.5;\n    return a * (1.0 - f) + b * f;\n}\n\nfloat rnd(vec2 p){\n    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat irnd(vec2 p){\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tvec4 v = vec4(rnd(vec2(i.x,i.y)),rnd(vec2(i.x + 1.0,i.y)),rnd(vec2(i.x,i.y + 1.0)),rnd(vec2(i.x + 1.0, i.y + 1.0)));\n\treturn interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);\n}\n\nfloat noise(vec2 p, float time){\n\tfloat t = 0.0;\n\tfor(int i = 0; i < noiseOct; i++){\n\t\tfloat freq = pow(2.0, float(i));\n\t\tfloat amp  = pow(per, float(noiseOct - i));\n\t\tt += irnd(vec2(p.y / freq + time, p.x / freq + time)) * amp;\n\t}\n\treturn t;\n}\n\nfloat fbm(vec2 x, float time) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfloat sign = 1.0;\n\tfor (int i = 0; i < fbmOct; ++i) {\n\t\tv += a * noise(x, time * sign);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t\tsign *= -1.0;\n\t}\n\treturn v;\n}\n\nvoid main() {\n\tvec2 uv = vUv;\n\t\n\tfloat noiseMap = fbm(gl_FragCoord.xy ,uTime * timeStrength);\n\t\n\tfloat noiseTextureMap = noiseMap*2.0-1.0;\n\tuv += noiseTextureMap * distortionStrength;\n\tvec3 textureMap = texture2D(uTexture, uv).rgb;\n\n\tfloat edge0 = fogEdge0;\n\tfloat edge1 = fogEdge1;\n\tfloat blendValue = smoothstep(edge0, edge1, noiseMap);\n\n\tvec3 outputColor = blendValue * fogColor + (1.0 - blendValue) * textureMap;\n\tgl_FragColor = vec4(outputColor, 1.0);\n}\n\n\n","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTime: { value: 0.0 },\n               uTexture: { value: new THREE.Texture() },\n               timeStrength: { value: 0.0 },\n               distortionStrength: { value: 0.0 },\n               fogEdge0: { value: 0.0 },\n               fogEdge1: { value: 0.9 },\n               fogColor: { value: new THREE.Color(0xffffff) },\n               noiseOct: { value: 8 },\n               fbmOct: { value: 3 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../utils/useSingleFBO\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\n\nexport type FogProjectionParams = {\n   texture?: THREE.Texture;\n   timeStrength?: number;\n   distortionStrength?: number;\n   fogEdge0?: number;\n   fogEdge1?: number;\n   fogColor?: THREE.Color;\n   noiseOct?: number;\n   fbmOct?: number;\n};\n\nexport type FogProjectionObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const useFogProjection = ({\n   size,\n}: {\n   size: Size;\n}): HooksReturn<FogProjectionParams, FogProjectionObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<FogProjectionParams>({\n      texture: new THREE.Texture(),\n      timeStrength: 0.0,\n      distortionStrength: 0.0,\n      fogEdge0: 0.0,\n      fogEdge1: 0.9,\n      fogColor: new THREE.Color(0xffffff),\n      noiseOct: 8,\n      fbmOct: 3,\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: FogProjectionParams) => {\n         const { gl, clock } = props;\n         setParams(updateParams);\n         setUniform(material, \"uTime\", clock.getElapsedTime());\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"timeStrength\", params.timeStrength!);\n         setUniform(material, \"distortionStrength\", params.distortionStrength!);\n         setUniform(material, \"fogEdge0\", params.fogEdge0!);\n         setUniform(material, \"fogEdge1\", params.fogEdge1!);\n         setUniform(material, \"fogColor\", params.fogColor!);\n         setUniform(material, \"noiseOct\", params.noiseOct!);\n         setUniform(material, \"fbmOct\", params.fbmOct!);\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return {\n      updateFx,\n      setParams,\n      fxObject: {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   };\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform vec2 texelSize;\n\nvoid main () {\n\tvUv = uv;\n\tvL = vUv - vec2(texelSize.x, 0.0);\n\tvR = vUv + vec2(texelSize.x, 0.0);\n\tvT = vUv + vec2(0.0, texelSize.y);\n\tvB = vUv - vec2(0.0, texelSize.y);\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvoid main(){\n\tgl_FragColor = vec4(0.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/init.frag\";\n\nexport const useInitialMaterial = () => {\n   const initialMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      []\n   );\n\n   return initialMaterial as THREE.ShaderMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uVelocity;\nuniform sampler2D uSource;\nuniform vec2 texelSize;\nuniform float dt;\nuniform float dissipation;\n\nvoid main () {\n\tvec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n\tgl_FragColor = dissipation * texture2D(uSource, coord);\n\tgl_FragColor.a = 1.0;\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/advection.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   uSource: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n   dt: { value: number };\n   dissipation: { value: number };\n};\n\nexport class AdvectionMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useAdvectionMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: new THREE.Texture() },\n               uSource: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n               dt: { value: 0.0 },\n               dissipation: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as AdvectionMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvec2 sampleVelocity (in vec2 uv) {\n\tvec2 multiplier = vec2(1.0, 1.0);\n\tif (uv.x < 0.0) { uv.x = 0.0; multiplier.x = -1.0; }\n\tif (uv.x > 1.0) { uv.x = 1.0; multiplier.x = -1.0; }\n\tif (uv.y < 0.0) { uv.y = 0.0; multiplier.y = -1.0; }\n\tif (uv.y > 1.0) { uv.y = 1.0; multiplier.y = -1.0; }\n\treturn multiplier * texture2D(uVelocity, uv).xy;\n}\n\nvoid main () {\n\tfloat L = sampleVelocity(vL).x;\n\tfloat R = sampleVelocity(vR).x;\n\tfloat T = sampleVelocity(vT).y;\n\tfloat B = sampleVelocity(vB).y;\n\tfloat div = 0.5 * (R - L + T - B);\n\tgl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/divergence.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class DivergenceMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useDivergenceMaterial = () => {\n   const divergenceMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return divergenceMaterial as DivergenceMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uDivergence;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tfloat C = texture2D(uPressure, vUv).x;\n\tfloat divergence = texture2D(uDivergence, vUv).x;\n\tfloat pressure = (L + R + B + T - divergence) * 0.25;\n\tgl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/pressure.frag\";\n\ntype TUniforms = {\n   uPressure: { value: THREE.Texture };\n   uDivergence: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class PressureMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const usePressureMaterial = () => {\n   const pressureMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: null },\n               uDivergence: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return pressureMaterial as PressureMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvoid main () {\n\tfloat L = texture2D(uVelocity, vL).y;\n\tfloat R = texture2D(uVelocity, vR).y;\n\tfloat T = texture2D(uVelocity, vT).x;\n\tfloat B = texture2D(uVelocity, vB).x;\n\tfloat vorticity = R - L - T + B;\n\tgl_FragColor = vec4(vorticity, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/curl.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class CurlMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useCurlMaterial = () => {\n   const curlMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return curlMaterial as CurlMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\nuniform sampler2D uCurl;\nuniform float curl;\nuniform float dt;\n\nvoid main () {\n\tfloat T = texture2D(uCurl, vT).x;\n\tfloat B = texture2D(uCurl, vB).x;\n\tfloat C = texture2D(uCurl, vUv).x;\n\tvec2 force = vec2(abs(T) - abs(B), 0.0);\n\tforce *= 1.0 / length(force + 0.00001) * curl * C;\n\tvec2 vel = texture2D(uVelocity, vUv).xy;\n\tgl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/vorticity.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   uCurl: { value: THREE.Texture };\n   curl: { value: number };\n   dt: { value: number };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class VorticityMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useVorticityMaterial = () => {\n   const vorticityMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               uCurl: { value: null },\n               curl: { value: 0 },\n               dt: { value: 0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return vorticityMaterial as VorticityMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform float value;\n\nvoid main () {\n\tgl_FragColor = value * texture2D(uTexture, vUv);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/clear.frag\";\n\ntype TUniforms = {\n   uTexture: { value: THREE.Texture };\n   value: { value: number };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class ClearMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useClearMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               value: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as ClearMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uVelocity;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tvec2 velocity = texture2D(uVelocity, vUv).xy;\n\tvelocity.xy -= vec2(R - L, T - B);\n\tgl_FragColor = vec4(velocity, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/gradientSubtract.frag\";\n\ntype TUniforms = {\n   uPressure: { value: THREE.Texture };\n   uVelocity: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class GradientSubtractMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useGradientSubtractMaterial = () => {\n   const gradientSubtractMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: new THREE.Texture() },\n               uVelocity: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return gradientSubtractMaterial as GradientSubtractMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uTarget;\nuniform float aspectRatio;\nuniform vec3 color;\nuniform vec2 point;\nuniform float radius;\n\nvoid main () {\n\tvec2 nPoint = (point + vec2(1.0)) * 0.5;\n\tvec2 p = vUv - nPoint.xy;\n\tp.x *= aspectRatio;\n\tvec3 splat = exp(-dot(p, p) / radius) * color;\n\tvec3 base = texture2D(uTarget, vUv).xyz;\n\tgl_FragColor = vec4(base + splat, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/splat.frag\";\n\ntype TUniforms = {\n   uTarget: { value: THREE.Texture };\n   aspectRatio: { value: number };\n   color: { value: THREE.Vector3 };\n   point: { value: THREE.Vector2 };\n   radius: { value: number };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class SplatMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useSplateMaterial = () => {\n   const splatMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTarget: { value: new THREE.Texture() },\n               aspectRatio: { value: 0 },\n               color: { value: new THREE.Vector3() },\n               point: { value: new THREE.Vector2() },\n               radius: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return splatMaterial as SplatMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo } from \"react\";\nimport { useInitialMaterial } from \"./materials/useInitialMaterial\";\nimport {\n   AdvectionMaterial,\n   useAdvectionMaterial,\n} from \"./materials/useAdvectionMaterial\";\nimport {\n   DivergenceMaterial,\n   useDivergenceMaterial,\n} from \"./materials/useDivergenceMaterial\";\nimport {\n   PressureMaterial,\n   usePressureMaterial,\n} from \"./materials/usePressureMaterial\";\nimport { CurlMaterial, useCurlMaterial } from \"./materials/useCurlMaterial\";\nimport {\n   VorticityMaterial,\n   useVorticityMaterial,\n} from \"./materials/useVorticityMaterial\";\nimport { useResolution } from \"../utils/useResolution\";\nimport { ClearMaterial, useClearMaterial } from \"./materials/useClearMaterial\";\nimport {\n   GradientSubtractMaterial,\n   useGradientSubtractMaterial,\n} from \"./materials/useGradientSubtractMaterial\";\nimport { SplatMaterial, useSplateMaterial } from \"./materials/useSplatMaterial\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TMaterials =\n   | AdvectionMaterial\n   | DivergenceMaterial\n   | CurlMaterial\n   | PressureMaterial\n   | ClearMaterial\n   | GradientSubtractMaterial\n   | SplatMaterial;\n\nexport type FruidMaterials = {\n   vorticityMaterial: VorticityMaterial;\n   curlMaterial: CurlMaterial;\n   advectionMaterial: AdvectionMaterial;\n   divergenceMaterial: DivergenceMaterial;\n   pressureMaterial: PressureMaterial;\n   clearMaterial: ClearMaterial;\n   gradientSubtractMaterial: GradientSubtractMaterial;\n   splatMaterial: SplatMaterial;\n};\ntype TUseMeshReturnType = [FruidMaterials, (material: TMaterials) => void];\n\n/**\n * Returns the material update function in the second argument\n */\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}): TUseMeshReturnType => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const initialMaterial = useInitialMaterial();\n   const updateMaterial = initialMaterial.clone();\n   const curlMaterial = useCurlMaterial();\n   const vorticityMaterial = useVorticityMaterial();\n   const advectionMaterial = useAdvectionMaterial();\n   const divergenceMaterial = useDivergenceMaterial();\n   const pressureMaterial = usePressureMaterial();\n   const clearMaterial = useClearMaterial();\n   const gradientSubtractMaterial = useGradientSubtractMaterial();\n   const splatMaterial = useSplateMaterial();\n   const materials = useMemo(\n      () => ({\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      }),\n      [\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      ]\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(\n         materials.splatMaterial,\n         \"aspectRatio\",\n         resolution.x / resolution.y\n      );\n      for (const material of Object.values(materials)) {\n         setUniform(\n            material,\n            \"texelSize\",\n            new THREE.Vector2(1.0 / resolution.x, 1.0 / resolution.y)\n         );\n      }\n   }, [resolution, materials]);\n\n   const mesh = useAddMesh(scene, geometry, initialMaterial);\n   useEffect(() => {\n      initialMaterial.dispose();\n      mesh.material = updateMaterial;\n   }, [initialMaterial, mesh, updateMaterial]);\n\n   const setMeshMaterial = useCallback(\n      (material: TMaterials) => {\n         mesh.material = material;\n         mesh.material.needsUpdate = true;\n      },\n      [mesh]\n   );\n\n   return [materials, setMeshMaterial];\n};\n","import * as THREE from \"three\";\nimport { FruidMaterials, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { useDoubleFBO } from \"../utils/useDoubleFBO\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { usePointer } from \"../utils/usePointer\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../utils/useSingleFBO\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\nimport { DoubleRenderTarget } from \"../utils/types\";\n\nexport type FruidParams = {\n   density_dissipation?: number;\n   velocity_dissipation?: number;\n   velocity_acceleration?: number;\n   pressure_dissipation?: number;\n   pressure_iterations?: number;\n   curl_strength?: number;\n   splat_radius?: number;\n   fruid_color?: ((velocity: THREE.Vector2) => THREE.Vector3) | THREE.Vector3;\n};\n\nexport type FruidObject = {\n   scene: THREE.Scene;\n   materials: FruidMaterials;\n   camera: THREE.Camera;\n   renderTarget: {\n      velocity: DoubleRenderTarget;\n      density: DoubleRenderTarget;\n      curl: THREE.WebGLRenderTarget;\n      divergence: THREE.WebGLRenderTarget;\n      pressure: DoubleRenderTarget;\n   };\n};\n\nexport const useFruid = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<FruidParams, FruidObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const [materials, setMeshMaterial] = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n\n   const fboProps = useMemo(\n      () => ({\n         scene,\n         camera,\n         size,\n         dpr,\n      }),\n      [scene, camera, size, dpr]\n   );\n   const [velocityFBO, updateVelocityFBO] = useDoubleFBO(fboProps);\n   const [densityFBO, updateDensityFBO] = useDoubleFBO(fboProps);\n   const [curlFBO, updateCurlFBO] = useSingleFBO(fboProps);\n   const [divergenceFBO, updateDivergenceFBO] = useSingleFBO(fboProps);\n   const [pressureFBO, updatePressureFBO] = useDoubleFBO(fboProps);\n\n   const lastTime = useRef(0);\n   const scaledDiffVec = useRef(new THREE.Vector2(0, 0));\n   const spaltVec = useRef(new THREE.Vector3(0, 0, 0));\n\n   const [params, setParams] = useParams<FruidParams>({\n      density_dissipation: 0.0,\n      velocity_dissipation: 0.0,\n      velocity_acceleration: 0.0,\n      pressure_dissipation: 0.0,\n      pressure_iterations: 20,\n      curl_strength: 0.0,\n      splat_radius: 0.001,\n      fruid_color: new THREE.Vector3(1.0, 1.0, 1.0),\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: FruidParams) => {\n         const { gl, pointer, clock, size } = props;\n\n         setParams(updateParams);\n\n         if (lastTime.current === 0) {\n            lastTime.current = clock.getElapsedTime();\n         }\n         const dt = Math.min(\n            (clock.getElapsedTime() - lastTime.current) / 3,\n            0.02\n         );\n         lastTime.current = clock.getElapsedTime();\n\n         // update velocity\n         const velocityTex = updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", read);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(materials.advectionMaterial, \"dt\", dt);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.velocity_dissipation!\n            );\n         });\n\n         // update density\n         const densityTex = updateDensityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", velocityTex);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.density_dissipation!\n            );\n         });\n\n         // update splatting\n         const { currentPointer, diffPointer, isVelocityUpdate, velocity } =\n            updatePointer(pointer);\n         if (isVelocityUpdate) {\n            updateVelocityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               setUniform(materials.splatMaterial, \"point\", currentPointer);\n               const scaledDiff = diffPointer.multiply(\n                  scaledDiffVec.current\n                     .set(size.width, size.height)\n                     .multiplyScalar(params.velocity_acceleration!)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"color\",\n                  spaltVec.current.set(scaledDiff.x, scaledDiff.y, 1.0)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"radius\",\n                  params.splat_radius!\n               );\n            });\n            updateDensityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               const color: THREE.Vector3 =\n                  typeof params.fruid_color === \"function\"\n                     ? params.fruid_color(velocity)\n                     : params.fruid_color!;\n               setUniform(materials.splatMaterial, \"color\", color);\n            });\n         }\n\n         // update curl\n         const curlTex = updateCurlFBO(gl, () => {\n            setMeshMaterial(materials.curlMaterial);\n            setUniform(materials.curlMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update vorticity\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.vorticityMaterial);\n            setUniform(materials.vorticityMaterial, \"uVelocity\", read);\n            setUniform(materials.vorticityMaterial, \"uCurl\", curlTex);\n            setUniform(\n               materials.vorticityMaterial,\n               \"curl\",\n               params.curl_strength!\n            );\n            setUniform(materials.vorticityMaterial, \"dt\", dt);\n         });\n\n         // update divergence\n         const divergenceTex = updateDivergenceFBO(gl, () => {\n            setMeshMaterial(materials.divergenceMaterial);\n            setUniform(materials.divergenceMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update pressure\n         updatePressureFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.clearMaterial);\n            setUniform(materials.clearMaterial, \"uTexture\", read);\n            setUniform(\n               materials.clearMaterial,\n               \"value\",\n               params.pressure_dissipation!\n            );\n         });\n\n         // solve pressure iterative (Gauss-Seidel)\n         setMeshMaterial(materials.pressureMaterial);\n         setUniform(materials.pressureMaterial, \"uDivergence\", divergenceTex);\n         let pressureTexTemp: THREE.Texture;\n         for (let i = 0; i < params.pressure_iterations!; i++) {\n            pressureTexTemp = updatePressureFBO(gl, ({ read }) => {\n               setUniform(materials.pressureMaterial, \"uPressure\", read);\n            });\n         }\n\n         // update gradienSubtract\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.gradientSubtractMaterial);\n            setUniform(\n               materials.gradientSubtractMaterial,\n               \"uPressure\",\n               pressureTexTemp\n            );\n            setUniform(materials.gradientSubtractMaterial, \"uVelocity\", read);\n         });\n\n         return densityTex;\n      },\n      [\n         materials,\n         setMeshMaterial,\n         updateCurlFBO,\n         updateDensityFBO,\n         updateDivergenceFBO,\n         updatePointer,\n         updatePressureFBO,\n         updateVelocityFBO,\n         setParams,\n         params,\n      ]\n   );\n   return {\n      updateFx,\n      setParams,\n      fxObject: {\n         scene: scene,\n         materials: materials,\n         camera: camera,\n         renderTarget: {\n            velocity: velocityFBO,\n            density: densityFBO,\n            curl: curlFBO,\n            divergence: divergenceFBO,\n            pressure: pressureFBO,\n         },\n      },\n   };\n};\n","import { useEffect, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\n\ntype TcreateMesh = {\n   scale: number;\n   max: number;\n   texture?: THREE.Texture;\n   scene: THREE.Scene;\n};\nexport const useMesh = ({ scale, max, texture, scene }: TcreateMesh) => {\n   const meshArr = useRef<THREE.Mesh[]>([]);\n   const geometry = useMemo(\n      () => new THREE.PlaneGeometry(scale, scale),\n      [scale]\n   );\n   const material = useMemo(\n      () =>\n         new THREE.MeshBasicMaterial({\n            map: texture ?? null,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      [texture]\n   );\n   useEffect(() => {\n      for (let i = 0; i < max; i++) {\n         const mesh = new THREE.Mesh(geometry.clone(), material.clone());\n         mesh.rotateZ(2 * Math.PI * Math.random());\n         mesh.visible = false;\n         scene.add(mesh);\n         meshArr.current.push(mesh);\n      }\n   }, [geometry, material, scene, max]);\n   return meshArr.current;\n};\n","import { useCallback, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../utils/useSingleFBO\";\nimport { usePointer } from \"../utils/usePointer\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\n\nexport type RippleParams = {\n   /** rippleが出現する頻度,default:0.01 */\n   frequency?: number;\n   /** rippleの回転,default:0.01 */\n   rotation?: number;\n   /** rippleがフェードアウトするスピード,default:0.9 */\n   fadeout_speed?: number;\n   /** rippleの拡大率,default:0.15 */\n   scale?: number;\n   /** rippleの透明度,default:0.6 */\n   alpha?: number;\n};\n\nexport type RippleObject = {\n   scene: THREE.Scene;\n   meshArr: THREE.Mesh[];\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\ntype UseRipple = {\n   /** texture applied to ripple */\n   texture: THREE.Texture;\n   /** ripple size, default:64 */\n   scale?: number;\n   /** ripple max length, default:100 */\n   max?: number;\n};\n\nexport const useRipple = ({\n   texture,\n   scale = 64,\n   max = 100,\n   size,\n}: {\n   /** texture applied to ripple */\n   texture: THREE.Texture;\n   /** ripple size, default:64 */\n   scale?: number;\n   /** ripple max length, default:100 */\n   max?: number;\n   size: Size;\n}): HooksReturn<RippleParams, RippleObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const meshArr = useMesh({\n      scale: scale,\n      max: max,\n      texture,\n      scene,\n   });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<RippleParams>({\n      frequency: 0.01,\n      rotation: 0.01,\n      fadeout_speed: 0.9,\n      scale: 0.15,\n      alpha: 0.6,\n   });\n\n   const currentWave = useRef(0);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: RippleParams) => {\n         const { gl, pointer, size } = props;\n\n         setParams(updateParams);\n\n         const { currentPointer, diffPointer } = updatePointer(pointer);\n         if (params.frequency! < diffPointer.length()) {\n            const mesh = meshArr[currentWave.current];\n            mesh.visible = true;\n            mesh.position.set(\n               currentPointer.x * (size.width / 2),\n               currentPointer.y * (size.height / 2),\n               0\n            );\n            mesh.scale.x = mesh.scale.y = 0.0;\n            (mesh.material as THREE.MeshBasicMaterial).opacity = params.alpha!;\n            currentWave.current = (currentWave.current + 1) % max;\n         }\n         meshArr.forEach((mesh) => {\n            if (mesh.visible) {\n               const material = mesh.material as THREE.MeshBasicMaterial;\n               mesh.rotation.z += params.rotation!;\n               material.opacity *= params.fadeout_speed!;\n               mesh.scale.x =\n                  params.fadeout_speed! * mesh.scale.x + params.scale!;\n               mesh.scale.y = mesh.scale.x;\n               if (material.opacity < 0.002) mesh.visible = false;\n            }\n         });\n\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, meshArr, updatePointer, max, params, setParams]\n   );\n   return {\n      updateFx,\n      setParams,\n      fxObject: {\n         scene: scene,\n         camera: camera,\n         meshArr: meshArr,\n         renderTarget: renderTarget,\n      },\n   };\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvoid main(){\n\tgl_FragColor = vec4(0.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/init.frag\";\n\nexport const useInitialMaterial = () => {\n   const initialMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      []\n   );\n\n   return initialMaterial as THREE.ShaderMaterial;\n};\n","precision highp float;\n\nuniform float viscosity;\nuniform float forceRadius;\nuniform float forceCoefficient;\nuniform vec2 resolution;\nuniform sampler2D dataTex;\nuniform vec2 pointerPos;\nuniform vec2 beforePointerPos;\n\n#pragma glslify: map            = require('./map.glsl')\n#pragma glslify: samplePressure = require('./samplePressure.glsl')\n#pragma glslify: sampleVelocity = require('./sampleVelocity.glsl')\n\nvarying vec2 vUv;\n\nvoid main(){\n\tvec2 r = resolution;\n\tvec2 uv = gl_FragCoord.xy / r;\n\tvec4 data = texture2D(dataTex, uv);\n\tvec2 v = data.xy;\n\n\tvec2 offsetX = vec2(1.0, 0.0);\n\tvec2 offsetY = vec2(0.0, 1.0);\n\n\t// 上下左右の圧力\n\tfloat pLeft   = samplePressure(dataTex, (gl_FragCoord.xy - offsetX) / r, r);\n\tfloat pRight  = samplePressure(dataTex, (gl_FragCoord.xy + offsetX) / r, r);\n\tfloat pTop    = samplePressure(dataTex, (gl_FragCoord.xy - offsetY) / r, r);\n\tfloat pBottom = samplePressure(dataTex, (gl_FragCoord.xy + offsetY) / r, r);\n\n\t// マウス\n\tvec2 mPos = 0.5 * (pointerPos + 1.0) * r;\n\tvec2 mPPos = 0.5 * (beforePointerPos + 1.0) * r;\n\tvec2 mouseV = mPos - mPPos;\n\tfloat len = length(mPos - uv * r) / forceRadius;\n\tfloat d = clamp(1.0 - len, 0.0, 1.0) * length(mouseV) * forceCoefficient;\n\tvec2 mforce = d * normalize(mPos - uv * r + mouseV);\n\n\tv += vec2(pRight - pLeft, pBottom - pTop) * 0.5;\n\tv += mforce;\n\tv *= viscosity;\n\n\tgl_FragColor = vec4(v, data.zw);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/velocity.frag\";\n\ntype TUniforms = {\n   resolution: { value: THREE.Vector2 };\n   viscosity: { value: number };\n   forceRadius: { value: number };\n   forceCoefficient: { value: number };\n   dataTex: { value: THREE.Texture };\n   pointerPos: { value: THREE.Vector2 };\n   beforePointerPos: { value: THREE.Vector2 };\n};\n\nexport class VelocityMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useVelocityMaterial = () => {\n   const velocityMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               resolution: { value: new THREE.Vector2() },\n               dataTex: { value: null },\n               pointerPos: { value: null },\n               beforePointerPos: { value: null },\n               viscosity: { value: 0.0 },\n               forceRadius: { value: 0.0 },\n               forceCoefficient: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return velocityMaterial as VelocityMaterial;\n};\n","precision highp float;\n\nuniform float attenuation;\nuniform vec2 resolution;\nuniform sampler2D dataTex;\n\n#pragma glslify: sampleVelocity = require('./sampleVelocity.glsl')\n#pragma glslify: samplePressure = require('./samplePressure.glsl')\n\nvarying vec2 vUv;\n\nvec2 bilerpVelocity(sampler2D tex, vec2 p, vec2 resolution) {\n\tvec4 ij; // i0, j0, i1, j1\n\tij.xy = floor(p - 0.5) + 0.5;\n\tij.zw = ij.xy + 1.0;\n\n\tvec4 uv = ij / resolution.xyxy;\n\tvec2 d11 = sampleVelocity(tex, uv.xy, resolution);\n\tvec2 d21 = sampleVelocity(tex, uv.zy, resolution);\n\tvec2 d12 = sampleVelocity(tex, uv.xw, resolution);\n\tvec2 d22 = sampleVelocity(tex, uv.zw, resolution);\n\n\tvec2 a = p - ij.xy;\n\n\treturn mix(mix(d11, d21, a.x), mix(d12, d22, a.x), a.y);\n}\n\nvoid main(){\n\tvec2 r = resolution;\n\tvec2 p = gl_FragCoord.xy - sampleVelocity(dataTex, gl_FragCoord.xy / r, r);\n\n\tgl_FragColor = vec4(bilerpVelocity(dataTex, p, r) * attenuation, samplePressure(dataTex, gl_FragCoord.xy / r, r), 0.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/advection.frag\";\n\ntype TUniforms = {\n   resolution: { value: THREE.Vector2 };\n   dataTex: { value: THREE.Texture };\n   attenuation: { value: number };\n};\n\nexport class AdvectionMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useAdvectionMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               resolution: { value: new THREE.Vector2(0, 0) },\n               dataTex: { value: null },\n               attenuation: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as AdvectionMaterial;\n};\n","precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D dataTex;\n\n#pragma glslify: sampleVelocity = require('./sampleVelocity.glsl')\n\nvoid main(){\n\tvec2 r = resolution;\n\tvec4 data = texture2D(dataTex, gl_FragCoord.xy / r);\n\n\tvec2 offsetX = vec2(1.0, 0.0);\n\tvec2 offsetY = vec2(0.0, 1.0);\n\n\t// 上下左右の速度\n\tvec2 vLeft   = sampleVelocity(dataTex, (gl_FragCoord.xy - offsetX) / r, r);\n\tvec2 vRight  = sampleVelocity(dataTex, (gl_FragCoord.xy + offsetX) / r, r);\n\tvec2 vTop    = sampleVelocity(dataTex, (gl_FragCoord.xy - offsetY) / r, r);\n\tvec2 vBottom = sampleVelocity(dataTex, (gl_FragCoord.xy + offsetY) / r, r);\n\n\tfloat divergence = ((vRight.x - vLeft.x) + (vBottom.y - vTop.y)) * 0.5;\n\n\tgl_FragColor = vec4(data.xy, data.z, divergence);\n\n}\n\n","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/divergence.frag\";\n\ntype TUniforms = {\n   resolution: { value: THREE.Vector2 };\n   dataTex: { value: THREE.Texture };\n};\n\nexport class DivergenceMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useDivergenceMaterial = () => {\n   const divergenceMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               resolution: { value: new THREE.Vector2() },\n               dataTex: { value: null },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return divergenceMaterial as DivergenceMaterial;\n};\n","precision highp float;\n\nuniform float alpha;\nuniform float beta;\nuniform vec2 resolution;\nuniform sampler2D dataTex;\n\n#pragma glslify: samplePressure = require('./samplePressure.glsl')\n\nvoid main(){\n\tvec2 r = resolution;\n\tvec4 data = texture2D(dataTex, gl_FragCoord.xy / r);\n\n\t// 上下左右の圧力\n\tfloat pLeft   = samplePressure(dataTex, (gl_FragCoord.xy - vec2(1.0, 0.0)) / r, r);\n\tfloat pRight  = samplePressure(dataTex, (gl_FragCoord.xy + vec2(1.0, 0.0)) / r, r);\n\tfloat pTop    = samplePressure(dataTex, (gl_FragCoord.xy - vec2(0.0, 1.0)) / r, r);\n\tfloat pBottom = samplePressure(dataTex, (gl_FragCoord.xy + vec2(0.0, 1.0)) / r, r);\n\n\tfloat divergence = data.w;\n\tfloat pressure = (divergence * alpha + (pLeft + pRight + pTop + pBottom)) * 0.25 * beta;\n\tgl_FragColor = vec4(data.xy, pressure, divergence);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/pressure.frag\";\n\ntype TUniforms = {\n   resolution: { value: THREE.Vector2 };\n   dataTex: { value: THREE.Texture };\n   alpha: { value: number };\n   beta: { value: number };\n};\n\nexport class PressureMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const usePressureMaterial = () => {\n   const pressureMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               resolution: { value: new THREE.Vector2() },\n               dataTex: { value: null },\n               alpha: { value: 0.0 },\n               beta: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return pressureMaterial as PressureMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo } from \"react\";\nimport { useInitialMaterial } from \"./materials/useInitialMaterial\";\nimport {\n   VelocityMaterial,\n   useVelocityMaterial,\n} from \"./materials/useVelocityMaterial\";\nimport {\n   AdvectionMaterial,\n   useAdvectionMaterial,\n} from \"./materials/useAdvectionMaterial\";\nimport {\n   DivergenceMaterial,\n   useDivergenceMaterial,\n} from \"./materials/useDivergenceMaterial\";\nimport {\n   PressureMaterial,\n   usePressureMaterial,\n} from \"./materials/usePressureMaterial\";\nimport { useResolution } from \"../utils/useResolution\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TMaterials =\n   | VelocityMaterial\n   | AdvectionMaterial\n   | DivergenceMaterial\n   | PressureMaterial;\n\nexport type SimpleFruidMaterials = {\n   velocityMaterial: VelocityMaterial;\n   advectionMaterial: AdvectionMaterial;\n   divergenceMaterial: DivergenceMaterial;\n   pressureMaterial: PressureMaterial;\n};\n\ntype TUseMeshReturnType = [\n   SimpleFruidMaterials,\n   (material: TMaterials) => void\n];\n\nexport const useMesh = ({\n   scene,\n   size,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n}): TUseMeshReturnType => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const initialMaterial = useInitialMaterial();\n   const updateMaterial = initialMaterial.clone();\n   const velocityMaterial = useVelocityMaterial();\n   const advectionMaterial = useAdvectionMaterial();\n   const divergenceMaterial = useDivergenceMaterial();\n   const pressureMaterial = usePressureMaterial();\n   const materials = useMemo(\n      () => ({\n         velocityMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n      }),\n      [\n         velocityMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n      ]\n   );\n\n   const resolution = useResolution(size);\n   useEffect(() => {\n      for (const material of Object.values(materials)) {\n         setUniform(material, \"resolution\", resolution);\n      }\n   }, [resolution, materials]);\n\n   const mesh = useAddMesh(scene, geometry, initialMaterial);\n   useEffect(() => {\n      initialMaterial.dispose();\n      mesh.material = updateMaterial;\n   }, [initialMaterial, mesh, updateMaterial]);\n\n   const setMeshMaterial = useCallback(\n      (material: TMaterials) => {\n         mesh.material = material;\n         mesh.material.needsUpdate = true;\n      },\n      [mesh]\n   );\n\n   return [materials, setMeshMaterial];\n};\n","import * as THREE from \"three\";\nimport { SimpleFruidMaterials, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { useDoubleFBO } from \"../utils/useDoubleFBO\";\nimport { useCallback, useMemo } from \"react\";\nimport { usePointer } from \"../utils/usePointer\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { useParams } from \"../utils/useParams\";\nimport { HooksReturn } from \"../types\";\nimport { DoubleRenderTarget } from \"../utils/types\";\n\nexport type SimpleFruidParams = {\n   /** 圧力のヤコビ法の計算回数 */\n   pressure_iterations?: number;\n   /** 圧力のステップごとの減衰値 */\n   attenuation?: number;\n   /** 圧力計算時の係数 */\n   alpha?: number;\n   /** 圧力計算時の係数 */\n   beta?: number;\n   /** 粘度 */\n   viscosity?: number;\n   /** 力を加える円の半径 */\n   forceRadius?: number;\n   /** 速度の係数 */\n   forceCoefficient?: number;\n};\n\nexport type SimpleFruidObject = {\n   scene: THREE.Scene;\n   materials: SimpleFruidMaterials;\n   camera: THREE.Camera;\n   renderTarget: DoubleRenderTarget;\n};\n\nexport const useSimpleFruid = ({\n   size,\n}: {\n   size: Size;\n}): HooksReturn<SimpleFruidParams, SimpleFruidObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const [materials, setMeshMaterial] = useMesh({ scene, size });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n\n   const [renderTarget, updateRenderTarget] = useDoubleFBO({\n      scene,\n      camera,\n      size,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] = useParams<SimpleFruidParams>({\n      pressure_iterations: 20,\n      attenuation: 1.0,\n      alpha: 1.0,\n      beta: 1.0,\n      viscosity: 0.99,\n      forceRadius: 90,\n      forceCoefficient: 1.0,\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: SimpleFruidParams) => {\n         const { gl, pointer } = props;\n\n         setParams(updateParams);\n\n         setUniform(\n            materials.advectionMaterial,\n            \"attenuation\",\n            params.attenuation!\n         );\n         setUniform(materials.pressureMaterial, \"alpha\", params.alpha!);\n         setUniform(materials.pressureMaterial, \"beta\", params.beta!);\n         setUniform(materials.velocityMaterial, \"viscosity\", params.viscosity!);\n         setUniform(\n            materials.velocityMaterial,\n            \"forceRadius\",\n            params.forceRadius!\n         );\n         setUniform(\n            materials.velocityMaterial,\n            \"forceCoefficient\",\n            params.forceCoefficient!\n         );\n\n         // update divergence\n         updateRenderTarget(gl, ({ read }) => {\n            setMeshMaterial(materials.divergenceMaterial);\n            setUniform(materials.divergenceMaterial, \"dataTex\", read);\n         });\n\n         // update pressure\n         const solverIteration = params.pressure_iterations!;\n         for (let i = 0; i < solverIteration; i++) {\n            updateRenderTarget(gl, ({ read }) => {\n               setMeshMaterial(materials.pressureMaterial);\n               setUniform(materials.pressureMaterial, \"dataTex\", read);\n            });\n         }\n\n         // update velocity\n         const { currentPointer, prevPointer } = updatePointer(pointer);\n         setUniform(materials.velocityMaterial, \"pointerPos\", currentPointer);\n         setUniform(\n            materials.velocityMaterial,\n            \"beforePointerPos\",\n            prevPointer\n         );\n         updateRenderTarget(gl, ({ read }) => {\n            setMeshMaterial(materials.velocityMaterial);\n            setUniform(materials.velocityMaterial, \"dataTex\", read);\n         });\n\n         // update advection\n         const outPutTexture = updateRenderTarget(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"dataTex\", read);\n         });\n\n         return outPutTexture;\n      },\n      [\n         materials,\n         setMeshMaterial,\n         updatePointer,\n         updateRenderTarget,\n         setParams,\n         params,\n      ]\n   );\n   return {\n      updateFx,\n      setParams,\n      fxObject: {\n         scene: scene,\n         materials: materials,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   };\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform vec2 uResolution;\nuniform vec2 uImageResolution;\n\nuniform sampler2D uTexture0;\nuniform sampler2D uTexture1;\nuniform sampler2D noise;\nuniform float noiseStrength;\nuniform float progress;\nuniform float dirX;\nuniform float dirY;\n\nvoid main() {\n\tvec2 bgRatio=vec2(\n\t\tmin((uResolution.x/uResolution.y)/(uImageResolution.x/uImageResolution.y),1.),\n\t\tmin((uResolution.y/uResolution.x)/(uImageResolution.y/uImageResolution.x),1.)\n\t);\n\tvec2 uv=vec2(\n\t\tvUv.x*bgRatio.x+(1.-bgRatio.x)*.5,\n\t\tvUv.y*bgRatio.y+(1.-bgRatio.y)*.5\n\t);\n\n\t// noise\n\tvec2 noiseMap = texture2D(noise, uv).rg;\n\tnoiseMap=noiseMap*2.0-1.0;\n\tuv += noiseMap * noiseStrength;\n\n\t// uvをセンター基準に\n\tvec2 centeredUV = uv - vec2(0.5);\n\t\n\t//texture 0\n\tfloat xOffsetTexture0 = 0.5 - dirX * progress;\n\tfloat yOffsetTexture0 = 0.5 - dirY * progress;\n\tvec2 samplePosTexture0 = vec2(xOffsetTexture0, yOffsetTexture0) + centeredUV;\n\n\t//texture 1\n\tfloat xOffsetTexture1 = 0.5 + dirX * (1.0 - progress);\n\tfloat yOffsetTexture1 = 0.5 + dirY * (1.0 - progress);\n\tvec2 samplePosTexture1 = vec2(xOffsetTexture1, yOffsetTexture1) + centeredUV;\n\n\tvec4 color0 = texture2D(uTexture0, samplePosTexture0);\n\tvec4 color1 = texture2D(uTexture1, samplePosTexture1);\n\n\tgl_FragColor = mix(color0, color1, progress);\n\n}","import { useEffect, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useResolution } from \"../utils/useResolution\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TUniforms = {\n   uResolution: { value: THREE.Vector2 };\n   uImageResolution: { value: THREE.Vector2 };\n   uTexture0: { value: THREE.Texture };\n   uTexture1: { value: THREE.Texture };\n   noise: { value: THREE.Texture };\n   noiseStrength: { value: number };\n   progress: { value: number };\n   dirX: { value: number };\n   dirY: { value: number };\n};\n\nexport class MetamorphoseMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uResolution: { value: new THREE.Vector2() },\n               uImageResolution: { value: new THREE.Vector2() },\n               uTexture0: { value: new THREE.Texture() },\n               uTexture1: { value: new THREE.Texture() },\n               noise: { value: new THREE.Texture() },\n               noiseStrength: { value: 0.0 },\n               progress: { value: 0.0 },\n               dirX: { value: 0.0 },\n               dirY: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size);\n   useEffect(() => {\n      material.uniforms.uResolution.value = resolution.clone();\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material as MetamorphoseMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../utils/useSingleFBO\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\n\nexport type TransitionBgParams = {\n   texture0?: THREE.Texture;\n   texture1?: THREE.Texture;\n   imageResolution?: THREE.Vector2;\n   noise?: THREE.Texture;\n   noiseStrength?: number;\n   progress?: number;\n   dir?: THREE.Vector2;\n};\n\nexport type TransitionBgObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const useTransitionBg = ({\n   size,\n}: {\n   size: Size;\n}): HooksReturn<TransitionBgParams, TransitionBgObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size });\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<TransitionBgParams>({\n      texture0: new THREE.Texture(),\n      texture1: new THREE.Texture(),\n      imageResolution: new THREE.Vector2(0, 0),\n      noise: new THREE.Texture(),\n      noiseStrength: 0.0,\n      progress: 0.0,\n      dir: new THREE.Vector2(0, 0),\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: TransitionBgParams) => {\n         const { gl } = props;\n\n         setParams(updateParams);\n\n         setUniform(material, \"uTexture0\", params.texture0!);\n         setUniform(material, \"uTexture1\", params.texture1!);\n         setUniform(material, \"uImageResolution\", params.imageResolution!);\n         setUniform(material, \"noise\", params.noise!);\n         setUniform(material, \"noiseStrength\", params.noiseStrength!);\n         setUniform(material, \"progress\", params.progress!);\n         setUniform(material, \"dirX\", params.dir!.x);\n         setUniform(material, \"dirY\", params.dir!.y);\n\n         const bufferTexture = updateRenderTarget(gl);\n\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, params, setParams]\n   );\n   return {\n      updateFx,\n      setParams,\n      fxObject: {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   };\n};\n"],"names":["main_default","useResolution","size","dpr","_width","_height","useMemo","THREE","useAddMesh","scene","geometry","material","mesh","useEffect","setUniform","key","value","useMesh","vertexShader","fragmentShader","resolution","getCameraProps","width","height","frustumSize","aspect","w","h","useCamera","near","far","FBO_OPTION","useSingleFBO","camera","isSizeUpdate","renderTarget","useRef","useLayoutEffect","_a","updateRenderTarget","useCallback","gl","onBeforeRender","fbo","useDoubleFBO","temp","initRenderTargets","read","write","_b","usePointer","prevPointer","diffPointer","lastUpdateTime","velocity","isMoved","currentPointer","now","current","deltaTime","isUpdate","prevTemp","useParams","params","paramsRef","setParams","updateParams","paramKey","useBrush","updatePointer","props","pointer","useDuoTone","useFlowmap","useFogProjection","clock","init_default","useInitialMaterial","advection_default","useAdvectionMaterial","divergence_default","useDivergenceMaterial","pressure_default","usePressureMaterial","curl_default","useCurlMaterial","vorticity_default","useVorticityMaterial","clear_default","useClearMaterial","gradientSubtract_default","useGradientSubtractMaterial","splat_default","useSplateMaterial","initialMaterial","updateMaterial","curlMaterial","vorticityMaterial","advectionMaterial","divergenceMaterial","pressureMaterial","clearMaterial","gradientSubtractMaterial","splatMaterial","materials","setMeshMaterial","useFruid","fboProps","velocityFBO","updateVelocityFBO","densityFBO","updateDensityFBO","curlFBO","updateCurlFBO","divergenceFBO","updateDivergenceFBO","pressureFBO","updatePressureFBO","lastTime","scaledDiffVec","spaltVec","dt","velocityTex","densityTex","isVelocityUpdate","scaledDiff","color","curlTex","divergenceTex","pressureTexTemp","i","scale","max","texture","meshArr","useRipple","currentWave","velocity_default","useVelocityMaterial","velocityMaterial","useSimpleFruid","solverIteration","useTransitionBg"],"mappings":"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"}