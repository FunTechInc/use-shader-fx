{"version":3,"file":"use-shader-fx.js","sources":["../src/hooks/useBrush/shader/main.vert","../src/hooks/useBrush/shader/main.frag","../src/hooks/utils/useResolution.ts","../src/hooks/utils/useAddMesh.ts","../src/hooks/utils/setUniforms.ts","../src/hooks/useBrush/useMesh.ts","../src/hooks/utils/useCamera.ts","../src/hooks/utils/useSingleFBO.ts","../src/hooks/utils/useDoubleFBO.ts","../src/hooks/utils/usePointer.ts","../src/hooks/utils/useParams.ts","../src/hooks/useBrush/index.ts","../src/hooks/useDuoTone/shader/main.vert","../src/hooks/useDuoTone/shader/main.frag","../src/hooks/useDuoTone/useMesh.ts","../src/hooks/useDuoTone/index.ts","../src/hooks/useFlowmap/shader/main.vert","../src/hooks/useFlowmap/shader/main.frag","../src/hooks/useFlowmap/useMesh.ts","../src/hooks/useFlowmap/index.ts","../src/hooks/useFogProjection/shader/main.vert","../src/hooks/useFogProjection/shader/main.frag","../src/hooks/useFogProjection/useMesh.ts","../src/hooks/useFogProjection/index.ts","../src/hooks/useFruid/shaders/main.vert","../src/hooks/useFruid/shaders/init.frag","../src/hooks/useFruid/materials/useInitialMaterial.ts","../src/hooks/useFruid/shaders/advection.frag","../src/hooks/useFruid/materials/useAdvectionMaterial.ts","../src/hooks/useFruid/shaders/divergence.frag","../src/hooks/useFruid/materials/useDivergenceMaterial.ts","../src/hooks/useFruid/shaders/pressure.frag","../src/hooks/useFruid/materials/usePressureMaterial.ts","../src/hooks/useFruid/shaders/curl.frag","../src/hooks/useFruid/materials/useCurlMaterial.ts","../src/hooks/useFruid/shaders/vorticity.frag","../src/hooks/useFruid/materials/useVorticityMaterial.ts","../src/hooks/useFruid/shaders/clear.frag","../src/hooks/useFruid/materials/useClearMaterial.ts","../src/hooks/useFruid/shaders/gradientSubtract.frag","../src/hooks/useFruid/materials/useGradientSubtractMaterial.ts","../src/hooks/useFruid/shaders/splat.frag","../src/hooks/useFruid/materials/useSplatMaterial.ts","../src/hooks/useFruid/useMesh.ts","../src/hooks/useFruid/index.ts","../src/hooks/useRipple/useMesh.ts","../src/hooks/useRipple/index.ts","../src/hooks/useSimpleFruid/shaders/main.vert","../src/hooks/useSimpleFruid/shaders/init.frag","../src/hooks/useSimpleFruid/materials/useInitialMaterial.ts","../src/hooks/useSimpleFruid/shaders/velocity.frag","../src/hooks/useSimpleFruid/materials/useVelocityMaterial.ts","../src/hooks/useSimpleFruid/shaders/advection.frag","../src/hooks/useSimpleFruid/materials/useAdvectionMaterial.ts","../src/hooks/useSimpleFruid/shaders/divergence.frag","../src/hooks/useSimpleFruid/materials/useDivergenceMaterial.ts","../src/hooks/useSimpleFruid/shaders/pressure.frag","../src/hooks/useSimpleFruid/materials/usePressureMaterial.ts","../src/hooks/useSimpleFruid/useMesh.ts","../src/hooks/useSimpleFruid/index.ts","../src/hooks/useTransitionBg/shader/main.vert","../src/hooks/useTransitionBg/shader/main.frag","../src/hooks/useTransitionBg/useMesh.ts","../src/hooks/useTransitionBg/index.ts"],"sourcesContent":["varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nuniform sampler2D uMap;\nuniform sampler2D uTexture;\nuniform float uRadius;\nuniform float uAlpha;\nuniform float uDissipation;\nuniform float uMagnification;\nuniform vec2 uResolution;\nuniform float uSmudge;\nuniform float uAspect;\nuniform vec2 uMouse;\nuniform vec2 uPrevMouse;\nuniform vec2 uVelocity;\n\nuniform float uMotionBlur;\nuniform int uMotionSample;\n\nvarying vec2 vUv;\n\nfloat isOnLine(vec2 point, vec2 start, vec2 end, float width, float aspect) {\n\t//正円にする\n\tpoint.x *= aspect;\n\tstart.x *= aspect;\n\tend.x *= aspect;\n\n\t//方向の単位ベクトル\n\tvec2 dir = normalize(end - start);\n\t//線分に対して垂直の単位ベクトル\n\tvec2 n = vec2(dir.y, -dir.x);\n\t//方向ベクトル\n\tvec2 p0 = point - start;\n\t\n\t//線上の距離を計算する\n\tfloat distToLine = abs(dot(p0, n));\n\tfloat distAlongLine = dot(p0, dir);\n\tfloat totalLength = length(end - start);\n\n\t//始点と終点の円の半径も範囲に含める\n\tfloat distFromStart = length(point - start);\n\tfloat distFromEnd = length(point - end);\n\t\n\tbool withinLine = (distToLine < width && distAlongLine > 0.0 && distAlongLine < totalLength) || distFromStart < width || distFromEnd < width;\n\n\treturn float(withinLine);\n}\n\nvec4 createSmudge(){\n\tvec2 offsets[9];\n\toffsets[0] = vec2(-1, -1); offsets[1] = vec2( 0, -1); offsets[2] = vec2( 1, -1);\n\toffsets[3] = vec2(-1,  0); offsets[4] = vec2( 0,  0); offsets[5] = vec2( 1,  0);\n\toffsets[6] = vec2(-1,  1); offsets[7] = vec2( 0,  1); offsets[8] = vec2( 1,  1);\n\t// オフセットをテクスチャサイズにスケール\n\tfor(int i = 0; i < 9; i++) {\n\t\toffsets[i] = (offsets[i] * uSmudge) / uResolution;\n\t}\t\n\tvec4 smudgedColor = vec4(0.0);\n\tfor(int i = 0; i < 9; i++) {\n\t\tsmudgedColor += texture2D(uMap, vUv + offsets[i]);\n\t}\n\treturn smudgedColor / 9.0;\n}\n\nvec4 createMotionBlur(vec4 baseColor, vec2 velocity, float motion, int samples) {\n\tvec4 motionBlurredColor = baseColor;\n\tvec2 scaledVelocity = velocity * motion;\n\tfor(int i = 1; i < samples; i++) {\n\t\tfloat t = float(i) / float(samples - 1);\n\t\tvec2 offset = t * scaledVelocity / uResolution;\n\t\tmotionBlurredColor += texture2D(uMap, vUv + offset);\n\t}\n\treturn motionBlurredColor / float(samples);\n}\n\n\nvoid main() {\n\t// UV座標を[-1, 1]の範囲に変換\n\tvec2 st = vUv * 2.0 - 1.0;\n\t\n\t//速度ベクトル\n\tvec2 velocity = uVelocity * uResolution;\n\n\t// 滲みを加える\n\tvec4 smudgedColor = createSmudge();\n\t\n\t//モーションブラー\n\tvec4 motionBlurredColor = createMotionBlur(smudgedColor, uVelocity, uMotionBlur,uMotionSample);\n\n\t//バッファーテクスチャー\n\tvec4 bufferColor = motionBlurredColor * uDissipation;\n\n\t// radius\n\tfloat modifiedRadius = uRadius + (length(velocity) * uMagnification);\n\tmodifiedRadius = max(0.0,modifiedRadius);\n\n\t//\tcolor TODO:カラーに速度を反映させるかどうか、最初のフレームのカラーをどうするか\n\t// vec3 color = vec3(velocity * vec2(1, -1), 1.0 - pow(1.0 - min(1.0, length(velocity)), 1.0));\n\tvec3 color = vec3(1.0,1.0,1.0);\n\n\t//カラーにテクスチャーをマッピングする\n\tvec4 textureColor = texture2D(uTexture, vUv);\n\tvec3 finalColor = mix(color, textureColor.rgb, textureColor.a);\n\n\t//始点と終点の直線上を判定する\n\tfloat onLine = isOnLine(st, uPrevMouse, uMouse, modifiedRadius, uAspect);\n\n\t//最終出力\n\tbufferColor.rgb = mix(bufferColor.rgb, finalColor, onLine);\n\tgl_FragColor = bufferColor;\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\n/**\n * @params isDpr Whether to multiply dpr, default:false\n */\nexport const useResolution = (size: Size, dpr: number | false = false) => {\n   const _width = dpr ? size.width * dpr : size.width;\n   const _height = dpr ? size.height * dpr : size.height;\n   const resolution = useMemo(\n      () => new THREE.Vector2(_width, _height),\n      [_width, _height]\n   );\n   return resolution;\n};\n","import * as THREE from \"three\";\nimport { useEffect, useMemo } from \"react\";\n\nexport const useAddMesh = (\n   scene: THREE.Scene,\n   geometry: THREE.PlaneGeometry,\n   material: THREE.Material\n) => {\n   const mesh = useMemo(\n      () => new THREE.Mesh(geometry, material),\n      [geometry, material]\n   );\n   useEffect(() => {\n      scene.add(mesh);\n   }, [scene, mesh]);\n   return mesh;\n};\n","export const setUniform = (\n   material: THREE.ShaderMaterial | THREE.RawShaderMaterial,\n   key: string,\n   value:\n      | number\n      | THREE.Color\n      | THREE.Vector2\n      | THREE.Vector3\n      | THREE.Vector4\n      | THREE.Matrix3\n      | THREE.Matrix4\n      | THREE.Texture\n      | THREE.CubeTexture\n) => {\n   if (\n      material.uniforms &&\n      material.uniforms[key] &&\n      value !== undefined &&\n      value !== null\n   ) {\n      material.uniforms[key].value = value;\n   } else {\n      console.error(\n         `Uniform key \"${key}\" does not exist in the material. or \"${key}\" is null | undefined`\n      );\n   }\n};\n","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useEffect, useMemo } from \"react\";\nimport { useResolution } from \"../utils/useResolution\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uMap: {\n                  value: null,\n               },\n               uResolution: { value: new THREE.Vector2(0, 0) },\n               uAspect: { value: 1 },\n               uTexture: { value: new THREE.Texture() },\n               uRadius: { value: 0.0 },\n               uAlpha: { value: 0.0 },\n               uSmudge: { value: 0.0 },\n               uDissipation: { value: 0.0 },\n               uMagnification: { value: 0.0 },\n               uMotionBlur: { value: 0.0 },\n               uMotionSample: { value: 10 },\n               uMouse: { value: new THREE.Vector2(0, 0) },\n               uPrevMouse: { value: new THREE.Vector2(0, 0) },\n               uVelocity: { value: new THREE.Vector2(0, 0) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(material, \"uAspect\", resolution.width / resolution.height);\n      setUniform(material, \"uResolution\", resolution.clone());\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material;\n};\n","import * as THREE from \"three\";\nimport { useResolution } from \"./useResolution\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\nconst getCameraProps = (width: number, height: number) => {\n   const frustumSize = height;\n   const aspect = width / height;\n   const [w, h] = [(frustumSize * aspect) / 2, frustumSize / 2];\n   return { width: w, height: h, near: -1000, far: 1000 };\n};\n\nexport const useCamera = (size: Size) => {\n   const resolution = useResolution(size);\n   const { width, height, near, far } = getCameraProps(\n      resolution.x,\n      resolution.y\n   );\n   const camera = useMemo(\n      () =>\n         new THREE.OrthographicCamera(\n            -width,\n            width,\n            height,\n            -height,\n            near,\n            far\n         ),\n      [width, height, near, far]\n   );\n   return camera;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useLayoutEffect, useMemo, useRef } from \"react\";\nimport { useResolution } from \"./useResolution\";\nimport { UseFboProps } from \"./types\";\n\nexport const FBO_OPTION = {\n   minFilter: THREE.LinearFilter,\n   magFilter: THREE.LinearFilter,\n   type: THREE.HalfFloatType,\n   depthBuffer: false,\n   stencilBuffer: false,\n};\n\ntype FBOUpdateFunction = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({ read }: { read: THREE.Texture }) => void\n) => THREE.Texture;\n\ntype Return = [THREE.WebGLRenderTarget, FBOUpdateFunction];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [THREE.WebGLRenderTarget , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useSingleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n}: UseFboProps): Return => {\n   const renderTarget = useRef<THREE.WebGLRenderTarget>();\n\n   const resolution = useResolution(size, dpr);\n   renderTarget.current = useMemo(\n      () => new THREE.WebGLRenderTarget(resolution.x, resolution.y, FBO_OPTION),\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      []\n   );\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current?.setSize(resolution.x, resolution.y);\n      }\n   }, [resolution, isSizeUpdate]);\n\n   const updateRenderTarget: FBOUpdateFunction = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current!;\n         gl.setRenderTarget(fbo);\n         onBeforeRender && onBeforeRender({ read: fbo.texture });\n         gl.render(scene, camera);\n         gl.setRenderTarget(null);\n         gl.clear();\n         return fbo.texture;\n      },\n      [scene, camera]\n   );\n\n   return [renderTarget.current, updateRenderTarget];\n};\n","import * as THREE from \"three\";\nimport { useCallback, useLayoutEffect, useMemo, useRef } from \"react\";\nimport { FBO_OPTION } from \"./useSingleFBO\";\nimport { useResolution } from \"./useResolution\";\nimport { DoubleRenderTarget, UseFboProps } from \"./types\";\n\ninterface RenderTarget extends DoubleRenderTarget {\n   swap: () => void;\n}\n\ntype FBOUpdateFunction = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({\n      read,\n      write,\n   }: {\n      read: THREE.Texture;\n      write: THREE.Texture;\n   }) => void\n) => THREE.Texture;\n\ntype Return = [\n   { read: THREE.WebGLRenderTarget; write: THREE.WebGLRenderTarget },\n   FBOUpdateFunction\n];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [{read:THREE.WebGLRenderTarget,write:THREE.WebGLRenderTarget} , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useDoubleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n}: UseFboProps): Return => {\n   const renderTarget = useRef<RenderTarget>({\n      read: null,\n      write: null,\n      swap: function () {\n         let temp = this.read;\n         this.read = this.write;\n         this.write = temp;\n      },\n   });\n\n   const resolution = useResolution(size, dpr);\n   const initRenderTargets = useMemo(() => {\n      const read = new THREE.WebGLRenderTarget(\n         resolution.x,\n         resolution.y,\n         FBO_OPTION\n      );\n      const write = new THREE.WebGLRenderTarget(\n         resolution.x,\n         resolution.y,\n         FBO_OPTION\n      );\n      return { read, write };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, []);\n   renderTarget.current.read = initRenderTargets.read;\n   renderTarget.current.write = initRenderTargets.write;\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current.read?.setSize(resolution.x, resolution.y);\n         renderTarget.current.write?.setSize(resolution.x, resolution.y);\n      }\n   }, [resolution, isSizeUpdate]);\n\n   const updateRenderTarget: FBOUpdateFunction = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current;\n         gl.setRenderTarget(fbo.write);\n         onBeforeRender &&\n            onBeforeRender({\n               read: fbo.read!.texture,\n               write: fbo.write!.texture,\n            });\n         gl.render(scene, camera);\n         fbo.swap();\n         gl.setRenderTarget(null);\n         gl.clear();\n         return fbo.read?.texture as THREE.Texture;\n      },\n      [scene, camera]\n   );\n\n   return [\n      { read: renderTarget.current.read, write: renderTarget.current.write },\n      updateRenderTarget,\n   ];\n};\n","import * as THREE from \"three\";\nimport { useCallback, useRef } from \"react\";\n\n/**\n * @returns updatePointer frameで呼び出す更新関数を返す\n */\nexport const usePointer = () => {\n   const prevPointer = useRef(new THREE.Vector2(0, 0));\n   const diffPointer = useRef(new THREE.Vector2(0, 0));\n   const lastUpdateTime = useRef<number>(0);\n   const velocity = useRef(new THREE.Vector2(0, 0));\n   const isMoved = useRef(false);\n\n   const updatePointer = useCallback((currentPointer: THREE.Vector2) => {\n      const now = performance.now();\n      const current = currentPointer.clone();\n\n      // first frame\n      if (lastUpdateTime.current === 0) {\n         lastUpdateTime.current = now;\n         prevPointer.current = current;\n      }\n      const deltaTime = Math.max(1, now - lastUpdateTime.current);\n      lastUpdateTime.current = now;\n\n      // get velocity\n      velocity.current\n         .copy(current)\n         .sub(prevPointer.current)\n         .divideScalar(deltaTime);\n      const isUpdate = velocity.current.length() > 0;\n\n      //set prev temp pos\n      const prevTemp = isMoved.current ? prevPointer.current.clone() : current;\n      if (!isMoved.current && isUpdate) {\n         isMoved.current = true;\n      }\n      prevPointer.current = current;\n\n      return {\n         currentPointer: current,\n         prevPointer: prevTemp,\n         diffPointer: diffPointer.current.subVectors(current, prevTemp),\n         velocity: velocity.current,\n         isVelocityUpdate: isUpdate,\n      };\n   }, []);\n\n   return updatePointer;\n};\n","import { useCallback, useRef } from \"react\";\n\ntype Return<T> = [T, (params: Partial<T>) => void];\n\nexport const useParams = <T extends object>(params: T): Return<T> => {\n   const paramsRef = useRef(params);\n   const setParams = useCallback((updateParams: Partial<T>) => {\n      for (const key in updateParams) {\n         const paramKey = key as keyof T;\n         if (\n            paramKey in paramsRef.current &&\n            updateParams[paramKey] !== undefined &&\n            updateParams[paramKey] !== null\n         ) {\n            paramsRef.current[paramKey] = updateParams[paramKey]!;\n         } else {\n            console.error(\n               `\"${String(\n                  paramKey\n               )}\" does not exist in the params. or \"${String(\n                  paramKey\n               )}\" is null | undefined`\n            );\n         }\n      }\n   }, []);\n   return [paramsRef.current, setParams];\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { useDoubleFBO } from \"../utils/useDoubleFBO\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { usePointer } from \"../utils/usePointer\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\nimport { DoubleRenderTarget } from \"../utils/types\";\n\nexport type BrushParams = {\n   /** ブラシに適用するテクスチャー */\n   texture?: THREE.Texture;\n   /** size of the stamp, percentage of the size */\n   radius?: number;\n   /** opacity TODO*これバグってるいので修正 */\n   alpha?: number;\n   /** 滲み効果の強さ */\n   smudge?: number;\n   /** 拡散率。1にすると残り続ける */\n   dissipation?: number;\n   /** 拡大率 */\n   magnification?: number;\n   /** モーションブラーの強さ */\n   motionBlur?: number;\n   /** モーションブラーのサンプル数 これを高くするとパフォーマンスへの影響大 */\n   motionSample?: number;\n};\n\nexport type BrushObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: DoubleRenderTarget;\n};\n\nexport const useBrush = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<BrushParams, BrushObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useDoubleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<BrushParams>({\n      texture: new THREE.Texture(),\n      radius: 0.0,\n      alpha: 0.0,\n      smudge: 0.0,\n      dissipation: 0.0,\n      magnification: 0.0,\n      motionBlur: 0.0,\n      motionSample: 10,\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: BrushParams) => {\n         const { gl, pointer } = props;\n\n         setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uRadius\", params.radius!);\n         setUniform(material, \"uAlpha\", params.alpha!);\n         setUniform(material, \"uSmudge\", params.smudge!);\n         setUniform(material, \"uDissipation\", params.dissipation!);\n         setUniform(material, \"uMagnification\", params.magnification!);\n         setUniform(material, \"uMotionBlur\", params.motionBlur!);\n         setUniform(material, \"uMotionSample\", params.motionSample!);\n\n         const { currentPointer, prevPointer, velocity } =\n            updatePointer(pointer);\n         setUniform(material, \"uMouse\", currentPointer);\n         setUniform(material, \"uPrevMouse\", prevPointer);\n         setUniform(material, \"uVelocity\", velocity);\n\n         const bufferTexture = updateRenderTarget(gl, ({ read }) => {\n            setUniform(material, \"uMap\", read);\n         });\n\n         return bufferTexture;\n      },\n      [material, updatePointer, updateRenderTarget, params, setParams]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\n\nuniform vec3 uColor0;\nuniform vec3 uColor1;\n\nvoid main() {\n\tvec2 uv = vUv;\n\tvec4 texColor = texture2D(uTexture, uv);\n\tfloat grayscale = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n\tvec3 duotone = mix(uColor0, uColor1, grayscale);\n\tgl_FragColor = vec4(duotone, texColor.a);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\n\ntype TUniforms = {\n   uTexture: { value: THREE.Texture };\n   uColor0: { value: THREE.Color };\n   uColor1: { value: THREE.Color };\n};\n\nexport class MetamorphoseMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uColor0: { value: new THREE.Color(0xffffff) },\n               uColor1: { value: new THREE.Color(0x000000) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as MetamorphoseMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../utils/useSingleFBO\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\n\nexport type DuoToneParams = {\n   texture?: THREE.Texture;\n   color0?: THREE.Color;\n   color1?: THREE.Color;\n};\n\nexport type DuoToneObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const useDuoTone = ({\n   size,\n}: {\n   size: Size;\n}): HooksReturn<DuoToneParams, DuoToneObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<DuoToneParams>({\n      texture: new THREE.Texture(),\n      color0: new THREE.Color(0xffffff),\n      color1: new THREE.Color(0x000000),\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: DuoToneParams) => {\n         const { gl } = props;\n\n         setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uColor0\", params.color0!);\n         setUniform(material, \"uColor1\", params.color1!);\n\n         const bufferTexture = updateRenderTarget(gl);\n\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nuniform sampler2D uMap;\nuniform float uRadius;\nuniform float uAlpha;\nuniform float uDissipation;\nuniform float uMagnification;\nuniform vec2 uResolution;\n\nuniform float uAspect;\nuniform vec2 uMouse;\nuniform vec2 uVelocity;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec2 st = vUv * 2.0 - 1.0; // UV座標を[-1, 1]の範囲に変換\n\n\tvec2 vel = uVelocity * uResolution;\n\n\t// buffer color\n\tvec4 bufferColor = texture2D(uMap, vUv) * uDissipation;\n\t\n\t//\tcolor\n\tvec3 color = vec3(vel * vec2(1, -1), 1.0 - pow(1.0 - min(1.0, length(vel)), 1.0));\n\t// vec3 color = vec3(1.0,1.0,1.0);\n\n\t// cursor\n\tvec2 nMouse = (uMouse + vec2(1.0)) * 0.5;\n\tvec2 cursor = vUv - nMouse;\n\tcursor.x *= uAspect;\n\n\t// radius\n\tfloat modifiedRadius = uRadius + (length(vel) * uMagnification);\n\tmodifiedRadius = max(0.0,modifiedRadius);\n\tfloat finalBrush = smoothstep(modifiedRadius,0.0,length(cursor)) * uAlpha;\n\n\t// mix buffer and current color\n\tbufferColor.rgb = mix(bufferColor.rgb, color, vec3(finalBrush));\n\n\tgl_FragColor = bufferColor;\n}","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useEffect, useMemo } from \"react\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\nimport { useResolution } from \"../utils/useResolution\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uMap: { value: null },\n               uResolution: { value: new THREE.Vector2(0, 0) },\n               uAspect: { value: 1 },\n               uRadius: { value: 0.0 },\n               uAlpha: { value: 0.0 },\n               uDissipation: { value: 0.0 },\n               uMagnification: { value: 0.0 },\n               uMouse: { value: new THREE.Vector2(0, 0) },\n               uVelocity: { value: new THREE.Vector2(0, 0) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size, dpr);\n\n   useEffect(() => {\n      setUniform(material, \"uAspect\", resolution.width / resolution.height);\n      setUniform(material, \"uResolution\", resolution.clone());\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material;\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { useDoubleFBO } from \"../utils/useDoubleFBO\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { usePointer } from \"../utils/usePointer\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\nimport { DoubleRenderTarget } from \"../utils/types\";\n\nexport type FlowmapParams = {\n   /** size of the stamp, percentage of the size */\n   radius?: number;\n   /** 拡大率 */\n   magnification?: number;\n   /** opacity */\n   alpha?: number;\n   /** 拡散率。1にすると残り続ける */\n   dissipation?: number;\n};\n\nexport type FlowmapObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: DoubleRenderTarget;\n};\n\nexport const useFlowmap = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<FlowmapParams, FlowmapObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useDoubleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<FlowmapParams>({\n      radius: 0.0,\n      magnification: 0.0,\n      alpha: 0.0,\n      dissipation: 0.0,\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: FlowmapParams) => {\n         const { gl, pointer } = props;\n\n         setParams(updateParams);\n\n         setUniform(material, \"uRadius\", params.radius!);\n         setUniform(material, \"uAlpha\", params.alpha!);\n         setUniform(material, \"uDissipation\", params.dissipation!);\n         setUniform(material, \"uMagnification\", params.magnification!);\n\n         const { currentPointer, velocity } = updatePointer(pointer);\n         setUniform(material, \"uMouse\", currentPointer);\n         setUniform(material, \"uVelocity\", velocity);\n\n         const bufferTexture = updateRenderTarget(gl, ({ read }) => {\n            setUniform(material, \"uMap\", read);\n         });\n\n         return bufferTexture;\n      },\n      [material, updatePointer, updateRenderTarget, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform float uTime;\nuniform sampler2D uTexture;\nuniform float timeStrength;\nuniform float distortionStrength;\nuniform float fogEdge0;\nuniform float fogEdge1;\nuniform vec3 fogColor;\nuniform int noiseOct; //noiseの振幅回数\nuniform int fbmOct; //fbmの振幅回数\n\nconst float per  = 0.5;\nconst float PI   = 3.1415926;\n\nfloat interpolate(float a, float b, float x){\n    float f = (1.0 - cos(x * PI)) * 0.5;\n    return a * (1.0 - f) + b * f;\n}\n\nfloat rnd(vec2 p){\n    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat irnd(vec2 p){\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tvec4 v = vec4(rnd(vec2(i.x,i.y)),rnd(vec2(i.x + 1.0,i.y)),rnd(vec2(i.x,i.y + 1.0)),rnd(vec2(i.x + 1.0, i.y + 1.0)));\n\treturn interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);\n}\n\nfloat noise(vec2 p, float time){\n\tfloat t = 0.0;\n\tfor(int i = 0; i < noiseOct; i++){\n\t\tfloat freq = pow(2.0, float(i));\n\t\tfloat amp  = pow(per, float(noiseOct - i));\n\t\tt += irnd(vec2(p.y / freq + time, p.x / freq + time)) * amp;\n\t}\n\treturn t;\n}\n\nfloat fbm(vec2 x, float time) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfloat sign = 1.0;\n\tfor (int i = 0; i < fbmOct; ++i) {\n\t\tv += a * noise(x, time * sign);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t\tsign *= -1.0;\n\t}\n\treturn v;\n}\n\nvoid main() {\n\tvec2 uv = vUv;\n\t\n\tfloat noiseMap = fbm(gl_FragCoord.xy ,uTime * timeStrength);\n\t\n\tfloat noiseTextureMap = noiseMap*2.0-1.0;\n\tuv += noiseTextureMap * distortionStrength;\n\tvec3 textureMap = texture2D(uTexture, uv).rgb;\n\n\tfloat edge0 = fogEdge0;\n\tfloat edge1 = fogEdge1;\n\tfloat blendValue = smoothstep(edge0, edge1, noiseMap);\n\n\tvec3 outputColor = blendValue * fogColor + (1.0 - blendValue) * textureMap;\n\tgl_FragColor = vec4(outputColor, 1.0);\n}\n\n\n","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTime: { value: 0.0 },\n               uTexture: { value: new THREE.Texture() },\n               timeStrength: { value: 0.0 },\n               distortionStrength: { value: 0.0 },\n               fogEdge0: { value: 0.0 },\n               fogEdge1: { value: 0.9 },\n               fogColor: { value: new THREE.Color(0xffffff) },\n               noiseOct: { value: 8 },\n               fbmOct: { value: 3 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../utils/useSingleFBO\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\n\nexport type FogProjectionParams = {\n   texture?: THREE.Texture;\n   timeStrength?: number;\n   distortionStrength?: number;\n   fogEdge0?: number;\n   fogEdge1?: number;\n   fogColor?: THREE.Color;\n   noiseOct?: number;\n   fbmOct?: number;\n};\n\nexport type FogProjectionObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const useFogProjection = ({\n   size,\n}: {\n   size: Size;\n}): HooksReturn<FogProjectionParams, FogProjectionObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<FogProjectionParams>({\n      texture: new THREE.Texture(),\n      timeStrength: 0.0,\n      distortionStrength: 0.0,\n      fogEdge0: 0.0,\n      fogEdge1: 0.9,\n      fogColor: new THREE.Color(0xffffff),\n      noiseOct: 8,\n      fbmOct: 3,\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: FogProjectionParams) => {\n         const { gl, clock } = props;\n         setParams(updateParams);\n         setUniform(material, \"uTime\", clock.getElapsedTime());\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"timeStrength\", params.timeStrength!);\n         setUniform(material, \"distortionStrength\", params.distortionStrength!);\n         setUniform(material, \"fogEdge0\", params.fogEdge0!);\n         setUniform(material, \"fogEdge1\", params.fogEdge1!);\n         setUniform(material, \"fogColor\", params.fogColor!);\n         setUniform(material, \"noiseOct\", params.noiseOct!);\n         setUniform(material, \"fbmOct\", params.fbmOct!);\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform vec2 texelSize;\n\nvoid main () {\n\tvUv = uv;\n\tvL = vUv - vec2(texelSize.x, 0.0);\n\tvR = vUv + vec2(texelSize.x, 0.0);\n\tvT = vUv + vec2(0.0, texelSize.y);\n\tvB = vUv - vec2(0.0, texelSize.y);\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvoid main(){\n\tgl_FragColor = vec4(0.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/init.frag\";\n\nexport const useInitialMaterial = () => {\n   const initialMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      []\n   );\n\n   return initialMaterial as THREE.ShaderMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uVelocity;\nuniform sampler2D uSource;\nuniform vec2 texelSize;\nuniform float dt;\nuniform float dissipation;\n\nvoid main () {\n\tvec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n\tgl_FragColor = dissipation * texture2D(uSource, coord);\n\tgl_FragColor.a = 1.0;\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/advection.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   uSource: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n   dt: { value: number };\n   dissipation: { value: number };\n};\n\nexport class AdvectionMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useAdvectionMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: new THREE.Texture() },\n               uSource: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n               dt: { value: 0.0 },\n               dissipation: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as AdvectionMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvec2 sampleVelocity (in vec2 uv) {\n\tvec2 multiplier = vec2(1.0, 1.0);\n\tif (uv.x < 0.0) { uv.x = 0.0; multiplier.x = -1.0; }\n\tif (uv.x > 1.0) { uv.x = 1.0; multiplier.x = -1.0; }\n\tif (uv.y < 0.0) { uv.y = 0.0; multiplier.y = -1.0; }\n\tif (uv.y > 1.0) { uv.y = 1.0; multiplier.y = -1.0; }\n\treturn multiplier * texture2D(uVelocity, uv).xy;\n}\n\nvoid main () {\n\tfloat L = sampleVelocity(vL).x;\n\tfloat R = sampleVelocity(vR).x;\n\tfloat T = sampleVelocity(vT).y;\n\tfloat B = sampleVelocity(vB).y;\n\tfloat div = 0.5 * (R - L + T - B);\n\tgl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/divergence.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class DivergenceMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useDivergenceMaterial = () => {\n   const divergenceMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return divergenceMaterial as DivergenceMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uDivergence;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tfloat C = texture2D(uPressure, vUv).x;\n\tfloat divergence = texture2D(uDivergence, vUv).x;\n\tfloat pressure = (L + R + B + T - divergence) * 0.25;\n\tgl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/pressure.frag\";\n\ntype TUniforms = {\n   uPressure: { value: THREE.Texture };\n   uDivergence: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class PressureMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const usePressureMaterial = () => {\n   const pressureMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: null },\n               uDivergence: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return pressureMaterial as PressureMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvoid main () {\n\tfloat L = texture2D(uVelocity, vL).y;\n\tfloat R = texture2D(uVelocity, vR).y;\n\tfloat T = texture2D(uVelocity, vT).x;\n\tfloat B = texture2D(uVelocity, vB).x;\n\tfloat vorticity = R - L - T + B;\n\tgl_FragColor = vec4(vorticity, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/curl.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class CurlMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useCurlMaterial = () => {\n   const curlMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return curlMaterial as CurlMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\nuniform sampler2D uCurl;\nuniform float curl;\nuniform float dt;\n\nvoid main () {\n\tfloat T = texture2D(uCurl, vT).x;\n\tfloat B = texture2D(uCurl, vB).x;\n\tfloat C = texture2D(uCurl, vUv).x;\n\tvec2 force = vec2(abs(T) - abs(B), 0.0);\n\tforce *= 1.0 / length(force + 0.00001) * curl * C;\n\tvec2 vel = texture2D(uVelocity, vUv).xy;\n\tgl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/vorticity.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   uCurl: { value: THREE.Texture };\n   curl: { value: number };\n   dt: { value: number };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class VorticityMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useVorticityMaterial = () => {\n   const vorticityMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               uCurl: { value: null },\n               curl: { value: 0 },\n               dt: { value: 0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return vorticityMaterial as VorticityMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform float value;\n\nvoid main () {\n\tgl_FragColor = value * texture2D(uTexture, vUv);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/clear.frag\";\n\ntype TUniforms = {\n   uTexture: { value: THREE.Texture };\n   value: { value: number };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class ClearMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useClearMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               value: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as ClearMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uVelocity;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tvec2 velocity = texture2D(uVelocity, vUv).xy;\n\tvelocity.xy -= vec2(R - L, T - B);\n\tgl_FragColor = vec4(velocity, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/gradientSubtract.frag\";\n\ntype TUniforms = {\n   uPressure: { value: THREE.Texture };\n   uVelocity: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class GradientSubtractMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useGradientSubtractMaterial = () => {\n   const gradientSubtractMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: new THREE.Texture() },\n               uVelocity: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return gradientSubtractMaterial as GradientSubtractMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uTarget;\nuniform float aspectRatio;\nuniform vec3 color;\nuniform vec2 point;\nuniform float radius;\n\nvoid main () {\n\tvec2 nPoint = (point + vec2(1.0)) * 0.5;\n\tvec2 p = vUv - nPoint.xy;\n\tp.x *= aspectRatio;\n\tvec3 splat = exp(-dot(p, p) / radius) * color;\n\tvec3 base = texture2D(uTarget, vUv).xyz;\n\tgl_FragColor = vec4(base + splat, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/splat.frag\";\n\ntype TUniforms = {\n   uTarget: { value: THREE.Texture };\n   aspectRatio: { value: number };\n   color: { value: THREE.Vector3 };\n   point: { value: THREE.Vector2 };\n   radius: { value: number };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class SplatMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useSplateMaterial = () => {\n   const splatMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTarget: { value: new THREE.Texture() },\n               aspectRatio: { value: 0 },\n               color: { value: new THREE.Vector3() },\n               point: { value: new THREE.Vector2() },\n               radius: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return splatMaterial as SplatMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo } from \"react\";\nimport { useInitialMaterial } from \"./materials/useInitialMaterial\";\nimport {\n   AdvectionMaterial,\n   useAdvectionMaterial,\n} from \"./materials/useAdvectionMaterial\";\nimport {\n   DivergenceMaterial,\n   useDivergenceMaterial,\n} from \"./materials/useDivergenceMaterial\";\nimport {\n   PressureMaterial,\n   usePressureMaterial,\n} from \"./materials/usePressureMaterial\";\nimport { CurlMaterial, useCurlMaterial } from \"./materials/useCurlMaterial\";\nimport {\n   VorticityMaterial,\n   useVorticityMaterial,\n} from \"./materials/useVorticityMaterial\";\nimport { useResolution } from \"../utils/useResolution\";\nimport { ClearMaterial, useClearMaterial } from \"./materials/useClearMaterial\";\nimport {\n   GradientSubtractMaterial,\n   useGradientSubtractMaterial,\n} from \"./materials/useGradientSubtractMaterial\";\nimport { SplatMaterial, useSplateMaterial } from \"./materials/useSplatMaterial\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TMaterials =\n   | AdvectionMaterial\n   | DivergenceMaterial\n   | CurlMaterial\n   | PressureMaterial\n   | ClearMaterial\n   | GradientSubtractMaterial\n   | SplatMaterial;\n\nexport type FruidMaterials = {\n   vorticityMaterial: VorticityMaterial;\n   curlMaterial: CurlMaterial;\n   advectionMaterial: AdvectionMaterial;\n   divergenceMaterial: DivergenceMaterial;\n   pressureMaterial: PressureMaterial;\n   clearMaterial: ClearMaterial;\n   gradientSubtractMaterial: GradientSubtractMaterial;\n   splatMaterial: SplatMaterial;\n};\ntype TUseMeshReturnType = [FruidMaterials, (material: TMaterials) => void];\n\n/**\n * Returns the material update function in the second argument\n */\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}): TUseMeshReturnType => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const initialMaterial = useInitialMaterial();\n   const updateMaterial = initialMaterial.clone();\n   const curlMaterial = useCurlMaterial();\n   const vorticityMaterial = useVorticityMaterial();\n   const advectionMaterial = useAdvectionMaterial();\n   const divergenceMaterial = useDivergenceMaterial();\n   const pressureMaterial = usePressureMaterial();\n   const clearMaterial = useClearMaterial();\n   const gradientSubtractMaterial = useGradientSubtractMaterial();\n   const splatMaterial = useSplateMaterial();\n   const materials = useMemo(\n      () => ({\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      }),\n      [\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      ]\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(\n         materials.splatMaterial,\n         \"aspectRatio\",\n         resolution.x / resolution.y\n      );\n      for (const material of Object.values(materials)) {\n         setUniform(\n            material,\n            \"texelSize\",\n            new THREE.Vector2(1.0 / resolution.x, 1.0 / resolution.y)\n         );\n      }\n   }, [resolution, materials]);\n\n   const mesh = useAddMesh(scene, geometry, initialMaterial);\n   useEffect(() => {\n      initialMaterial.dispose();\n      mesh.material = updateMaterial;\n   }, [initialMaterial, mesh, updateMaterial]);\n\n   const setMeshMaterial = useCallback(\n      (material: TMaterials) => {\n         mesh.material = material;\n         mesh.material.needsUpdate = true;\n      },\n      [mesh]\n   );\n\n   return [materials, setMeshMaterial];\n};\n","import * as THREE from \"three\";\nimport { FruidMaterials, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { useDoubleFBO } from \"../utils/useDoubleFBO\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { usePointer } from \"../utils/usePointer\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../utils/useSingleFBO\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\nimport { DoubleRenderTarget } from \"../utils/types\";\n\nexport type FruidParams = {\n   density_dissipation?: number;\n   velocity_dissipation?: number;\n   velocity_acceleration?: number;\n   pressure_dissipation?: number;\n   pressure_iterations?: number;\n   curl_strength?: number;\n   splat_radius?: number;\n   fruid_color?: ((velocity: THREE.Vector2) => THREE.Vector3) | THREE.Vector3;\n};\n\nexport type FruidObject = {\n   scene: THREE.Scene;\n   materials: FruidMaterials;\n   camera: THREE.Camera;\n   renderTarget: {\n      velocity: DoubleRenderTarget;\n      density: DoubleRenderTarget;\n      curl: THREE.WebGLRenderTarget;\n      divergence: THREE.WebGLRenderTarget;\n      pressure: DoubleRenderTarget;\n   };\n};\n\nexport const useFruid = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<FruidParams, FruidObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const [materials, setMeshMaterial] = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n\n   const fboProps = useMemo(\n      () => ({\n         scene,\n         camera,\n         size,\n         dpr,\n      }),\n      [scene, camera, size, dpr]\n   );\n   const [velocityFBO, updateVelocityFBO] = useDoubleFBO(fboProps);\n   const [densityFBO, updateDensityFBO] = useDoubleFBO(fboProps);\n   const [curlFBO, updateCurlFBO] = useSingleFBO(fboProps);\n   const [divergenceFBO, updateDivergenceFBO] = useSingleFBO(fboProps);\n   const [pressureFBO, updatePressureFBO] = useDoubleFBO(fboProps);\n\n   const lastTime = useRef(0);\n   const scaledDiffVec = useRef(new THREE.Vector2(0, 0));\n   const spaltVec = useRef(new THREE.Vector3(0, 0, 0));\n\n   const [params, setParams] = useParams<FruidParams>({\n      density_dissipation: 0.0,\n      velocity_dissipation: 0.0,\n      velocity_acceleration: 0.0,\n      pressure_dissipation: 0.0,\n      pressure_iterations: 20,\n      curl_strength: 0.0,\n      splat_radius: 0.001,\n      fruid_color: new THREE.Vector3(1.0, 1.0, 1.0),\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: FruidParams) => {\n         const { gl, pointer, clock, size } = props;\n\n         setParams(updateParams);\n\n         if (lastTime.current === 0) {\n            lastTime.current = clock.getElapsedTime();\n         }\n         const dt = Math.min(\n            (clock.getElapsedTime() - lastTime.current) / 3,\n            0.02\n         );\n         lastTime.current = clock.getElapsedTime();\n\n         // update velocity\n         const velocityTex = updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", read);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(materials.advectionMaterial, \"dt\", dt);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.velocity_dissipation!\n            );\n         });\n\n         // update density\n         const densityTex = updateDensityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", velocityTex);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.density_dissipation!\n            );\n         });\n\n         // update splatting\n         const { currentPointer, diffPointer, isVelocityUpdate, velocity } =\n            updatePointer(pointer);\n         if (isVelocityUpdate) {\n            updateVelocityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               setUniform(materials.splatMaterial, \"point\", currentPointer);\n               const scaledDiff = diffPointer.multiply(\n                  scaledDiffVec.current\n                     .set(size.width, size.height)\n                     .multiplyScalar(params.velocity_acceleration!)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"color\",\n                  spaltVec.current.set(scaledDiff.x, scaledDiff.y, 1.0)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"radius\",\n                  params.splat_radius!\n               );\n            });\n            updateDensityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               const color: THREE.Vector3 =\n                  typeof params.fruid_color === \"function\"\n                     ? params.fruid_color(velocity)\n                     : params.fruid_color!;\n               setUniform(materials.splatMaterial, \"color\", color);\n            });\n         }\n\n         // update curl\n         const curlTex = updateCurlFBO(gl, () => {\n            setMeshMaterial(materials.curlMaterial);\n            setUniform(materials.curlMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update vorticity\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.vorticityMaterial);\n            setUniform(materials.vorticityMaterial, \"uVelocity\", read);\n            setUniform(materials.vorticityMaterial, \"uCurl\", curlTex);\n            setUniform(\n               materials.vorticityMaterial,\n               \"curl\",\n               params.curl_strength!\n            );\n            setUniform(materials.vorticityMaterial, \"dt\", dt);\n         });\n\n         // update divergence\n         const divergenceTex = updateDivergenceFBO(gl, () => {\n            setMeshMaterial(materials.divergenceMaterial);\n            setUniform(materials.divergenceMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update pressure\n         updatePressureFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.clearMaterial);\n            setUniform(materials.clearMaterial, \"uTexture\", read);\n            setUniform(\n               materials.clearMaterial,\n               \"value\",\n               params.pressure_dissipation!\n            );\n         });\n\n         // solve pressure iterative (Gauss-Seidel)\n         setMeshMaterial(materials.pressureMaterial);\n         setUniform(materials.pressureMaterial, \"uDivergence\", divergenceTex);\n         let pressureTexTemp: THREE.Texture;\n         for (let i = 0; i < params.pressure_iterations!; i++) {\n            pressureTexTemp = updatePressureFBO(gl, ({ read }) => {\n               setUniform(materials.pressureMaterial, \"uPressure\", read);\n            });\n         }\n\n         // update gradienSubtract\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.gradientSubtractMaterial);\n            setUniform(\n               materials.gradientSubtractMaterial,\n               \"uPressure\",\n               pressureTexTemp\n            );\n            setUniform(materials.gradientSubtractMaterial, \"uVelocity\", read);\n         });\n\n         return densityTex;\n      },\n      [\n         materials,\n         setMeshMaterial,\n         updateCurlFBO,\n         updateDensityFBO,\n         updateDivergenceFBO,\n         updatePointer,\n         updatePressureFBO,\n         updateVelocityFBO,\n         setParams,\n         params,\n      ]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         materials: materials,\n         camera: camera,\n         renderTarget: {\n            velocity: velocityFBO,\n            density: densityFBO,\n            curl: curlFBO,\n            divergence: divergenceFBO,\n            pressure: pressureFBO,\n         },\n      },\n   ];\n};\n","import { useEffect, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\n\ntype TcreateMesh = {\n   scale: number;\n   max: number;\n   texture?: THREE.Texture;\n   scene: THREE.Scene;\n};\nexport const useMesh = ({ scale, max, texture, scene }: TcreateMesh) => {\n   const meshArr = useRef<THREE.Mesh[]>([]);\n   const geometry = useMemo(\n      () => new THREE.PlaneGeometry(scale, scale),\n      [scale]\n   );\n   const material = useMemo(\n      () =>\n         new THREE.MeshBasicMaterial({\n            map: texture ?? null,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      [texture]\n   );\n   useEffect(() => {\n      for (let i = 0; i < max; i++) {\n         const mesh = new THREE.Mesh(geometry.clone(), material.clone());\n         mesh.rotateZ(2 * Math.PI * Math.random());\n         mesh.visible = false;\n         scene.add(mesh);\n         meshArr.current.push(mesh);\n      }\n   }, [geometry, material, scene, max]);\n   return meshArr.current;\n};\n","import { useCallback, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../utils/useSingleFBO\";\nimport { usePointer } from \"../utils/usePointer\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\n\nexport type RippleParams = {\n   /** rippleが出現する頻度,default:0.01 */\n   frequency?: number;\n   /** rippleの回転,default:0.01 */\n   rotation?: number;\n   /** rippleがフェードアウトするスピード,default:0.9 */\n   fadeout_speed?: number;\n   /** rippleの拡大率,default:0.15 */\n   scale?: number;\n   /** rippleの透明度,default:0.6 */\n   alpha?: number;\n};\n\nexport type RippleObject = {\n   scene: THREE.Scene;\n   meshArr: THREE.Mesh[];\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const useRipple = ({\n   texture,\n   scale = 64,\n   max = 100,\n   size,\n}: {\n   /** texture applied to ripple */\n   texture: THREE.Texture;\n   /** ripple size, default:64 */\n   scale?: number;\n   /** ripple max length, default:100 */\n   max?: number;\n   size: Size;\n}): HooksReturn<RippleParams, RippleObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const meshArr = useMesh({\n      scale: scale,\n      max: max,\n      texture,\n      scene,\n   });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<RippleParams>({\n      frequency: 0.01,\n      rotation: 0.01,\n      fadeout_speed: 0.9,\n      scale: 0.15,\n      alpha: 0.6,\n   });\n\n   const currentWave = useRef(0);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: RippleParams) => {\n         const { gl, pointer, size } = props;\n\n         setParams(updateParams);\n\n         const { currentPointer, diffPointer } = updatePointer(pointer);\n         if (params.frequency! < diffPointer.length()) {\n            const mesh = meshArr[currentWave.current];\n            mesh.visible = true;\n            mesh.position.set(\n               currentPointer.x * (size.width / 2),\n               currentPointer.y * (size.height / 2),\n               0\n            );\n            mesh.scale.x = mesh.scale.y = 0.0;\n            (mesh.material as THREE.MeshBasicMaterial).opacity = params.alpha!;\n            currentWave.current = (currentWave.current + 1) % max;\n         }\n         meshArr.forEach((mesh) => {\n            if (mesh.visible) {\n               const material = mesh.material as THREE.MeshBasicMaterial;\n               mesh.rotation.z += params.rotation!;\n               material.opacity *= params.fadeout_speed!;\n               mesh.scale.x =\n                  params.fadeout_speed! * mesh.scale.x + params.scale!;\n               mesh.scale.y = mesh.scale.x;\n               if (material.opacity < 0.002) mesh.visible = false;\n            }\n         });\n\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, meshArr, updatePointer, max, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         camera: camera,\n         meshArr: meshArr,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvoid main(){\n\tgl_FragColor = vec4(0.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/init.frag\";\n\nexport const useInitialMaterial = () => {\n   const initialMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      []\n   );\n\n   return initialMaterial as THREE.ShaderMaterial;\n};\n","precision highp float;\n\nuniform float viscosity;\nuniform float forceRadius;\nuniform float forceCoefficient;\nuniform vec2 resolution;\nuniform sampler2D dataTex;\nuniform vec2 pointerPos;\nuniform vec2 beforePointerPos;\n\n#pragma glslify: map            = require('./map.glsl')\n#pragma glslify: samplePressure = require('./samplePressure.glsl')\n#pragma glslify: sampleVelocity = require('./sampleVelocity.glsl')\n\nvarying vec2 vUv;\n\nvoid main(){\n\tvec2 r = resolution;\n\tvec2 uv = gl_FragCoord.xy / r;\n\tvec4 data = texture2D(dataTex, uv);\n\tvec2 v = data.xy;\n\n\tvec2 offsetX = vec2(1.0, 0.0);\n\tvec2 offsetY = vec2(0.0, 1.0);\n\n\t// 上下左右の圧力\n\tfloat pLeft   = samplePressure(dataTex, (gl_FragCoord.xy - offsetX) / r, r);\n\tfloat pRight  = samplePressure(dataTex, (gl_FragCoord.xy + offsetX) / r, r);\n\tfloat pTop    = samplePressure(dataTex, (gl_FragCoord.xy - offsetY) / r, r);\n\tfloat pBottom = samplePressure(dataTex, (gl_FragCoord.xy + offsetY) / r, r);\n\n\t// マウス\n\tvec2 mPos = 0.5 * (pointerPos + 1.0) * r;\n\tvec2 mPPos = 0.5 * (beforePointerPos + 1.0) * r;\n\tvec2 mouseV = mPos - mPPos;\n\tfloat len = length(mPos - uv * r) / forceRadius;\n\tfloat d = clamp(1.0 - len, 0.0, 1.0) * length(mouseV) * forceCoefficient;\n\tvec2 mforce = d * normalize(mPos - uv * r + mouseV);\n\n\tv += vec2(pRight - pLeft, pBottom - pTop) * 0.5;\n\tv += mforce;\n\tv *= viscosity;\n\n\tgl_FragColor = vec4(v, data.zw);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/velocity.frag\";\n\ntype TUniforms = {\n   resolution: { value: THREE.Vector2 };\n   viscosity: { value: number };\n   forceRadius: { value: number };\n   forceCoefficient: { value: number };\n   dataTex: { value: THREE.Texture };\n   pointerPos: { value: THREE.Vector2 };\n   beforePointerPos: { value: THREE.Vector2 };\n};\n\nexport class VelocityMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useVelocityMaterial = () => {\n   const velocityMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               resolution: { value: new THREE.Vector2() },\n               dataTex: { value: null },\n               pointerPos: { value: null },\n               beforePointerPos: { value: null },\n               viscosity: { value: 0.0 },\n               forceRadius: { value: 0.0 },\n               forceCoefficient: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return velocityMaterial as VelocityMaterial;\n};\n","precision highp float;\n\nuniform float attenuation;\nuniform vec2 resolution;\nuniform sampler2D dataTex;\n\n#pragma glslify: sampleVelocity = require('./sampleVelocity.glsl')\n#pragma glslify: samplePressure = require('./samplePressure.glsl')\n\nvarying vec2 vUv;\n\nvec2 bilerpVelocity(sampler2D tex, vec2 p, vec2 resolution) {\n\tvec4 ij; // i0, j0, i1, j1\n\tij.xy = floor(p - 0.5) + 0.5;\n\tij.zw = ij.xy + 1.0;\n\n\tvec4 uv = ij / resolution.xyxy;\n\tvec2 d11 = sampleVelocity(tex, uv.xy, resolution);\n\tvec2 d21 = sampleVelocity(tex, uv.zy, resolution);\n\tvec2 d12 = sampleVelocity(tex, uv.xw, resolution);\n\tvec2 d22 = sampleVelocity(tex, uv.zw, resolution);\n\n\tvec2 a = p - ij.xy;\n\n\treturn mix(mix(d11, d21, a.x), mix(d12, d22, a.x), a.y);\n}\n\nvoid main(){\n\tvec2 r = resolution;\n\tvec2 p = gl_FragCoord.xy - sampleVelocity(dataTex, gl_FragCoord.xy / r, r);\n\n\tgl_FragColor = vec4(bilerpVelocity(dataTex, p, r) * attenuation, samplePressure(dataTex, gl_FragCoord.xy / r, r), 0.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/advection.frag\";\n\ntype TUniforms = {\n   resolution: { value: THREE.Vector2 };\n   dataTex: { value: THREE.Texture };\n   attenuation: { value: number };\n};\n\nexport class AdvectionMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useAdvectionMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               resolution: { value: new THREE.Vector2(0, 0) },\n               dataTex: { value: null },\n               attenuation: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as AdvectionMaterial;\n};\n","precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D dataTex;\n\n#pragma glslify: sampleVelocity = require('./sampleVelocity.glsl')\n\nvoid main(){\n\tvec2 r = resolution;\n\tvec4 data = texture2D(dataTex, gl_FragCoord.xy / r);\n\n\tvec2 offsetX = vec2(1.0, 0.0);\n\tvec2 offsetY = vec2(0.0, 1.0);\n\n\t// 上下左右の速度\n\tvec2 vLeft   = sampleVelocity(dataTex, (gl_FragCoord.xy - offsetX) / r, r);\n\tvec2 vRight  = sampleVelocity(dataTex, (gl_FragCoord.xy + offsetX) / r, r);\n\tvec2 vTop    = sampleVelocity(dataTex, (gl_FragCoord.xy - offsetY) / r, r);\n\tvec2 vBottom = sampleVelocity(dataTex, (gl_FragCoord.xy + offsetY) / r, r);\n\n\tfloat divergence = ((vRight.x - vLeft.x) + (vBottom.y - vTop.y)) * 0.5;\n\n\tgl_FragColor = vec4(data.xy, data.z, divergence);\n\n}\n\n","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/divergence.frag\";\n\ntype TUniforms = {\n   resolution: { value: THREE.Vector2 };\n   dataTex: { value: THREE.Texture };\n};\n\nexport class DivergenceMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useDivergenceMaterial = () => {\n   const divergenceMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               resolution: { value: new THREE.Vector2() },\n               dataTex: { value: null },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return divergenceMaterial as DivergenceMaterial;\n};\n","precision highp float;\n\nuniform float alpha;\nuniform float beta;\nuniform vec2 resolution;\nuniform sampler2D dataTex;\n\n#pragma glslify: samplePressure = require('./samplePressure.glsl')\n\nvoid main(){\n\tvec2 r = resolution;\n\tvec4 data = texture2D(dataTex, gl_FragCoord.xy / r);\n\n\t// 上下左右の圧力\n\tfloat pLeft   = samplePressure(dataTex, (gl_FragCoord.xy - vec2(1.0, 0.0)) / r, r);\n\tfloat pRight  = samplePressure(dataTex, (gl_FragCoord.xy + vec2(1.0, 0.0)) / r, r);\n\tfloat pTop    = samplePressure(dataTex, (gl_FragCoord.xy - vec2(0.0, 1.0)) / r, r);\n\tfloat pBottom = samplePressure(dataTex, (gl_FragCoord.xy + vec2(0.0, 1.0)) / r, r);\n\n\tfloat divergence = data.w;\n\tfloat pressure = (divergence * alpha + (pLeft + pRight + pTop + pBottom)) * 0.25 * beta;\n\tgl_FragColor = vec4(data.xy, pressure, divergence);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/pressure.frag\";\n\ntype TUniforms = {\n   resolution: { value: THREE.Vector2 };\n   dataTex: { value: THREE.Texture };\n   alpha: { value: number };\n   beta: { value: number };\n};\n\nexport class PressureMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const usePressureMaterial = () => {\n   const pressureMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               resolution: { value: new THREE.Vector2() },\n               dataTex: { value: null },\n               alpha: { value: 0.0 },\n               beta: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return pressureMaterial as PressureMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo } from \"react\";\nimport { useInitialMaterial } from \"./materials/useInitialMaterial\";\nimport {\n   VelocityMaterial,\n   useVelocityMaterial,\n} from \"./materials/useVelocityMaterial\";\nimport {\n   AdvectionMaterial,\n   useAdvectionMaterial,\n} from \"./materials/useAdvectionMaterial\";\nimport {\n   DivergenceMaterial,\n   useDivergenceMaterial,\n} from \"./materials/useDivergenceMaterial\";\nimport {\n   PressureMaterial,\n   usePressureMaterial,\n} from \"./materials/usePressureMaterial\";\nimport { useResolution } from \"../utils/useResolution\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TMaterials =\n   | VelocityMaterial\n   | AdvectionMaterial\n   | DivergenceMaterial\n   | PressureMaterial;\n\nexport type SimpleFruidMaterials = {\n   velocityMaterial: VelocityMaterial;\n   advectionMaterial: AdvectionMaterial;\n   divergenceMaterial: DivergenceMaterial;\n   pressureMaterial: PressureMaterial;\n};\n\ntype TUseMeshReturnType = [\n   SimpleFruidMaterials,\n   (material: TMaterials) => void\n];\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}): TUseMeshReturnType => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const initialMaterial = useInitialMaterial();\n   const updateMaterial = initialMaterial.clone();\n   const velocityMaterial = useVelocityMaterial();\n   const advectionMaterial = useAdvectionMaterial();\n   const divergenceMaterial = useDivergenceMaterial();\n   const pressureMaterial = usePressureMaterial();\n   const materials = useMemo(\n      () => ({\n         velocityMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n      }),\n      [\n         velocityMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n      ]\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      for (const material of Object.values(materials)) {\n         setUniform(material, \"resolution\", resolution);\n      }\n   }, [resolution, materials]);\n\n   const mesh = useAddMesh(scene, geometry, initialMaterial);\n   useEffect(() => {\n      initialMaterial.dispose();\n      mesh.material = updateMaterial;\n   }, [initialMaterial, mesh, updateMaterial]);\n\n   const setMeshMaterial = useCallback(\n      (material: TMaterials) => {\n         mesh.material = material;\n         mesh.material.needsUpdate = true;\n      },\n      [mesh]\n   );\n\n   return [materials, setMeshMaterial];\n};\n","import * as THREE from \"three\";\nimport { SimpleFruidMaterials, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { useDoubleFBO } from \"../utils/useDoubleFBO\";\nimport { useCallback, useMemo } from \"react\";\nimport { usePointer } from \"../utils/usePointer\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { useParams } from \"../utils/useParams\";\nimport { HooksReturn } from \"../types\";\nimport { DoubleRenderTarget } from \"../utils/types\";\n\nexport type SimpleFruidParams = {\n   /** 圧力のヤコビ法の計算回数 */\n   pressure_iterations?: number;\n   /** 圧力のステップごとの減衰値 */\n   attenuation?: number;\n   /** 圧力計算時の係数 */\n   alpha?: number;\n   /** 圧力計算時の係数 */\n   beta?: number;\n   /** 粘度 */\n   viscosity?: number;\n   /** 力を加える円の半径 */\n   forceRadius?: number;\n   /** 速度の係数 */\n   forceCoefficient?: number;\n};\n\nexport type SimpleFruidObject = {\n   scene: THREE.Scene;\n   materials: SimpleFruidMaterials;\n   camera: THREE.Camera;\n   renderTarget: DoubleRenderTarget;\n};\n\nexport const useSimpleFruid = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<SimpleFruidParams, SimpleFruidObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const [materials, setMeshMaterial] = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n\n   const [renderTarget, updateRenderTarget] = useDoubleFBO({\n      scene,\n      camera,\n      size,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] = useParams<SimpleFruidParams>({\n      pressure_iterations: 20,\n      attenuation: 1.0,\n      alpha: 1.0,\n      beta: 1.0,\n      viscosity: 0.99,\n      forceRadius: 90,\n      forceCoefficient: 1.0,\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: SimpleFruidParams) => {\n         const { gl, pointer } = props;\n\n         setParams(updateParams);\n\n         setUniform(\n            materials.advectionMaterial,\n            \"attenuation\",\n            params.attenuation!\n         );\n         setUniform(materials.pressureMaterial, \"alpha\", params.alpha!);\n         setUniform(materials.pressureMaterial, \"beta\", params.beta!);\n         setUniform(materials.velocityMaterial, \"viscosity\", params.viscosity!);\n         setUniform(\n            materials.velocityMaterial,\n            \"forceRadius\",\n            params.forceRadius!\n         );\n         setUniform(\n            materials.velocityMaterial,\n            \"forceCoefficient\",\n            params.forceCoefficient!\n         );\n\n         // update divergence\n         updateRenderTarget(gl, ({ read }) => {\n            setMeshMaterial(materials.divergenceMaterial);\n            setUniform(materials.divergenceMaterial, \"dataTex\", read);\n         });\n\n         // update pressure\n         const solverIteration = params.pressure_iterations!;\n         for (let i = 0; i < solverIteration; i++) {\n            updateRenderTarget(gl, ({ read }) => {\n               setMeshMaterial(materials.pressureMaterial);\n               setUniform(materials.pressureMaterial, \"dataTex\", read);\n            });\n         }\n\n         // update velocity\n         const { currentPointer, prevPointer } = updatePointer(pointer);\n         setUniform(materials.velocityMaterial, \"pointerPos\", currentPointer);\n         setUniform(\n            materials.velocityMaterial,\n            \"beforePointerPos\",\n            prevPointer\n         );\n         updateRenderTarget(gl, ({ read }) => {\n            setMeshMaterial(materials.velocityMaterial);\n            setUniform(materials.velocityMaterial, \"dataTex\", read);\n         });\n\n         // update advection\n         const outPutTexture = updateRenderTarget(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"dataTex\", read);\n         });\n\n         return outPutTexture;\n      },\n      [\n         materials,\n         setMeshMaterial,\n         updatePointer,\n         updateRenderTarget,\n         setParams,\n         params,\n      ]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         materials: materials,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform vec2 uResolution;\nuniform vec2 uImageResolution;\n\nuniform sampler2D uTexture0;\nuniform sampler2D uTexture1;\nuniform sampler2D noise;\nuniform float noiseStrength;\nuniform float progress;\nuniform float dirX;\nuniform float dirY;\n\nvoid main() {\n\tvec2 bgRatio=vec2(\n\t\tmin((uResolution.x/uResolution.y)/(uImageResolution.x/uImageResolution.y),1.),\n\t\tmin((uResolution.y/uResolution.x)/(uImageResolution.y/uImageResolution.x),1.)\n\t);\n\tvec2 uv=vec2(\n\t\tvUv.x*bgRatio.x+(1.-bgRatio.x)*.5,\n\t\tvUv.y*bgRatio.y+(1.-bgRatio.y)*.5\n\t);\n\n\t// noise\n\tvec2 noiseMap = texture2D(noise, uv).rg;\n\tnoiseMap=noiseMap*2.0-1.0;\n\tuv += noiseMap * noiseStrength;\n\n\t// uvをセンター基準に\n\tvec2 centeredUV = uv - vec2(0.5);\n\t\n\t//texture 0\n\tfloat xOffsetTexture0 = 0.5 - dirX * progress;\n\tfloat yOffsetTexture0 = 0.5 - dirY * progress;\n\tvec2 samplePosTexture0 = vec2(xOffsetTexture0, yOffsetTexture0) + centeredUV;\n\n\t//texture 1\n\tfloat xOffsetTexture1 = 0.5 + dirX * (1.0 - progress);\n\tfloat yOffsetTexture1 = 0.5 + dirY * (1.0 - progress);\n\tvec2 samplePosTexture1 = vec2(xOffsetTexture1, yOffsetTexture1) + centeredUV;\n\n\tvec4 color0 = texture2D(uTexture0, samplePosTexture0);\n\tvec4 color1 = texture2D(uTexture1, samplePosTexture1);\n\n\tgl_FragColor = mix(color0, color1, progress);\n\n}","import { useEffect, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useResolution } from \"../utils/useResolution\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../utils/useAddMesh\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TUniforms = {\n   uResolution: { value: THREE.Vector2 };\n   uImageResolution: { value: THREE.Vector2 };\n   uTexture0: { value: THREE.Texture };\n   uTexture1: { value: THREE.Texture };\n   noise: { value: THREE.Texture };\n   noiseStrength: { value: number };\n   progress: { value: number };\n   dirX: { value: number };\n   dirY: { value: number };\n};\n\nexport class MetamorphoseMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uResolution: { value: new THREE.Vector2() },\n               uImageResolution: { value: new THREE.Vector2() },\n               uTexture0: { value: new THREE.Texture() },\n               uTexture1: { value: new THREE.Texture() },\n               noise: { value: new THREE.Texture() },\n               noiseStrength: { value: 0.0 },\n               progress: { value: 0.0 },\n               dirX: { value: 0.0 },\n               dirY: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      material.uniforms.uResolution.value = resolution.clone();\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material as MetamorphoseMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../utils/useSingleFBO\";\nimport { setUniform } from \"../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../utils/useParams\";\n\nexport type TransitionBgParams = {\n   texture0?: THREE.Texture;\n   texture1?: THREE.Texture;\n   imageResolution?: THREE.Vector2;\n   noise?: THREE.Texture;\n   noiseStrength?: number;\n   progress?: number;\n   dir?: THREE.Vector2;\n};\n\nexport type TransitionBgObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const useTransitionBg = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<TransitionBgParams, TransitionBgObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      dpr,\n      size,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] = useParams<TransitionBgParams>({\n      texture0: new THREE.Texture(),\n      texture1: new THREE.Texture(),\n      imageResolution: new THREE.Vector2(0, 0),\n      noise: new THREE.Texture(),\n      noiseStrength: 0.0,\n      progress: 0.0,\n      dir: new THREE.Vector2(0, 0),\n   });\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams: TransitionBgParams) => {\n         const { gl } = props;\n\n         setParams(updateParams);\n\n         setUniform(material, \"uTexture0\", params.texture0!);\n         setUniform(material, \"uTexture1\", params.texture1!);\n         setUniform(material, \"uImageResolution\", params.imageResolution!);\n         setUniform(material, \"noise\", params.noise!);\n         setUniform(material, \"noiseStrength\", params.noiseStrength!);\n         setUniform(material, \"progress\", params.progress!);\n         setUniform(material, \"dirX\", params.dir!.x);\n         setUniform(material, \"dirY\", params.dir!.y);\n\n         const bufferTexture = updateRenderTarget(gl);\n\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n"],"names":["main_default","useResolution","size","dpr","_width","_height","useMemo","THREE","useAddMesh","scene","geometry","material","mesh","useEffect","setUniform","key","value","useMesh","vertexShader","fragmentShader","resolution","getCameraProps","width","height","frustumSize","aspect","w","h","useCamera","near","far","FBO_OPTION","useSingleFBO","camera","isSizeUpdate","renderTarget","useRef","useLayoutEffect","_a","updateRenderTarget","useCallback","gl","onBeforeRender","fbo","useDoubleFBO","temp","initRenderTargets","read","write","_b","usePointer","prevPointer","diffPointer","lastUpdateTime","velocity","isMoved","currentPointer","now","current","deltaTime","isUpdate","prevTemp","useParams","params","paramsRef","setParams","updateParams","paramKey","useBrush","updatePointer","props","pointer","useDuoTone","useFlowmap","useFogProjection","clock","init_default","useInitialMaterial","advection_default","useAdvectionMaterial","divergence_default","useDivergenceMaterial","pressure_default","usePressureMaterial","curl_default","useCurlMaterial","vorticity_default","useVorticityMaterial","clear_default","useClearMaterial","gradientSubtract_default","useGradientSubtractMaterial","splat_default","useSplateMaterial","initialMaterial","updateMaterial","curlMaterial","vorticityMaterial","advectionMaterial","divergenceMaterial","pressureMaterial","clearMaterial","gradientSubtractMaterial","splatMaterial","materials","setMeshMaterial","useFruid","fboProps","velocityFBO","updateVelocityFBO","densityFBO","updateDensityFBO","curlFBO","updateCurlFBO","divergenceFBO","updateDivergenceFBO","pressureFBO","updatePressureFBO","lastTime","scaledDiffVec","spaltVec","dt","velocityTex","densityTex","isVelocityUpdate","scaledDiff","color","curlTex","divergenceTex","pressureTexTemp","i","scale","max","texture","meshArr","useRipple","currentWave","velocity_default","useVelocityMaterial","velocityMaterial","useSimpleFruid","solverIteration","useTransitionBg"],"mappings":"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"}