{"version":3,"file":"use-shader-fx.js","sources":["../src/fxs/interactions/useBrush/shader/main.vert","../src/fxs/interactions/useBrush/shader/main.frag","../src/utils/useResolution.ts","../src/utils/useAddMesh.ts","../src/utils/setUniforms.ts","../src/fxs/interactions/useBrush/useMesh.ts","../src/utils/useCamera.ts","../src/misc/usePointer.ts","../src/utils/useParams.ts","../src/utils/useSingleFBO.ts","../src/utils/useDoubleFBO.ts","../src/fxs/interactions/useBrush/index.ts","../src/fxs/interactions/useFluid/shaders/main.vert","../src/fxs/interactions/useFluid/shaders/init.frag","../src/fxs/interactions/useFluid/materials/useInitialMaterial.ts","../src/fxs/interactions/useFluid/shaders/advection.frag","../src/fxs/interactions/useFluid/materials/useAdvectionMaterial.ts","../src/fxs/interactions/useFluid/shaders/divergence.frag","../src/fxs/interactions/useFluid/materials/useDivergenceMaterial.ts","../src/fxs/interactions/useFluid/shaders/pressure.frag","../src/fxs/interactions/useFluid/materials/usePressureMaterial.ts","../src/fxs/interactions/useFluid/shaders/curl.frag","../src/fxs/interactions/useFluid/materials/useCurlMaterial.ts","../src/fxs/interactions/useFluid/shaders/vorticity.frag","../src/fxs/interactions/useFluid/materials/useVorticityMaterial.ts","../src/fxs/interactions/useFluid/shaders/clear.frag","../src/fxs/interactions/useFluid/materials/useClearMaterial.ts","../src/fxs/interactions/useFluid/shaders/gradientSubtract.frag","../src/fxs/interactions/useFluid/materials/useGradientSubtractMaterial.ts","../src/fxs/interactions/useFluid/shaders/splat.frag","../src/fxs/interactions/useFluid/materials/useSplatMaterial.ts","../src/fxs/interactions/useFluid/useMesh.ts","../src/fxs/interactions/useFluid/index.ts","../src/fxs/interactions/useRipple/useMesh.ts","../src/fxs/interactions/useRipple/index.ts","../src/fxs/noises/useNoise/shader/main.vert","../src/fxs/noises/useNoise/shader/main.frag","../src/fxs/noises/useNoise/useMesh.ts","../src/fxs/noises/useNoise/index.ts","../src/fxs/noises/useColorStrata/shader/main.vert","../src/fxs/noises/useColorStrata/shader/main.frag","../src/fxs/noises/useColorStrata/useMesh.ts","../src/fxs/noises/useColorStrata/index.ts","../src/fxs/noises/useMarble/shader/main.vert","../src/fxs/noises/useMarble/shader/main.frag","../src/fxs/noises/useMarble/useMesh.ts","../src/fxs/noises/useMarble/index.ts","../src/fxs/utils/useDuoTone/shader/main.vert","../src/fxs/utils/useDuoTone/shader/main.frag","../src/fxs/utils/useDuoTone/useMesh.ts","../src/fxs/utils/useDuoTone/index.ts","../src/fxs/utils/useBlending/shader/main.vert","../src/fxs/utils/useBlending/shader/main.frag","../src/fxs/utils/useBlending/useMesh.ts","../src/fxs/utils/useBlending/index.ts","../src/fxs/utils/useFxTexture/shader/main.vert","../src/fxs/utils/useFxTexture/shader/main.frag","../src/fxs/utils/useFxTexture/useMesh.ts","../src/fxs/utils/useFxTexture/index.ts","../src/fxs/utils/useBrightnessPicker/shader/main.vert","../src/fxs/utils/useBrightnessPicker/shader/main.frag","../src/fxs/utils/useBrightnessPicker/useMesh.ts","../src/fxs/utils/useBrightnessPicker/index.ts","../src/fxs/utils/useFxBlending/shader/main.vert","../src/fxs/utils/useFxBlending/shader/main.frag","../src/fxs/utils/useFxBlending/useMesh.ts","../src/fxs/utils/useFxBlending/index.ts","../src/fxs/utils/useAlphaBlending/shader/main.vert","../src/fxs/utils/useAlphaBlending/shader/main.frag","../src/fxs/utils/useAlphaBlending/useMesh.ts","../src/fxs/utils/useAlphaBlending/index.ts","../src/fxs/utils/useHSV/shader/main.vert","../src/fxs/utils/useHSV/shader/main.frag","../src/fxs/utils/useHSV/useMesh.ts","../src/fxs/utils/useHSV/index.ts","../src/fxs/utils/useCoverTexture/shader/main.vert","../src/fxs/utils/useCoverTexture/shader/main.frag","../src/fxs/utils/useCoverTexture/useMesh.ts","../src/fxs/utils/useCoverTexture/index.ts","../src/fxs/effects/useSimpleBlur/shader/main.vert","../src/fxs/effects/useSimpleBlur/shader/main.frag","../src/fxs/effects/useSimpleBlur/useMesh.ts","../src/fxs/effects/useSimpleBlur/index.ts","../src/fxs/effects/useWave/shader/main.vert","../src/fxs/effects/useWave/shader/main.frag","../src/fxs/effects/useWave/useMesh.ts","../src/fxs/effects/useWave/index.ts","../src/fxs/misc/useChromaKey/shader/main.vert","../src/fxs/misc/useChromaKey/shader/main.frag","../src/fxs/misc/useChromaKey/useMesh.ts","../src/fxs/misc/useChromaKey/index.ts","../src/utils/useCopyTexture.ts","../src/libs/easing.ts","../src/misc/useBeat.ts","../src/misc/useFPSLimiter.ts","../src/misc/useDomSyncer/utils/errorHandler.ts","../src/misc/useDomSyncer/shader/main.vert","../src/misc/useDomSyncer/shader/main.frag","../src/misc/useDomSyncer/utils/createMesh.ts","../src/misc/useDomSyncer/utils/useIntersectionHandler.ts","../src/misc/useDomSyncer/utils/useUpdateDomRect.ts","../src/misc/useDomSyncer/utils/useIsIntersecting.ts","../src/misc/useDomSyncer/utils/createUseDomView.ts","../src/misc/useDomSyncer/index.ts"],"sourcesContent":["varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nuniform sampler2D uBuffer;\nuniform sampler2D uTexture;\nuniform bool uIsTexture;\nuniform sampler2D uMap;\nuniform bool uIsMap;\nuniform float uMapIntensity;\nuniform float uRadius;\nuniform float uDissipation;\nuniform vec2 uResolution;\nuniform float uSmudge;\nuniform vec2 uMouse;\nuniform vec2 uPrevMouse;\nuniform vec2 uVelocity;\nuniform vec3 uColor;\nuniform float uMotionBlur;\nuniform int uMotionSample;\nuniform bool uIsCursor;\nuniform float uPressureStart;\nuniform float uPressureEnd;\n\nvarying vec2 vUv;\n\nfloat isOnLine(vec2 point, vec2 start, vec2 end, float radius, float pressureStart, float pressureEnd) {\n\t\n\tfloat aspect = uResolution.x / uResolution.y;\n\n\tpoint.x *= aspect;\n\tstart.x *= aspect;\n\tend.x *= aspect;\n\n\tvec2 dir = normalize(end - start);\n\tvec2 n = vec2(dir.y, -dir.x);\n\tvec2 p0 = point - start;\n\t\n\tfloat distToLine = abs(dot(p0, n));\n\tfloat distAlongLine = dot(p0, dir);\n\tfloat totalLength = length(end - start);\n\n\tfloat progress = clamp(distAlongLine / totalLength, 0.0, 1.0);\n\tfloat pressure = mix(pressureStart, pressureEnd, progress);\n\tradius = min(radius,radius * pressure);\n\n\tfloat distFromStart = length(point - start);\n\tfloat distFromEnd = length(point - end);\n\t\n\tbool withinLine = (distToLine < radius && distAlongLine > 0.0 && distAlongLine < totalLength) || distFromStart < radius || distFromEnd < radius;\n\n\treturn float(withinLine);\n}\n\nvec4 createSmudge(vec2 uv){\n\tvec2 offsets[9];\n\toffsets[0] = vec2(-1, -1); offsets[1] = vec2( 0, -1); offsets[2] = vec2( 1, -1);\n\toffsets[3] = vec2(-1,  0); offsets[4] = vec2( 0,  0); offsets[5] = vec2( 1,  0);\n\toffsets[6] = vec2(-1,  1); offsets[7] = vec2( 0,  1); offsets[8] = vec2( 1,  1);\n\n\tfor(int i = 0; i < 9; i++) {\n\t\toffsets[i] = (offsets[i] * uSmudge) / uResolution;\n\t}\t\n\tvec4 smudgedColor = vec4(0.);\n\tfor(int i = 0; i < 9; i++) {\n\t\tsmudgedColor += texture2D(uBuffer, uv + offsets[i]);\n\t}\n\treturn smudgedColor / 9.0;\n}\n\nvec4 createMotionBlur(vec2 uv , vec4 baseColor, vec2 velocity) {\n\tvec2 scaledV = velocity * uMotionBlur;\n\tfor(int i = 1; i < uMotionSample; i++) {\n\t\tfloat t = float(i) / float(uMotionSample - 1);\n\t\tvec2 offset = t * scaledV / uResolution;\n\t\tbaseColor += texture2D(uBuffer, uv + offset);\n\t}\n\treturn baseColor / float(uMotionSample);\n}\n\nvoid main() {\n\n\tvec2 uv = vUv;\n\tif(uIsMap){\n\t\tvec2 mapColor = texture2D(uMap, uv).rg;\n\t\tvec2 normalizedMap = mapColor * 2.0 - 1.0;\n\t\tuv = uv * 2.0 - 1.0;\n\t\tuv *= mix(vec2(1.0), abs(normalizedMap.rg), uMapIntensity);\n\t\tuv = (uv + 1.0) / 2.0;\n\t}\n\tvec2 suv = uv*2.-1.;\n\n\tvec2 velocity = uVelocity * uResolution;\n\n\tfloat radius = max(0.0,uRadius);\n\t\n\tvec4 smudgedColor = uSmudge > 0. ? createSmudge(uv) : texture2D(uBuffer, uv);\n\n\tvec4 motionBlurredColor = uMotionBlur > 0. ? createMotionBlur(uv,smudgedColor, velocity) : smudgedColor;\n\n\tvec4 bufferColor = motionBlurredColor;\n\tbufferColor.a = bufferColor.a < 1e-10 ? 0.0 : bufferColor.a * uDissipation;\n\t\n\tvec4 brushColor = uIsTexture ? texture2D(uTexture, uv) : vec4(uColor,1.);\n\t\n\tfloat onLine = isOnLine(suv, uPrevMouse, uMouse, radius, uPressureStart,uPressureEnd);\n\tfloat isOnLine = length(velocity) > 0. ? onLine : uIsCursor ? onLine : 0.;\n\n\tvec4 finalColor = mix(bufferColor, brushColor, isOnLine);\n\n\tgl_FragColor = finalColor;\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\n/**\n * @params dpr if dpr is set, it returns the resolution which is size multiplied by dpr.\n */\nexport const useResolution = (size: Size, dpr: number | false = false) => {\n   const _width = dpr ? size.width * dpr : size.width;\n   const _height = dpr ? size.height * dpr : size.height;\n   const resolution = useMemo(\n      () => new THREE.Vector2(_width, _height),\n      [_width, _height]\n   );\n   return resolution;\n};\n","import * as THREE from \"three\";\nimport { useEffect, useMemo } from \"react\";\n\n/** Generate mesh from geometry and material and add to scene */\nexport const useAddMesh = (\n   scene: THREE.Scene,\n   geometry: THREE.BufferGeometry,\n   material: THREE.Material\n) => {\n   const mesh = useMemo(\n      () => new THREE.Mesh(geometry, material),\n      [geometry, material]\n   );\n\n   useEffect(() => {\n      scene.add(mesh);\n   }, [scene, mesh]);\n\n   useEffect(() => {\n      return () => {\n         scene.remove(mesh);\n         geometry.dispose();\n         material.dispose();\n      };\n   }, [scene, geometry, material, mesh]);\n\n   return mesh;\n};\n","type UniformValue =\n   | THREE.CubeTexture\n   | THREE.Texture\n   | Int32Array\n   | Float32Array\n   | THREE.Matrix4\n   | THREE.Matrix3\n   | THREE.Quaternion\n   | THREE.Vector4\n   | THREE.Vector3\n   | THREE.Vector2\n   | THREE.Color\n   | number\n   | boolean\n   | Array<any>\n   | null;\ntype UniformObject = { [key: string]: { value: UniformValue } };\n\nexport const setUniform = <T extends UniformObject>(\n   material: { uniforms: T },\n   key: keyof T,\n   value: UniformValue\n) => {\n   if (\n      material.uniforms &&\n      material.uniforms[key] &&\n      value !== undefined &&\n      value !== null\n   ) {\n      material.uniforms[key].value = value;\n   } else {\n      console.error(\n         `Uniform key \"${String(\n            key\n         )}\" does not exist in the material. or \"${String(\n            key\n         )}\" is null | undefined`\n      );\n   }\n};\n","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useEffect, useMemo } from \"react\";\nimport { useResolution } from \"../../../utils/useResolution\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\nexport class BrushMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uBuffer: { value: THREE.Texture };\n      uTexture: { value: THREE.Texture };\n      uIsTexture: { value: boolean };\n      uMap: { value: THREE.Texture };\n      uIsMap: { value: boolean };\n      uMapIntensity: { value: number };\n      uResolution: { value: THREE.Texture };\n      uRadius: { value: number };\n      uSmudge: { value: number };\n      uDissipation: { value: number };\n      uMotionBlur: { value: number };\n      uMotionSample: { value: number };\n      uMouse: { value: number };\n      uPrevMouse: { value: number };\n      uVelocity: { value: number };\n      uColor: { value: THREE.Vector3 };\n      uIsCursor: { value: boolean };\n      uPressureStart: { value: number };\n      uPressureEnd: { value: number };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uBuffer: { value: new THREE.Texture() },\n               uResolution: { value: new THREE.Vector2(0, 0) },\n               uTexture: { value: new THREE.Texture() },\n               uIsTexture: { value: false },\n               uMap: { value: new THREE.Texture() },\n               uIsMap: { value: false },\n               uMapIntensity: { value: 0.0 },\n               uRadius: { value: 0.0 },\n               uSmudge: { value: 0.0 },\n               uDissipation: { value: 0.0 },\n               uMotionBlur: { value: 0.0 },\n               uMotionSample: { value: 0 },\n               uMouse: { value: new THREE.Vector2(-10, -10) },\n               uPrevMouse: { value: new THREE.Vector2(-10, -10) },\n               uVelocity: { value: new THREE.Vector2(0, 0) },\n               uColor: { value: new THREE.Vector3(1, 0, 0) },\n               uIsCursor: { value: false },\n               uPressureStart: { value: 1.0 },\n               uPressureEnd: { value: 1.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as BrushMaterial;\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(material, \"uResolution\", resolution.clone());\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material;\n};\n","import * as THREE from \"three\";\nimport { useResolution } from \"./useResolution\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\nconst getCameraProps = (width: number, height: number) => {\n   const frustumSize = height;\n   const aspect = width / height;\n   const [w, h] = [(frustumSize * aspect) / 2, frustumSize / 2];\n   return { width: w, height: h, near: -1000, far: 1000 };\n};\n\nexport const useCamera = (size: Size) => {\n   const resolution = useResolution(size);\n   const { width, height, near, far } = getCameraProps(\n      resolution.x,\n      resolution.y\n   );\n   const camera = useMemo(\n      () =>\n         new THREE.OrthographicCamera(\n            -width,\n            width,\n            height,\n            -height,\n            near,\n            far\n         ),\n      [width, height, near, far]\n   );\n   return camera;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useRef } from \"react\";\n\nexport type PointerValues = {\n   currentPointer: THREE.Vector2;\n   prevPointer: THREE.Vector2;\n   diffPointer: THREE.Vector2;\n   velocity: THREE.Vector2;\n   isVelocityUpdate: boolean;\n};\n\ntype UpdatePointer = (currentPointer: THREE.Vector2) => PointerValues;\n\n/**\n * @description When given the pointer vector2 from r3f's RootState, it generates an update function that returns {`currentPointer`, `prevPointer`, `diffPointer`, `isVelocityUpdate`, `velocity`}.\n * @description When calling custom in a `useFrame` loop, you can avoid duplication of execution by passing `pointerValues` to the update function of a Pointer-activated fxHook, such as `useBrush`.\n * @param lerp 0~1, lerp intensity (0 to less than 1) , default: 0\n */\nexport const usePointer = (lerp: number = 0): UpdatePointer => {\n   const prevPointer = useRef(new THREE.Vector2(0, 0));\n   const diffPointer = useRef(new THREE.Vector2(0, 0));\n   const lerpPointer = useRef(new THREE.Vector2(0, 0));\n   const lastUpdateTime = useRef<number>(0);\n   const velocity = useRef(new THREE.Vector2(0, 0));\n   const isMoved = useRef(false);\n\n   const updatePointer = useCallback(\n      (currentPointer: THREE.Vector2) => {\n         const now = performance.now();\n\n         // lerp\n         let current: THREE.Vector2;\n         if (isMoved.current && lerp) {\n            lerpPointer.current = lerpPointer.current.lerp(\n               currentPointer,\n               1 - lerp\n            );\n            current = lerpPointer.current.clone();\n         } else {\n            current = currentPointer.clone();\n            lerpPointer.current = current;\n         }\n\n         // first frame\n         if (lastUpdateTime.current === 0) {\n            lastUpdateTime.current = now;\n            prevPointer.current = current;\n         }\n         const deltaTime = Math.max(1, now - lastUpdateTime.current);\n         lastUpdateTime.current = now;\n\n         // get velocity\n         velocity.current\n            .copy(current)\n            .sub(prevPointer.current)\n            .divideScalar(deltaTime);\n         const isUpdate = velocity.current.length() > 0;\n\n         //set prev temp pos\n         const prevTemp = isMoved.current\n            ? prevPointer.current.clone()\n            : current;\n         if (!isMoved.current && isUpdate) {\n            isMoved.current = true;\n         }\n         prevPointer.current = current;\n\n         return {\n            currentPointer: current,\n            prevPointer: prevTemp,\n            diffPointer: diffPointer.current.subVectors(current, prevTemp),\n            velocity: velocity.current,\n            isVelocityUpdate: isUpdate,\n         };\n      },\n      [lerp]\n   );\n\n   return updatePointer;\n};\n","import { useCallback, useRef } from \"react\";\n\ntype UseParamsReturn<T> = [T, (params: Partial<T>) => void];\n\n/**\n * @param params Receives an initial value object. With structuredClone, deep copy and set, but if the object contains a function, just set it.\n */\nexport const useParams = <T extends object>(params: T): UseParamsReturn<T> => {\n   const isContainsFunctions = (obj: object): boolean =>\n      Object.values(obj).some((value) => typeof value === \"function\");\n   const paramsRef = useRef(\n      isContainsFunctions(params) ? params : structuredClone(params)\n   );\n\n   const setParams = useCallback((updateParams: Partial<T>) => {\n      for (const key in updateParams) {\n         const paramKey = key as keyof T;\n         if (\n            paramKey in paramsRef.current &&\n            updateParams[paramKey] !== undefined &&\n            updateParams[paramKey] !== null\n         ) {\n            paramsRef.current[paramKey] = updateParams[paramKey]!;\n         } else {\n            console.error(\n               `\"${String(\n                  paramKey\n               )}\" does not exist in the params. or \"${String(\n                  paramKey\n               )}\" is null | undefined`\n            );\n         }\n      }\n   }, []);\n   return [paramsRef.current, setParams];\n};\n","import * as THREE from \"three\";\nimport {\n   useCallback,\n   useEffect,\n   useLayoutEffect,\n   useMemo,\n   useRef,\n} from \"react\";\nimport { useResolution } from \"./useResolution\";\nimport { Size } from \"@react-three/fiber\";\n\nexport const FBO_OPTION: THREE.RenderTargetOptions = {\n   minFilter: THREE.LinearFilter,\n   magFilter: THREE.LinearFilter,\n   type: THREE.HalfFloatType,\n   stencilBuffer: false,\n};\n\nexport type UseFboProps = {\n   scene: THREE.Scene;\n   camera: THREE.Camera;\n   size: Size;\n   /** If dpr is set, dpr will be multiplied, default:false */\n   dpr?: number | false;\n   /** Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false */\n   isSizeUpdate?: boolean;\n   /** Defines the count of MSAA samples. Can only be used with WebGL 2. Default is 0. */\n   samples?: number;\n   /** Renders to the depth buffer. Unlike the three.js,　Default is false. */\n   depthBuffer?: boolean;\n   /** If set, the scene depth will be rendered to this texture. Default is false. */\n   depthTexture?: boolean;\n};\n\nexport const renderFBO = ({\n   gl,\n   fbo,\n   scene,\n   camera,\n   onBeforeRender,\n   onSwap,\n}: {\n   gl: THREE.WebGLRenderer;\n   fbo: THREE.WebGLRenderTarget;\n   scene: THREE.Scene;\n   camera: THREE.Camera;\n   onBeforeRender: () => void;\n   onSwap?: () => void;\n}) => {\n   gl.setRenderTarget(fbo);\n   onBeforeRender();\n   gl.clear();\n   gl.render(scene, camera);\n   onSwap && onSwap();\n   gl.setRenderTarget(null);\n   gl.clear();\n};\n\ntype UpdateRenderTarget = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({ read }: { read: THREE.Texture }) => void\n) => THREE.Texture;\n\ntype UseSingleFBOReturn = [THREE.WebGLRenderTarget, UpdateRenderTarget];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [THREE.WebGLRenderTarget , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useSingleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n   samples = 0,\n   depthBuffer = false,\n   depthTexture = false,\n}: UseFboProps): UseSingleFBOReturn => {\n   const renderTarget = useRef<THREE.WebGLRenderTarget>();\n\n   const resolution = useResolution(size, dpr);\n\n   renderTarget.current = useMemo(\n      () => {\n         const target = new THREE.WebGLRenderTarget(\n            resolution.x,\n            resolution.y,\n            {\n               ...FBO_OPTION,\n               samples,\n               depthBuffer,\n            }\n         );\n         if (depthTexture) {\n            target.depthTexture = new THREE.DepthTexture(\n               resolution.x,\n               resolution.y,\n               THREE.FloatType\n            );\n         }\n         return target;\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      []\n   );\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current?.setSize(resolution.x, resolution.y);\n      }\n   }, [resolution, isSizeUpdate]);\n\n   useEffect(() => {\n      const temp = renderTarget.current;\n      return () => {\n         temp?.dispose();\n      };\n   }, []);\n\n   const updateRenderTarget: UpdateRenderTarget = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current!;\n         renderFBO({\n            gl,\n            fbo,\n            scene,\n            camera,\n            onBeforeRender: () =>\n               onBeforeRender && onBeforeRender({ read: fbo.texture }),\n         });\n         return fbo.texture;\n      },\n      [scene, camera]\n   );\n\n   return [renderTarget.current, updateRenderTarget];\n};\n","import * as THREE from \"three\";\nimport {\n   useCallback,\n   useEffect,\n   useLayoutEffect,\n   useMemo,\n   useRef,\n} from \"react\";\nimport { FBO_OPTION, UseFboProps, renderFBO } from \"./useSingleFBO\";\nimport { useResolution } from \"./useResolution\";\n\nexport type DoubleRenderTarget = {\n   read: THREE.WebGLRenderTarget | null;\n   write: THREE.WebGLRenderTarget | null;\n};\n\ninterface WebGLDoubleRenderTarget extends DoubleRenderTarget {\n   swap: () => void;\n}\n\ntype FBOUpdateFunction = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({\n      read,\n      write,\n   }: {\n      read: THREE.Texture;\n      write: THREE.Texture;\n   }) => void\n) => THREE.Texture;\n\ntype UseDoubleFBOReturn = [\n   { read: THREE.WebGLRenderTarget; write: THREE.WebGLRenderTarget },\n   FBOUpdateFunction\n];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [{read:THREE.WebGLRenderTarget,write:THREE.WebGLRenderTarget} , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useDoubleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n   samples = 0,\n   depthBuffer = false,\n   depthTexture = false,\n}: UseFboProps): UseDoubleFBOReturn => {\n   const renderTarget = useRef<WebGLDoubleRenderTarget>({\n      read: null,\n      write: null,\n      swap: function () {\n         let temp = this.read;\n         this.read = this.write;\n         this.write = temp;\n      },\n   });\n\n   const resolution = useResolution(size, dpr);\n\n   const initRenderTargets = useMemo(() => {\n      const read = new THREE.WebGLRenderTarget(resolution.x, resolution.y, {\n         ...FBO_OPTION,\n         samples,\n         depthBuffer,\n      });\n      const write = new THREE.WebGLRenderTarget(resolution.x, resolution.y, {\n         ...FBO_OPTION,\n         samples,\n         depthBuffer,\n      });\n\n      if (depthTexture) {\n         read.depthTexture = new THREE.DepthTexture(\n            resolution.x,\n            resolution.y,\n            THREE.FloatType\n         );\n         write.depthTexture = new THREE.DepthTexture(\n            resolution.x,\n            resolution.y,\n            THREE.FloatType\n         );\n      }\n\n      return { read, write };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, []);\n\n   renderTarget.current.read = initRenderTargets.read;\n   renderTarget.current.write = initRenderTargets.write;\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current.read?.setSize(resolution.x, resolution.y);\n         renderTarget.current.write?.setSize(resolution.x, resolution.y);\n      }\n   }, [resolution, isSizeUpdate]);\n\n   useEffect(() => {\n      const temp = renderTarget.current;\n      return () => {\n         temp.read?.dispose();\n         temp.write?.dispose();\n      };\n   }, []);\n\n   const updateRenderTarget: FBOUpdateFunction = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current;\n         renderFBO({\n            gl,\n            scene,\n            camera,\n            fbo: fbo.write!,\n            onBeforeRender: () =>\n               onBeforeRender &&\n               onBeforeRender({\n                  read: fbo.read!.texture,\n                  write: fbo.write!.texture,\n               }),\n            onSwap: () => fbo.swap(),\n         });\n         return fbo.read?.texture as THREE.Texture;\n      },\n      [scene, camera]\n   );\n\n   return [\n      { read: renderTarget.current.read, write: renderTarget.current.write },\n      updateRenderTarget,\n   ];\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { RootState } from \"@react-three/fiber\";\nimport { PointerValues, usePointer } from \"../../../misc/usePointer\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { DoubleRenderTarget, useDoubleFBO } from \"../../../utils/useDoubleFBO\";\n\nexport type BrushParams = {\n   /** Texture applied to the brush, If texture is true, it will take precedence over color , default:false */\n   texture?: THREE.Texture | false;\n   /** You can attach an fx map , default:false */\n   map?: THREE.Texture | false;\n   /** map intensity , default:0.1 */\n   mapIntensity?: number;\n   /** size of the stamp, percentage of the size ,default:0.05 */\n   radius?: number;\n   /** Strength of smudge effect , default:0.0*/\n   smudge?: number;\n   /** dissipation rate. If set to 1, it will remain. ,default:1.0 */\n   dissipation?: number;\n   /** Strength of motion blur , default:0.0 */\n   motionBlur?: number;\n   /** Number of motion blur samples. Affects performance default: 5 */\n   motionSample?: number;\n   /** brush color , it accepts a function that returns THREE.Vector3.The function takes velocity:THREE.Vector2 as an argument. , default:THREE.Vector3(1.0, 1.0, 1.0) */\n   color?: ((velocity: THREE.Vector2) => THREE.Vector3) | THREE.Vector3;\n   /** Follows the cursor even if it loses speed , default:false */\n   isCursor?: boolean;\n   /** brush pressure (0 to 1) , default : 1.0 */\n   pressure?: number;\n   /** When calling usePointer in a frame loop, setting PointerValues ​​to this value prevents double calls , default:false */\n   pointerValues?: PointerValues | false;\n};\n\nexport type BrushObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: DoubleRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const BRUSH_PARAMS: BrushParams = {\n   texture: false,\n   map: false,\n   mapIntensity: 0.1,\n   radius: 0.05,\n   smudge: 0.0,\n   dissipation: 1.0,\n   motionBlur: 0.0,\n   motionSample: 5,\n   color: new THREE.Vector3(1.0, 0.0, 0.0),\n   isCursor: false,\n   pressure: 1.0,\n   pointerValues: false,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useBrush = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<BrushParams, BrushObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useDoubleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n   });\n\n   const [params, setParams] = useParams<BrushParams>(BRUSH_PARAMS);\n\n   const pressureEnd = useRef<number | null>(null);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: BrushParams) => {\n         const { gl, pointer } = props;\n\n         updateParams && setParams(updateParams);\n\n         if (params.texture!) {\n            setUniform(material, \"uIsTexture\", true);\n            setUniform(material, \"uTexture\", params.texture!);\n         } else {\n            setUniform(material, \"uIsTexture\", false);\n         }\n\n         if (params.map!) {\n            setUniform(material, \"uIsMap\", true);\n            setUniform(material, \"uMap\", params.map!);\n            setUniform(material, \"uMapIntensity\", params.mapIntensity!);\n         } else {\n            setUniform(material, \"uIsMap\", false);\n         }\n\n         setUniform(material, \"uRadius\", params.radius!);\n         setUniform(material, \"uSmudge\", params.smudge!);\n         setUniform(material, \"uDissipation\", params.dissipation!);\n         setUniform(material, \"uMotionBlur\", params.motionBlur!);\n         setUniform(material, \"uMotionSample\", params.motionSample!);\n\n         const pointerValues = params.pointerValues! || updatePointer(pointer);\n\n         if (pointerValues.isVelocityUpdate) {\n            setUniform(material, \"uMouse\", pointerValues.currentPointer);\n            setUniform(material, \"uPrevMouse\", pointerValues.prevPointer);\n         }\n         setUniform(material, \"uVelocity\", pointerValues.velocity);\n\n         const color: THREE.Vector3 =\n            typeof params.color === \"function\"\n               ? params.color(pointerValues.velocity)\n               : params.color!;\n         setUniform(material, \"uColor\", color);\n\n         setUniform(material, \"uIsCursor\", params.isCursor!);\n\n         // pressure\n         setUniform(material, \"uPressureEnd\", params.pressure!);\n         if (pressureEnd.current === null) {\n            pressureEnd.current = params.pressure!;\n         }\n         setUniform(material, \"uPressureStart\", pressureEnd.current);\n         pressureEnd.current = params.pressure!;\n\n         return updateRenderTarget(gl, ({ read }) => {\n            setUniform(material, \"uBuffer\", read);\n         });\n      },\n      [material, updatePointer, updateRenderTarget, params, setParams]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.read.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform vec2 texelSize;\n\nvoid main () {\n\tvUv = uv;\n\tvL = vUv - vec2(texelSize.x, 0.0);\n\tvR = vUv + vec2(texelSize.x, 0.0);\n\tvT = vUv + vec2(0.0, texelSize.y);\n\tvB = vUv - vec2(0.0, texelSize.y);\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvoid main(){\n\tgl_FragColor = vec4(0.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/init.frag\";\n\nexport const useInitialMaterial = () => {\n   const initialMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      []\n   );\n\n   return initialMaterial as THREE.ShaderMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D uVelocity;\nuniform sampler2D uSource;\nuniform vec2 texelSize;\nuniform float dt;\nuniform float dissipation;\n\nvoid main () {\n\tvec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n\tgl_FragColor = dissipation * texture2D(uSource, coord);\n\tgl_FragColor.a = 1.0;\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/advection.frag\";\n\nexport class AdvectionMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uVelocity: { value: THREE.Texture };\n      uSource: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n      dt: { value: number };\n      dissipation: { value: number };\n   };\n}\n\nexport const useAdvectionMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: new THREE.Texture() },\n               uSource: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n               dt: { value: 0.0 },\n               dissipation: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as AdvectionMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvec2 sampleVelocity (in vec2 uv) {\n\tvec2 multiplier = vec2(1.0, 1.0);\n\tif (uv.x < 0.0) { uv.x = 0.0; multiplier.x = -1.0; }\n\tif (uv.x > 1.0) { uv.x = 1.0; multiplier.x = -1.0; }\n\tif (uv.y < 0.0) { uv.y = 0.0; multiplier.y = -1.0; }\n\tif (uv.y > 1.0) { uv.y = 1.0; multiplier.y = -1.0; }\n\treturn multiplier * texture2D(uVelocity, uv).xy;\n}\n\nvoid main () {\n\tfloat L = sampleVelocity(vL).x;\n\tfloat R = sampleVelocity(vR).x;\n\tfloat T = sampleVelocity(vT).y;\n\tfloat B = sampleVelocity(vB).y;\n\tfloat div = 0.5 * (R - L + T - B);\n\tgl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/divergence.frag\";\n\nexport class DivergenceMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uVelocity: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useDivergenceMaterial = () => {\n   const divergenceMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return divergenceMaterial as DivergenceMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uDivergence;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tfloat C = texture2D(uPressure, vUv).x;\n\tfloat divergence = texture2D(uDivergence, vUv).x;\n\tfloat pressure = (L + R + B + T - divergence) * 0.25;\n\tgl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/pressure.frag\";\n\nexport class PressureMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uPressure: { value: THREE.Texture };\n      uDivergence: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const usePressureMaterial = () => {\n   const pressureMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: null },\n               uDivergence: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return pressureMaterial as PressureMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvoid main () {\n\tfloat L = texture2D(uVelocity, vL).y;\n\tfloat R = texture2D(uVelocity, vR).y;\n\tfloat T = texture2D(uVelocity, vT).x;\n\tfloat B = texture2D(uVelocity, vB).x;\n\tfloat vorticity = R - L - T + B;\n\tgl_FragColor = vec4(vorticity, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/curl.frag\";\n\nexport class CurlMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uVelocity: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useCurlMaterial = () => {\n   const curlMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return curlMaterial as CurlMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\nuniform sampler2D uCurl;\nuniform float curl;\nuniform float dt;\n\nvoid main () {\n\tfloat T = texture2D(uCurl, vT).x;\n\tfloat B = texture2D(uCurl, vB).x;\n\tfloat C = texture2D(uCurl, vUv).x;\n\tvec2 force = vec2(abs(T) - abs(B), 0.0);\n\tforce *= 1.0 / length(force + 0.00001) * curl * C;\n\tvec2 vel = texture2D(uVelocity, vUv).xy;\n\tgl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/vorticity.frag\";\n\nexport class VorticityMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uVelocity: { value: THREE.Texture };\n      uCurl: { value: THREE.Texture };\n      curl: { value: number };\n      dt: { value: number };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useVorticityMaterial = () => {\n   const vorticityMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               uCurl: { value: null },\n               curl: { value: 0 },\n               dt: { value: 0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return vorticityMaterial as VorticityMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform float value;\n\nvoid main () {\n\tgl_FragColor = value * texture2D(uTexture, vUv);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/clear.frag\";\n\nexport class ClearMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      value: { value: number };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useClearMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               value: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as ClearMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uVelocity;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tvec2 velocity = texture2D(uVelocity, vUv).xy;\n\tvelocity.xy -= vec2(R - L, T - B);\n\tgl_FragColor = vec4(velocity, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/gradientSubtract.frag\";\n\nexport class GradientSubtractMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uPressure: { value: THREE.Texture };\n      uVelocity: { value: THREE.Texture };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useGradientSubtractMaterial = () => {\n   const gradientSubtractMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: new THREE.Texture() },\n               uVelocity: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return gradientSubtractMaterial as GradientSubtractMaterial;\n};\n","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D uTarget;\nuniform float aspectRatio;\nuniform vec3 color;\nuniform vec2 point;\nuniform float radius;\n\nvoid main () {\n\tvec2 nPoint = (point + vec2(1.0)) * 0.5;\n\tvec2 p = vUv - nPoint.xy;\n\tp.x *= aspectRatio;\n\tvec3 splat = exp(-dot(p, p) / radius) * color;\n\tvec3 base = texture2D(uTarget, vUv).xyz;\n\tgl_FragColor = vec4(base + splat, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/splat.frag\";\n\nexport class SplatMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTarget: { value: THREE.Texture };\n      aspectRatio: { value: number };\n      color: { value: THREE.Vector3 };\n      point: { value: THREE.Vector2 };\n      radius: { value: number };\n      texelSize: { value: THREE.Vector2 };\n   };\n}\n\nexport const useSplateMaterial = () => {\n   const splatMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTarget: { value: new THREE.Texture() },\n               aspectRatio: { value: 0 },\n               color: { value: new THREE.Vector3() },\n               point: { value: new THREE.Vector2() },\n               radius: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return splatMaterial as SplatMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo } from \"react\";\nimport { useInitialMaterial } from \"./materials/useInitialMaterial\";\nimport {\n   AdvectionMaterial,\n   useAdvectionMaterial,\n} from \"./materials/useAdvectionMaterial\";\nimport {\n   DivergenceMaterial,\n   useDivergenceMaterial,\n} from \"./materials/useDivergenceMaterial\";\nimport {\n   PressureMaterial,\n   usePressureMaterial,\n} from \"./materials/usePressureMaterial\";\nimport { CurlMaterial, useCurlMaterial } from \"./materials/useCurlMaterial\";\nimport {\n   VorticityMaterial,\n   useVorticityMaterial,\n} from \"./materials/useVorticityMaterial\";\nimport { useResolution } from \"../../../utils/useResolution\";\nimport { ClearMaterial, useClearMaterial } from \"./materials/useClearMaterial\";\nimport {\n   GradientSubtractMaterial,\n   useGradientSubtractMaterial,\n} from \"./materials/useGradientSubtractMaterial\";\nimport { SplatMaterial, useSplateMaterial } from \"./materials/useSplatMaterial\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TMaterials =\n   | AdvectionMaterial\n   | DivergenceMaterial\n   | CurlMaterial\n   | PressureMaterial\n   | ClearMaterial\n   | GradientSubtractMaterial\n   | SplatMaterial;\n\nexport type FluidMaterials = {\n   vorticityMaterial: VorticityMaterial;\n   curlMaterial: CurlMaterial;\n   advectionMaterial: AdvectionMaterial;\n   divergenceMaterial: DivergenceMaterial;\n   pressureMaterial: PressureMaterial;\n   clearMaterial: ClearMaterial;\n   gradientSubtractMaterial: GradientSubtractMaterial;\n   splatMaterial: SplatMaterial;\n};\ntype TUseMeshReturnType = [FluidMaterials, (material: TMaterials) => void];\n\n/**\n * Returns the material update function in the second argument\n */\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}): TUseMeshReturnType => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const initialMaterial = useInitialMaterial();\n   const updateMaterial = initialMaterial.clone();\n   const curlMaterial = useCurlMaterial();\n   const vorticityMaterial = useVorticityMaterial();\n   const advectionMaterial = useAdvectionMaterial();\n   const divergenceMaterial = useDivergenceMaterial();\n   const pressureMaterial = usePressureMaterial();\n   const clearMaterial = useClearMaterial();\n   const gradientSubtractMaterial = useGradientSubtractMaterial();\n   const splatMaterial = useSplateMaterial();\n   const materials = useMemo(\n      () => ({\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      }),\n      [\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      ]\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(\n         materials.splatMaterial,\n         \"aspectRatio\",\n         resolution.x / resolution.y\n      );\n      for (const material of Object.values(materials)) {\n         setUniform<typeof material.uniforms>(\n            material,\n            \"texelSize\",\n            new THREE.Vector2(1.0 / resolution.x, 1.0 / resolution.y)\n         );\n      }\n   }, [resolution, materials]);\n\n   const mesh = useAddMesh(scene, geometry, initialMaterial);\n   useEffect(() => {\n      initialMaterial.dispose();\n      mesh.material = updateMaterial;\n   }, [initialMaterial, mesh, updateMaterial]);\n\n   useEffect(() => {\n      return () => {\n         for (const material of Object.values(materials)) {\n            material.dispose();\n         }\n      };\n   }, [materials]);\n\n   const setMeshMaterial = useCallback(\n      (material: TMaterials) => {\n         mesh.material = material;\n         mesh.material.needsUpdate = true;\n      },\n      [mesh]\n   );\n\n   return [materials, setMeshMaterial];\n};\n","import * as THREE from \"three\";\nimport { FluidMaterials, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { PointerValues, usePointer } from \"../../../misc/usePointer\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { UseFboProps } from \"../../../utils/useSingleFBO\";\nimport { DoubleRenderTarget, useDoubleFBO } from \"../../../utils/useDoubleFBO\";\n\nexport type FluidParams = {\n   /** density disspation , default:0.98 */\n   density_dissipation?: number;\n   /** velocity dissipation , default:0.99 */\n   velocity_dissipation?: number;\n   /** velocity acceleration , default:10.0 */\n   velocity_acceleration?: number;\n   /** pressure dissipation , default:0.9 */\n   pressure_dissipation?: number;\n   /** pressure iterations. affects performance , default:20 */\n   pressure_iterations?: number;\n   /** curl_strength , default:35 */\n   curl_strength?: number;\n   /** splat radius , default:0.002 */\n   splat_radius?: number;\n   /** Fluid Color.THREE.Vector3 Alternatively, it accepts a function that returns THREE.Vector3.The function takes velocity:THREE.Vector2 as an argument. , default:THREE.Vector3(1.0, 1.0, 1.0) */\n   fluid_color?: ((velocity: THREE.Vector2) => THREE.Vector3) | THREE.Vector3;\n   /** When calling usePointer in a frame loop, setting PointerValues ​​to this value prevents double calls , default:false */\n   pointerValues?: PointerValues | false;\n};\n\nexport type FluidObject = {\n   scene: THREE.Scene;\n   materials: FluidMaterials;\n   camera: THREE.Camera;\n   renderTarget: {\n      velocity: DoubleRenderTarget;\n      density: DoubleRenderTarget;\n      curl: THREE.WebGLRenderTarget;\n      divergence: THREE.WebGLRenderTarget;\n      pressure: DoubleRenderTarget;\n   };\n   output: THREE.Texture;\n};\n\nexport const FLUID_PARAMS: FluidParams = {\n   density_dissipation: 0.98,\n   velocity_dissipation: 0.99,\n   velocity_acceleration: 10.0,\n   pressure_dissipation: 0.9,\n   pressure_iterations: 20,\n   curl_strength: 35,\n   splat_radius: 0.002,\n   fluid_color: new THREE.Vector3(1.0, 1.0, 1.0),\n   pointerValues: false,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useFluid = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<FluidParams, FluidObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const [materials, setMeshMaterial] = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n\n   const fboProps = useMemo<UseFboProps>(\n      () => ({\n         scene,\n         camera,\n         size,\n         samples,\n      }),\n      [scene, camera, size, samples]\n   );\n   const [velocityFBO, updateVelocityFBO] = useDoubleFBO(fboProps);\n   const [densityFBO, updateDensityFBO] = useDoubleFBO(fboProps);\n   const [curlFBO, updateCurlFBO] = useSingleFBO(fboProps);\n   const [divergenceFBO, updateDivergenceFBO] = useSingleFBO(fboProps);\n   const [pressureFBO, updatePressureFBO] = useDoubleFBO(fboProps);\n\n   const lastTime = useRef(0);\n   const scaledDiffVec = useRef(new THREE.Vector2(0, 0));\n   const spaltVec = useRef(new THREE.Vector3(0, 0, 0));\n\n   const [params, setParams] = useParams<FluidParams>(FLUID_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FluidParams) => {\n         const { gl, pointer, clock, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         if (lastTime.current === 0) {\n            lastTime.current = clock.getElapsedTime();\n         }\n         const dt = Math.min(\n            (clock.getElapsedTime() - lastTime.current) / 3,\n            0.02\n         );\n         lastTime.current = clock.getElapsedTime();\n\n         // update velocity\n         const velocityTex = updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", read);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(materials.advectionMaterial, \"dt\", dt);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.velocity_dissipation!\n            );\n         });\n\n         // update density\n         const densityTex = updateDensityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", velocityTex);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.density_dissipation!\n            );\n         });\n\n         // update splatting\n         const pointerValues = params.pointerValues! || updatePointer(pointer);\n\n         if (pointerValues.isVelocityUpdate) {\n            updateVelocityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               setUniform(\n                  materials.splatMaterial,\n                  \"point\",\n                  pointerValues.currentPointer\n               );\n               const scaledDiff = pointerValues.diffPointer.multiply(\n                  scaledDiffVec.current\n                     .set(size.width, size.height)\n                     .multiplyScalar(params.velocity_acceleration!)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"color\",\n                  spaltVec.current.set(scaledDiff.x, scaledDiff.y, 1.0)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"radius\",\n                  params.splat_radius!\n               );\n            });\n            updateDensityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               const color: THREE.Vector3 =\n                  typeof params.fluid_color === \"function\"\n                     ? params.fluid_color(pointerValues.velocity)\n                     : params.fluid_color!;\n               setUniform(materials.splatMaterial, \"color\", color);\n            });\n         }\n\n         // update curl\n         const curlTex = updateCurlFBO(gl, () => {\n            setMeshMaterial(materials.curlMaterial);\n            setUniform(materials.curlMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update vorticity\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.vorticityMaterial);\n            setUniform(materials.vorticityMaterial, \"uVelocity\", read);\n            setUniform(materials.vorticityMaterial, \"uCurl\", curlTex);\n            setUniform(\n               materials.vorticityMaterial,\n               \"curl\",\n               params.curl_strength!\n            );\n            setUniform(materials.vorticityMaterial, \"dt\", dt);\n         });\n\n         // update divergence\n         const divergenceTex = updateDivergenceFBO(gl, () => {\n            setMeshMaterial(materials.divergenceMaterial);\n            setUniform(materials.divergenceMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update pressure\n         updatePressureFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.clearMaterial);\n            setUniform(materials.clearMaterial, \"uTexture\", read);\n            setUniform(\n               materials.clearMaterial,\n               \"value\",\n               params.pressure_dissipation!\n            );\n         });\n\n         // solve pressure iterative (Gauss-Seidel)\n         setMeshMaterial(materials.pressureMaterial);\n         setUniform(materials.pressureMaterial, \"uDivergence\", divergenceTex);\n         let pressureTexTemp: THREE.Texture;\n         for (let i = 0; i < params.pressure_iterations!; i++) {\n            pressureTexTemp = updatePressureFBO(gl, ({ read }) => {\n               setUniform(materials.pressureMaterial, \"uPressure\", read);\n            });\n         }\n\n         // update gradienSubtract\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.gradientSubtractMaterial);\n            setUniform(\n               materials.gradientSubtractMaterial,\n               \"uPressure\",\n               pressureTexTemp\n            );\n            setUniform(materials.gradientSubtractMaterial, \"uVelocity\", read);\n         });\n\n         return densityTex;\n      },\n      [\n         materials,\n         setMeshMaterial,\n         updateCurlFBO,\n         updateDensityFBO,\n         updateDivergenceFBO,\n         updatePointer,\n         updatePressureFBO,\n         updateVelocityFBO,\n         setParams,\n         params,\n      ]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         materials: materials,\n         camera: camera,\n         renderTarget: {\n            velocity: velocityFBO,\n            density: densityFBO,\n            curl: curlFBO,\n            divergence: divergenceFBO,\n            pressure: pressureFBO,\n         },\n         output: densityFBO.read.texture,\n      },\n   ];\n};\n","import { useEffect, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\n\ntype UseMeshProps = {\n   scale: number;\n   max: number;\n   texture?: THREE.Texture;\n   scene: THREE.Scene;\n};\n\nexport const useMesh = ({ scale, max, texture, scene }: UseMeshProps) => {\n   const meshArr = useRef<THREE.Mesh[]>([]);\n   const geometry = useMemo(\n      () => new THREE.PlaneGeometry(scale, scale),\n      [scale]\n   );\n   const material = useMemo(\n      () =>\n         new THREE.MeshBasicMaterial({\n            map: texture,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      [texture]\n   );\n\n   useEffect(() => {\n      for (let i = 0; i < max; i++) {\n         const mesh = new THREE.Mesh(geometry.clone(), material.clone());\n         mesh.rotateZ(2 * Math.PI * Math.random());\n         mesh.visible = false;\n         scene.add(mesh);\n         meshArr.current.push(mesh);\n      }\n   }, [geometry, material, scene, max]);\n\n   useEffect(() => {\n      return () => {\n         meshArr.current.forEach((mesh) => {\n            mesh.geometry.dispose();\n            if (Array.isArray(mesh.material)) {\n               mesh.material.forEach((material) => material.dispose());\n            } else {\n               mesh.material.dispose();\n            }\n            scene.remove(mesh);\n         });\n         meshArr.current = [];\n      };\n   }, [scene]);\n\n   return meshArr.current;\n};\n","import { useCallback, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { usePointer, PointerValues } from \"../../../misc/usePointer\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\n\nexport type RippleParams = {\n   /** How often ripples appear,default:0.01 */\n   frequency?: number;\n   /** rotation rate,default:0.05 */\n   rotation?: number;\n   /** fadeout speed,default:0.9 */\n   fadeout_speed?: number;\n   /** scale rate,default:0.3 */\n   scale?: number;\n   /** alpha,default:0.6 */\n   alpha?: number;\n   /** When calling usePointer in a frame loop, setting PointerValues ​​to this value prevents double calls , default:false */\n   pointerValues?: PointerValues | false;\n};\n\nexport type RippleObject = {\n   scene: THREE.Scene;\n   meshArr: THREE.Mesh[];\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const RIPPLE_PARAMS: RippleParams = {\n   frequency: 0.01,\n   rotation: 0.05,\n   fadeout_speed: 0.9,\n   scale: 0.3,\n   alpha: 0.6,\n   pointerValues: false,\n};\n\ninterface UseRippleProps extends HooksProps {\n   /** texture applied to ripple */\n   texture?: THREE.Texture;\n   /** ripple size, default:64 */\n   scale?: number;\n   /** ripple max length, default:100 */\n   max?: number;\n}\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useRipple = ({\n   texture = new THREE.Texture(),\n   scale = 64,\n   max = 100,\n   size,\n   dpr,\n   samples = 0,\n}: UseRippleProps): HooksReturn<RippleParams, RippleObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const meshArr = useMesh({\n      scale: scale,\n      max: max,\n      texture,\n      scene,\n   });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n   });\n\n   const [params, setParams] = useParams<RippleParams>(RIPPLE_PARAMS);\n\n   const currentWave = useRef(0);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: RippleParams) => {\n         const { gl, pointer, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         const pointerValues = params.pointerValues! || updatePointer(pointer);\n\n         if (params.frequency! < pointerValues.diffPointer.length()) {\n            const mesh = meshArr[currentWave.current];\n            mesh.visible = true;\n            mesh.position.set(\n               pointerValues.currentPointer.x * (size.width / 2),\n               pointerValues.currentPointer.y * (size.height / 2),\n               0\n            );\n            mesh.scale.x = mesh.scale.y = 0.0;\n            (mesh.material as THREE.MeshBasicMaterial).opacity = params.alpha!;\n            currentWave.current = (currentWave.current + 1) % max;\n         }\n         meshArr.forEach((mesh) => {\n            if (mesh.visible) {\n               const material = mesh.material as THREE.MeshBasicMaterial;\n               mesh.rotation.z += params.rotation!;\n               material.opacity *= params.fadeout_speed!;\n               mesh.scale.x =\n                  params.fadeout_speed! * mesh.scale.x + params.scale!;\n               mesh.scale.y = mesh.scale.x;\n               if (material.opacity < 0.002) mesh.visible = false;\n            }\n         });\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, meshArr, updatePointer, max, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         camera: camera,\n         meshArr: meshArr,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\nprecision highp int;\n\nvarying vec2 vUv;\nuniform float uTime;\nuniform float timeStrength;\nuniform int noiseOctaves;\nuniform int fbmOctaves;\nuniform int warpOctaves;\nuniform vec2 warpDirection;\nuniform float warpStrength;\nuniform float scale;\n\nconst float per  = 0.5;\nconst float PI   = 3.14159265359;\n\nfloat rnd(vec2 n) {\n\tfloat a = 0.129898;\n\tfloat b = 0.78233;\n\tfloat c = 437.585453;\n\tfloat dt= dot(n ,vec2(a, b));\n\tfloat sn= mod(dt, PI);\n\treturn fract(sin(sn) * c);\n}\n\nfloat interpolate(float a, float b, float x){\n    float f = (1.0 - cos(x * PI)) * 0.5;\n    return a * (1.0 - f) + b * f;\n}\n\nfloat irnd(vec2 p){\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tvec4 v = vec4(rnd(vec2(i.x,i.y)),rnd(vec2(i.x + 1.0,i.y)),rnd(vec2(i.x,i.y + 1.0)),rnd(vec2(i.x + 1.0, i.y + 1.0)));\n\treturn interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);\n}\n\n// Based on The Book of Shaders\n// https://thebookofshaders.com/13/\nfloat noise(vec2 p, float time){\n\tfloat t = 0.0;\n\tfor(int i = 0; i < noiseOctaves; i++){\n\t\tfloat freq = pow(2.0, float(i));\n\t\tfloat amp  = pow(per, float(noiseOctaves - i));\n\t\tt += irnd(vec2(p.y / freq + time, p.x / freq + time)) * amp;\n\t}\n\treturn t;\n}\n\nfloat fbm(vec2 x, float time) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n\tfloat sign = 1.0;\n\tfor (int i = 0; i < fbmOctaves; ++i) {\n\t\tv += a * noise(x, time * sign);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t\tsign *= -1.0;\n\t}\n\treturn v;\n}\n\nfloat warp(vec2 x, float g,float time){\n\tfloat val = 0.0;\n\tfor (int i = 0; i < warpOctaves; i++){\n\t\tval = fbm(x + g * vec2(cos(warpDirection.x * val), sin(warpDirection.y * val)), time);\n\t}\n\treturn val;\n}\n\nvoid main() {\n\tfloat noise = warp(gl_FragCoord.xy * scale ,warpStrength,uTime * timeStrength);\n\tgl_FragColor = vec4(vec3(noise),1.0);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\n\nexport class NoiseMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTime: { value: number };\n      scale: { value: number };\n      timeStrength: { value: number };\n      noiseOctaves: { value: number };\n      fbmOctaves: { value: number };\n      warpOctaves: { value: number };\n      warpDirection: { value: THREE.Vector2 };\n      warpStrength: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTime: { value: 0.0 },\n               scale: { value: 0.0 },\n               timeStrength: { value: 0.0 },\n               noiseOctaves: { value: 0 },\n               fbmOctaves: { value: 0 },\n               warpOctaves: { value: 0 },\n               warpDirection: { value: new THREE.Vector2() },\n               warpStrength: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as NoiseMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { HooksProps, HooksReturn } from \"../../types\";\n\nexport type NoiseParams = {\n   /** noise scale , default:0.004 */\n   scale?: number;\n   /** time factor default:0.3 */\n   timeStrength?: number;\n   /** noiseOctaves, affects performance default:2 */\n   noiseOctaves?: number;\n   /** fbmOctaves, affects performance default:2 */\n   fbmOctaves?: number;\n   /** domain warping octaves , affects performance default:2  */\n   warpOctaves?: number;\n   /** direction of domain warping , default:(2.0,2,0) */\n   warpDirection?: THREE.Vector2;\n   /** strength of domain warping , default:8.0 */\n   warpStrength?: number;\n   /** you can get into the rhythm ♪ , default:false */\n   beat?: number | false;\n};\n\nexport type NoiseObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const NOISE_PARAMS: NoiseParams = {\n   scale: 0.004,\n   timeStrength: 0.3,\n   noiseOctaves: 2,\n   fbmOctaves: 2,\n   warpOctaves: 2,\n   warpDirection: new THREE.Vector2(2.0, 2.0),\n   warpStrength: 8.0,\n   beat: false,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n *\n * It is a basic value noise with `fbm` and `domain warping`\n */\nexport const useNoise = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<NoiseParams, NoiseObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n   });\n\n   const [params, setParams] = useParams<NoiseParams>(NOISE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: NoiseParams) => {\n         const { gl, clock } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"scale\", params.scale!);\n         setUniform(material, \"timeStrength\", params.timeStrength!);\n         setUniform(material, \"noiseOctaves\", params.noiseOctaves!);\n         setUniform(material, \"fbmOctaves\", params.fbmOctaves!);\n         setUniform(material, \"warpOctaves\", params.warpOctaves!);\n         setUniform(material, \"warpDirection\", params.warpDirection!);\n         setUniform(material, \"warpStrength\", params.warpStrength!);\n\n         setUniform(material, \"uTime\", params.beat || clock.getElapsedTime());\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\nvarying vec2 vUv;\n\nuniform sampler2D uTexture;\nuniform bool isTexture;\nuniform sampler2D noise;\nuniform bool isNoise;\nuniform vec2 noiseStrength;\nuniform float laminateLayer;\nuniform vec2 laminateInterval;\nuniform vec2 laminateDetail;\nuniform vec2 distortion;\nuniform vec3 colorFactor;\nuniform float uTime;\nuniform vec2 timeStrength;\nuniform float scale;\n\nvoid main() {\n\tvec2 uv = vUv;\n\n\tvec2 pos = isTexture ? texture2D(uTexture, uv).rg : uv * scale;\n\tvec2 noise = isNoise ? texture2D(noise, uv).rg : vec2(0.0);\n\tfloat alpha = isTexture ? texture2D(uTexture, uv).a : 1.0;\n\t\n\t// Avoid floating point bugs caused by GPU drivers.\n\talpha = (alpha < 1e-10) ? 0.0 : alpha;\n\n\tvec3 col;\n\tfor(float j = 0.0; j < 3.0; j++){\n\t\tfor(float i = 1.0; i < laminateLayer; i++){\n\t\t\tfloat timeNoiseSin = sin(uTime / (i + j)) * timeStrength.x + noise.r * noiseStrength.x;\n\t\t\tfloat timeNoiseCos = cos(uTime / (i + j)) * timeStrength.y + noise.g * noiseStrength.y;\n\t\t\tpos.x += laminateInterval.x / (i + j) * cos(i * distortion.x * pos.y + timeNoiseSin + sin(i + j));\n\t\t\tpos.y += laminateInterval.y / (i + j) * cos(i * distortion.y * pos.x + timeNoiseCos + sin(i + j));\n\t\t}\n\t\tcol[int(j)] = sin(pow(pos.x, 2.) * pow(laminateDetail.x, 2.)) + sin(pow(pos.y, 2.) * pow(laminateDetail.y, 2.));\n\t}\n\n\tcol *= colorFactor * alpha;\n\tcol = clamp(col, 0.0, 1.0);\n\t\n\tgl_FragColor = vec4(col, alpha);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\n\nexport class ColorStrataMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      isTexture: { value: boolean };\n      scale: { value: number };\n      noise: { value: THREE.Texture };\n      noiseStrength: { value: THREE.Vector2 };\n      isNoise: { value: boolean };\n      laminateLayer: { value: number };\n      laminateInterval: { value: THREE.Vector2 };\n      laminateDetail: { value: THREE.Vector2 };\n      distortion: { value: THREE.Vector2 };\n      colorFactor: { value: THREE.Vector3 };\n      uTime: { value: number };\n      timeStrength: { value: THREE.Vector2 };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               isTexture: { value: false },\n               scale: { value: 1.0 },\n               noise: { value: new THREE.Texture() },\n               noiseStrength: { value: new THREE.Vector2(0, 0) },\n               isNoise: { value: false },\n               laminateLayer: { value: 1.0 },\n               laminateInterval: { value: new THREE.Vector2(0.1, 0.1) },\n               laminateDetail: { value: new THREE.Vector2(1, 1) },\n               distortion: { value: new THREE.Vector2(0, 0) },\n               colorFactor: { value: new THREE.Vector3(1, 1, 1) },\n               uTime: { value: 0 },\n               timeStrength: { value: new THREE.Vector2(0, 0) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as ColorStrataMaterial;\n\n   useAddMesh(scene, geometry, material);\n   return material;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\n\nexport type ColorStrataParams = {\n   /** default: null */\n   texture?: THREE.Texture | false;\n   /** Valid when texture is false. default : 1 */\n   scale?: number;\n   /** default: 1.0 */\n   laminateLayer?: number;\n   /** default: (0.1, 0.1) */\n   laminateInterval?: THREE.Vector2;\n   /** default: (1.0, 1.0) */\n   laminateDetail?: THREE.Vector2;\n   /** default: (0.0, 0.0) */\n   distortion?: THREE.Vector2;\n   /** default: (1.0, 1.0,1.0) */\n   colorFactor?: THREE.Vector3;\n   /** default: (0.0, 0.0) */\n   timeStrength?: THREE.Vector2;\n   /** default:false */\n   noise?: THREE.Texture | false;\n   /** default : (0.0,0.0) */\n   noiseStrength?: THREE.Vector2;\n   /** you can get into the rhythm ♪ , default:false */\n   beat?: number | false;\n};\n\nexport type ColorStrataObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const COLORSTRATA_PARAMS: ColorStrataParams = {\n   texture: false,\n   scale: 1.0,\n   laminateLayer: 1.0,\n   laminateInterval: new THREE.Vector2(0.1, 0.1),\n   laminateDetail: new THREE.Vector2(1, 1),\n   distortion: new THREE.Vector2(0, 0),\n   colorFactor: new THREE.Vector3(1, 1, 1),\n   timeStrength: new THREE.Vector2(0, 0),\n   noise: false,\n   noiseStrength: new THREE.Vector2(0, 0),\n   beat: false,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useColorStrata = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<ColorStrataParams, ColorStrataObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n   });\n\n   const [params, setParams] = useParams<ColorStrataParams>(COLORSTRATA_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: ColorStrataParams) => {\n         const { gl, clock } = props;\n         updateParams && setParams(updateParams);\n\n         if (params.texture) {\n            setUniform(material, \"uTexture\", params.texture);\n            setUniform(material, \"isTexture\", true);\n         } else {\n            setUniform(material, \"isTexture\", false);\n            setUniform(material, \"scale\", params.scale!);\n         }\n\n         if (params.noise) {\n            setUniform(material, \"noise\", params.noise);\n            setUniform(material, \"isNoise\", true);\n            setUniform(material, \"noiseStrength\", params.noiseStrength!);\n         } else {\n            setUniform(material, \"isNoise\", false);\n         }\n\n         setUniform(material, \"uTime\", params.beat || clock.getElapsedTime());\n\n         setUniform(material, \"laminateLayer\", params.laminateLayer!);\n         setUniform(material, \"laminateInterval\", params.laminateInterval!);\n         setUniform(material, \"laminateDetail\", params.laminateDetail!);\n         setUniform(material, \"distortion\", params.distortion!);\n         setUniform(material, \"colorFactor\", params.colorFactor!);\n         setUniform(material, \"timeStrength\", params.timeStrength!);\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform float u_time;\nuniform float u_pattern;\nuniform float u_complexity;\nuniform float u_complexityAttenuation;\nuniform float u_iterations;\nuniform float u_timeStrength;\nuniform float u_scale;\n\nvec3 marble(vec3 p){\n\tvec4 n;\n\tfor(float i;i<u_iterations;i++){\n\t\tp+=sin(p.yzx + u_pattern);\n\t\tn=u_complexity*n+vec4(cross(cos(p + u_pattern),sin(p.zxy + u_pattern)),1.)*(1.+i*u_complexityAttenuation);\n\t\tp*=u_complexity;\n\t}\n\treturn n.xyz/n.w;\n}\n\nvoid main() {\n\tfloat time = u_time * u_timeStrength;\n\tvec3 color = clamp(marble(vec3(gl_FragCoord.xy*u_scale,time)),0.,1.);\n\tgl_FragColor = vec4(color,1.);\n}\n\n","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\n\nexport class MarbleMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_time: { value: number };\n      u_pattern: { value: number };\n      u_complexity: { value: number };\n      u_complexityAttenuation: { value: number };\n      u_iterations: { value: number };\n      u_timeStrength: { value: number };\n      u_scale: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               u_time: { value: 0 },\n               u_pattern: { value: 0 },\n               u_complexity: { value: 0 },\n               u_complexityAttenuation: { value: 0 },\n               u_iterations: { value: 0 },\n               u_timeStrength: { value: 0 },\n               u_scale: { value: 0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as MarbleMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\n\nexport type MarbleParams = {\n   /** You can add random patterns to noise by passing random numbers ,default:0 */\n   pattern?: number;\n   /** default:2 */\n   complexity?: number;\n   /** default:0.2 */\n   complexityAttenuation?: number;\n   /** default:8 */\n   iterations?: number;\n   /** default:0.2 */\n   timeStrength?: number;\n   /** default:0.002 */\n   scale?: number;\n   /** you can get into the rhythm ♪ , default:false */\n   beat?: number | false;\n};\n\nexport type MarbleObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const MARBLE_PARAMS: MarbleParams = {\n   pattern: 0,\n   complexity: 2,\n   complexityAttenuation: 0.2,\n   iterations: 8,\n   timeStrength: 0.2,\n   scale: 0.002,\n   beat: false,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useMarble = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<MarbleParams, MarbleObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n   });\n\n   const [params, setParams] = useParams<MarbleParams>(MARBLE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: MarbleParams) => {\n         const { gl, clock } = props;\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"u_pattern\", params.pattern!);\n         setUniform(material, \"u_complexity\", params.complexity!);\n         setUniform(\n            material,\n            \"u_complexityAttenuation\",\n            params.complexityAttenuation!\n         );\n         setUniform(material, \"u_iterations\", params.iterations!);\n         setUniform(material, \"u_timeStrength\", params.timeStrength!);\n         setUniform(material, \"u_scale\", params.scale!);\n\n         setUniform(material, \"u_time\", params.beat || clock.getElapsedTime());\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\n\nuniform vec3 uColor0;\nuniform vec3 uColor1;\n\nvoid main() {\n\tvec2 uv = vUv;\n\tvec4 texColor = texture2D(uTexture, uv);\n\tfloat grayscale = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n\tvec3 duotone = mix(uColor0, uColor1, grayscale);\n\tgl_FragColor = vec4(duotone, texColor.a);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\n\nexport class DuoToneMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      uColor0: { value: THREE.Color };\n      uColor1: { value: THREE.Color };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uColor0: { value: new THREE.Color(0xffffff) },\n               uColor1: { value: new THREE.Color(0x000000) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as DuoToneMaterial;\n   useAddMesh(scene, geometry, material);\n   return material;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { DuoToneMaterial, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\n\nexport type DuoToneParams = {\n   /** Make this texture duotone , Default:new THREE.Texture() */\n   texture?: THREE.Texture;\n   /** 1st color ,　Default:new THREE.Color(0xffffff) */\n   color0?: THREE.Color;\n   /** 2nd color , Default: new THREE.Color(0x000000) */\n   color1?: THREE.Color;\n};\n\nexport type DuoToneObject = {\n   scene: THREE.Scene;\n   material: DuoToneMaterial;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const DUOTONE_PARAMS: DuoToneParams = {\n   texture: new THREE.Texture(),\n   color0: new THREE.Color(0xffffff),\n   color1: new THREE.Color(0x000000),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useDuoTone = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<DuoToneParams, DuoToneObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n   });\n\n   const [params, setParams] = useParams<DuoToneParams>(DUOTONE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: DuoToneParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uColor0\", params.color0!);\n         setUniform(material, \"uColor1\", params.color1!);\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D u_texture;\nuniform sampler2D u_map;\nuniform bool u_isAlphaMap;\nuniform sampler2D u_alphaMap;\nuniform float u_mapIntensity;\nuniform vec3 u_brightness;\nuniform float u_min;\nuniform float u_max;\nuniform vec3 u_dodgeColor;\nuniform bool u_isDodgeColor;\n\nvoid main() {\n\tvec2 uv = vUv;\n\n\t// fx blending\n\tvec3 mapColor = texture2D(u_map, uv).rgb;\n\tvec3 normalizedMap = mapColor * 2.0 - 1.0;\n\n\tuv = uv * 2.0 - 1.0;\n\tuv *= mix(vec2(1.0), abs(normalizedMap.rg), u_mapIntensity);\n\tuv = (uv + 1.0) / 2.0;\n\n\t// colro blending\n\tfloat brightness = dot(mapColor,u_brightness);\n\tvec4 textureMap = texture2D(u_texture, uv);\n\tfloat blendValue = smoothstep(u_min, u_max, brightness);\n\n\t// set dodge color\n\tvec3 dodgeColor = u_isDodgeColor ? u_dodgeColor : mapColor;\n\tvec3 outputColor = blendValue * dodgeColor + (1.0 - blendValue) * textureMap.rgb;\n\t\n\t// alpha blending\n\tfloat alpha = u_isAlphaMap ? texture2D(u_alphaMap, uv).a : textureMap.a;\n\tfloat mixValue = u_isAlphaMap ? alpha : 0.0;\n\tvec3 alphColor = mix(outputColor,mapColor,mixValue);\n\n\tgl_FragColor = vec4(alphColor, alpha);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\n\nexport class BlendingMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_map: { value: THREE.Texture };\n      u_alphaMap: { value: THREE.Texture };\n      u_isAlphaMap: { value: boolean };\n      u_mapIntensity: { value: number };\n      u_brightness: { value: THREE.Vector3 };\n      u_min: { value: number };\n      u_max: { value: number };\n      u_dodgeColor: { value: THREE.Color };\n      u_isDodgeColor: { value: boolean };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               u_texture: { value: new THREE.Texture() },\n               u_map: { value: new THREE.Texture() },\n               u_alphaMap: { value: new THREE.Texture() },\n               u_isAlphaMap: { value: false },\n               u_mapIntensity: { value: 0.0 },\n               u_brightness: { value: new THREE.Vector3() },\n               u_min: { value: 0.0 },\n               u_max: { value: 0.9 },\n               u_dodgeColor: { value: new THREE.Color(0xffffff) },\n               u_isDodgeColor: { value: false },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as BlendingMaterial;\n   useAddMesh(scene, geometry, material);\n   return material;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\n\nexport type BlendingParams = {\n   /** Make this texture Blending , default:THREE.Texture */\n   texture?: THREE.Texture;\n   /** map texture, default:THREE.Texture */\n   map?: THREE.Texture;\n   /** map strength , r,g value are affecting , default:0.3 */\n   mapIntensity?: number;\n   /** Alpha blending is performed using the alpha of the set texture. , default:false */\n   alphaMap?: THREE.Texture | false;\n   /** default:(0.5,0.5,0.5) */\n   brightness?: THREE.Vector3;\n   /** default:0.0 */\n   min?: number;\n   /** default:1.0 */\n   max?: number;\n   /** If set, this value will apply color dodge , default: false */\n   dodgeColor?: THREE.Color | false;\n};\n\nexport type BlendingObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const BLENDING_PARAMS: BlendingParams = {\n   texture: new THREE.Texture(),\n   map: new THREE.Texture(),\n   alphaMap: false,\n   mapIntensity: 0.3,\n   brightness: new THREE.Vector3(0.5, 0.5, 0.5),\n   min: 0.0,\n   max: 1.0,\n   dodgeColor: false,\n};\n\n/**\n * Blend map to texture. You can set the threshold for blending with brightness. You can set the dodge color by setting color. \nIf you don't want to reflect the map's color, you can use useFxBlending instead.\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useBlending = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<BlendingParams, BlendingObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n   });\n\n   const [params, setParams] = useParams<BlendingParams>(BLENDING_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: BlendingParams) => {\n         const { gl } = props;\n         updateParams && setParams(updateParams);\n         setUniform(material, \"u_texture\", params.texture!);\n         setUniform(material, \"u_map\", params.map!);\n         setUniform(material, \"u_mapIntensity\", params.mapIntensity!);\n\n         if (params.alphaMap) {\n            setUniform(material, \"u_alphaMap\", params.alphaMap!);\n            setUniform(material, \"u_isAlphaMap\", true);\n         } else {\n            setUniform(material, \"u_isAlphaMap\", false);\n         }\n\n         setUniform(material, \"u_brightness\", params.brightness!);\n         setUniform(material, \"u_min\", params.min!);\n         setUniform(material, \"u_max\", params.max!);\n         if (params.dodgeColor) {\n            setUniform(material, \"u_dodgeColor\", params.dodgeColor);\n            setUniform(material, \"u_isDodgeColor\", true);\n         } else {\n            setUniform(material, \"u_isDodgeColor\", false);\n         }\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform vec2 uResolution;\nuniform vec2 uTextureResolution;\nuniform sampler2D uTexture0;\nuniform sampler2D uTexture1;\nuniform sampler2D uMap;\nuniform float mapIntensity;\nuniform float edgeIntensity;\nuniform float progress;\nuniform float dirX;\nuniform float dirY;\nuniform vec2 epicenter;\nuniform float padding;\n\nbool isInPaddingArea(vec2 uv) {\n   return uv.x < padding || uv.x > 1.0 - padding || uv.y < padding || uv.y > 1.0 - padding;\n}\n\nvoid main() {\n\tfloat screenAspect = uResolution.x / uResolution.y;\n\tfloat textureAspect = uTextureResolution.x / uTextureResolution.y;\n\tvec2 aspectRatio = vec2(\n\t\tmin(screenAspect / textureAspect, 1.0),\n\t\tmin(textureAspect / screenAspect, 1.0)\n\t);\n\tvec2 uv = vUv * aspectRatio + (1.0 - aspectRatio) * .5;\n\n\t// fx map\n\tvec2 map = texture2D(uMap, uv).rg;\n\tvec2 normalizedMap = map * 2.0 - 1.0;\n\n\t// multiply edge fx\n\tuv = uv * 2.0 - 1.0;\n\tuv *= map * distance(epicenter, uv) * edgeIntensity + 1.0;\n\tuv = (uv + 1.0) / 2.0;\n\n\t// padding\n\tif (isInPaddingArea(uv)) {\n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n\t}\n\tvec2 paddedUV = uv * (1.0 - 2.0 * padding * -1.) + padding * -1.;\n\n\t// centered uv\n\tvec2 centeredUV = paddedUV - vec2(0.5);\n\n\t// multiply map fx\n\tcenteredUV *= normalizedMap * map * mapIntensity + 1.0;\n\n\t// texture 0\n\tfloat xOffsetTexture0 = 0.5 - dirX * progress;\n\tfloat yOffsetTexture0 = 0.5 - dirY * progress;\n\tvec2 samplePosTexture0 = vec2(xOffsetTexture0, yOffsetTexture0) + centeredUV;\n\n\t//texture 1\n\tfloat xOffsetTexture1 = 0.5 + dirX * (1.0 - progress);\n\tfloat yOffsetTexture1 = 0.5 + dirY * (1.0 - progress);\n\tvec2 samplePosTexture1 = vec2(xOffsetTexture1, yOffsetTexture1) + centeredUV;\n\n\tvec4 color0 = texture2D(uTexture0, samplePosTexture0);\n\tvec4 color1 = texture2D(uTexture1, samplePosTexture1);\n\n\tgl_FragColor = mix(color0, color1, progress);\n\n}","import { useEffect, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useResolution } from \"../../../utils/useResolution\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\nexport class FxTextureMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uResolution: { value: THREE.Vector2 };\n      uTextureResolution: { value: THREE.Vector2 };\n      uTexture0: { value: THREE.Texture };\n      uTexture1: { value: THREE.Texture };\n      padding: { value: number };\n      uMap: { value: THREE.Texture };\n      edgeIntensity: { value: number };\n      mapIntensity: { value: number };\n      epicenter: { value: THREE.Vector2 };\n      progress: { value: number };\n      dirX: { value: number };\n      dirY: { value: number };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uResolution: { value: new THREE.Vector2() },\n               uTextureResolution: { value: new THREE.Vector2() },\n               uTexture0: { value: new THREE.Texture() },\n               uTexture1: { value: new THREE.Texture() },\n               padding: { value: 0.0 },\n               uMap: { value: new THREE.Texture() },\n               edgeIntensity: { value: 0.0 },\n               mapIntensity: { value: 0.0 },\n               epicenter: { value: new THREE.Vector2(0.0, 0.0) },\n               progress: { value: 0.0 },\n               dirX: { value: 0.0 },\n               dirY: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as FxTextureMaterial;\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(material, \"uResolution\", resolution.clone());\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\n\nexport type FxTextureParams = {\n   /** 1st texture , default:THREE.Texture() */\n   texture0?: THREE.Texture;\n   /** 2nd texture , default:THREE.Texture() */\n   texture1?: THREE.Texture;\n   /** add transparent padding, 0.0 ~ 1.0 , default:0.0 */\n   padding?: number;\n   /** The color map. The uv value is affected according to this rbg , default:THREE.Texture() */\n   map?: THREE.Texture;\n   /** intensity of map , r,g value are affecting , default:0.0 */\n   mapIntensity?: number;\n   /** Intensity of effect on edges , default:0.0 */\n   edgeIntensity?: number;\n   /** epicenter of fx, -1 ~ 1 , default:vec2(0.0,0.0)*/\n   epicenter?: THREE.Vector2;\n   /** Switch value to switch between texture0 and texture1 , 0 ~ 1 , default : 0 */\n   progress?: number;\n   /** direction of transition , default: THREE.Vector2(0, 0) */\n   dir?: THREE.Vector2;\n};\n\nexport type FxTextureObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const FXTEXTURE_PARAMS: FxTextureParams = {\n   texture0: new THREE.Texture(),\n   texture1: new THREE.Texture(),\n   padding: 0.0,\n   map: new THREE.Texture(),\n   mapIntensity: 0.0,\n   edgeIntensity: 0.0,\n   epicenter: new THREE.Vector2(0, 0),\n   progress: 0.0,\n   dir: new THREE.Vector2(0, 0),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useFxTexture = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<FxTextureParams, FxTextureObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      dpr,\n      size,\n      samples,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] = useParams<FxTextureParams>(FXTEXTURE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FxTextureParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture0\", params.texture0!);\n         setUniform(material, \"uTexture1\", params.texture1!);\n\n         setUniform(material, \"progress\", params.progress!);\n\n         // calculate resolution by linear interpolation.\n         const tex0Res = [\n            params.texture0!?.image?.width || 0,\n            params.texture0!?.image?.height || 0,\n         ];\n         const tex1Res = [\n            params.texture1!?.image?.width || 0,\n            params.texture1!?.image?.height || 0,\n         ];\n         const interpolatedResolution = tex0Res.map((value, index) => {\n            return value + (tex1Res[index] - value) * params.progress!;\n         });\n         setUniform(material, \"uTextureResolution\", interpolatedResolution);\n\n         setUniform(material, \"padding\", params.padding!);\n         setUniform(material, \"uMap\", params.map!);\n         setUniform(material, \"mapIntensity\", params.mapIntensity!);\n         setUniform(material, \"edgeIntensity\", params.edgeIntensity!);\n         setUniform(material, \"epicenter\", params.epicenter!);\n         setUniform(material, \"dirX\", params.dir!.x);\n         setUniform(material, \"dirY\", params.dir!.y);\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D u_texture;\nuniform vec3 u_brightness;\nuniform float u_min;\nuniform float u_max;\n\nvoid main() {\n\tvec2 uv = vUv;\n\tvec3 color = texture2D(u_texture, uv).rgb;\n\tfloat brightness = dot(color,u_brightness);\n\tfloat alpha = clamp(smoothstep(u_min, u_max, brightness),0.0,1.0);\n\tgl_FragColor = vec4(color, alpha);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\n\nexport class BrightnessPickerMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_brightness: { value: THREE.Vector3 };\n      u_min: { value: number };\n      u_max: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               u_texture: { value: new THREE.Texture() },\n               u_brightness: { value: new THREE.Vector3() },\n               u_min: { value: 0.0 },\n               u_max: { value: 1.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as BrightnessPickerMaterial;\n   useAddMesh(scene, geometry, material);\n   return material;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\n\nexport type BrightnessPickerParams = {\n   /** pick brightness from this texture , default:THREE.Texture */\n   texture?: THREE.Texture;\n   /** default:(0.5,0.5,0.5) */\n   brightness?: THREE.Vector3;\n   /** default:0.0 */\n   min?: number;\n   /** default:1.0 */\n   max?: number;\n};\n\nexport type BrightnessPickerObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const BRIGHTNESSPICKER_PARAMS: BrightnessPickerParams = {\n   texture: new THREE.Texture(),\n   brightness: new THREE.Vector3(0.5, 0.5, 0.5),\n   min: 0.0,\n   max: 1.0,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useBrightnessPicker = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<BrightnessPickerParams, BrightnessPickerObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n   });\n\n   const [params, setParams] = useParams<BrightnessPickerParams>(\n      BRIGHTNESSPICKER_PARAMS\n   );\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: BrightnessPickerParams) => {\n         const { gl } = props;\n         updateParams && setParams(updateParams);\n         setUniform(material, \"u_texture\", params.texture!);\n         setUniform(material, \"u_brightness\", params.brightness!);\n         setUniform(material, \"u_min\", params.min!);\n         setUniform(material, \"u_max\", params.max!);\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D u_texture;\nuniform sampler2D u_map;\nuniform float u_mapIntensity;\n\nvoid main() {\n\tvec2 uv = vUv;\n\n\tvec2 mapColor = texture2D(u_map, uv).rg;\n\tvec2 normalizedMap = mapColor * 2.0 - 1.0;\n\t\n\tuv = uv * 2.0 - 1.0;\n\tuv *= mix(vec2(1.0), abs(normalizedMap.rg), u_mapIntensity);\n\tuv = (uv + 1.0) / 2.0;\n\n\tgl_FragColor = texture2D(u_texture, uv);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\n\nexport class FxBlendingMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_map: { value: THREE.Texture };\n      u_mapIntensity: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               u_texture: { value: new THREE.Texture() },\n               u_map: { value: new THREE.Texture() },\n               u_mapIntensity: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as FxBlendingMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\n\nexport type FxBlendingParams = {\n   /** Make this texture Blending , default:THREE.Texture */\n   texture?: THREE.Texture;\n   /** map texture, default:THREE.Texture */\n   map?: THREE.Texture;\n   /** map strength , r,g value are affecting , default:0.3 */\n   mapIntensity?: number;\n};\n\nexport type FxBlendingObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const FXBLENDING_PARAMS: FxBlendingParams = {\n   texture: new THREE.Texture(),\n   map: new THREE.Texture(),\n   mapIntensity: 0.3,\n};\n\n/**\n * Blend map to texture. You can change the intensity of fx applied by the rg value of map. Unlike \"useBlending\", the map color is not reflected.\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useFxBlending = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<FxBlendingParams, FxBlendingObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n   });\n\n   const [params, setParams] = useParams<FxBlendingParams>(FXBLENDING_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FxBlendingParams) => {\n         const { gl } = props;\n         updateParams && setParams(updateParams);\n         setUniform(material, \"u_texture\", params.texture!);\n         setUniform(material, \"u_map\", params.map!);\n         setUniform(material, \"u_mapIntensity\", params.mapIntensity!);\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMap;\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvec2 uv = vUv;\n\tvec4 tex = texture2D(uTexture, uv);\n\tvec4 map = texture2D(uMap, uv);\n\tgl_FragColor = mix(tex,map,map.a);\n}\n\n","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useMemo } from \"react\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\nimport { Size } from \"@react-three/fiber\";\n\nexport class AlphaBlendingMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      uMap: { value: THREE.Texture };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uMap: { value: new THREE.Texture() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as AlphaBlendingMaterial;\n\n   useAddMesh(scene, geometry, material);\n   return material;\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState } from \"@react-three/fiber\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\n\nexport type AlphaBlendingParams = {\n   /** default:THREE.Texture()*/\n   texture?: THREE.Texture;\n   /** alpha map , default:THREE.Texture() */\n   map?: THREE.Texture;\n};\n\nexport type AlphaBlendingObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const ALPHABLENDING_PARAMS: AlphaBlendingParams = {\n   texture: new THREE.Texture(),\n   map: new THREE.Texture(),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useAlphaBlending = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<AlphaBlendingParams, AlphaBlendingObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n   });\n\n   const [params, setParams] =\n      useParams<AlphaBlendingParams>(ALPHABLENDING_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: AlphaBlendingParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uMap\", params.map!);\n\n         return updateRenderTarget(gl);\n      },\n      [material, updateRenderTarget, params, setParams]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D u_texture;\nuniform float u_brightness;\nuniform float u_saturation;\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n\tvec4 tex = texture2D(u_texture, vUv);\n\tvec3 hsv = rgb2hsv(tex.rgb);\n\thsv.y *= u_saturation;\n\thsv.z *= u_brightness;\n\tvec3 final = hsv2rgb(hsv);\n\tgl_FragColor = vec4(final, tex.a);\n}\n\n","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useMemo } from \"react\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\nimport { Size } from \"@react-three/fiber\";\n\nexport class HSVMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_brightness: { value: number };\n      u_saturation: { value: number };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               u_texture: { value: new THREE.Texture() },\n               u_brightness: { value: 1 },\n               u_saturation: { value: 1 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as HSVMaterial;\n\n   useAddMesh(scene, geometry, material);\n   return material;\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState } from \"@react-three/fiber\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\n\nexport type HSVParams = {\n   /** default:THREE.Texture() */\n   texture?: THREE.Texture;\n   /** default:1 */\n   brightness?: number;\n   /** default:1 */\n   saturation?: number;\n};\n\nexport type HSVObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const HSV_PARAMS: HSVParams = {\n   texture: new THREE.Texture(),\n   brightness: 1,\n   saturation: 1,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useHSV = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<HSVParams, HSVObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n   });\n\n   const [params, setParams] = useParams<HSVParams>(HSV_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: HSVParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"u_texture\", params.texture!);\n         setUniform(material, \"u_brightness\", params.brightness!);\n         setUniform(material, \"u_saturation\", params.saturation!);\n\n         return updateRenderTarget(gl);\n      },\n      [material, updateRenderTarget, params, setParams]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform vec2 uResolution;\nuniform vec2 uTextureResolution;\nuniform sampler2D uTexture;\n\nvoid main() {\n\tfloat screenAspect = uResolution.x / uResolution.y;\n\tfloat textureAspect = uTextureResolution.x / uTextureResolution.y;\n\tvec2 aspectRatio = vec2(\n\t\tmin(screenAspect / textureAspect, 1.0),\n\t\tmin(textureAspect / screenAspect, 1.0)\n\t);\n\tvec2 uv = vUv * aspectRatio + (1.0 - aspectRatio) * .5;\n\t\n\tgl_FragColor = texture2D(uTexture, uv);\n\n}","import { useEffect, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useResolution } from \"../../../utils/useResolution\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\nexport class FxTextureMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uResolution: { value: THREE.Vector2 };\n      uTextureResolution: { value: THREE.Vector2 };\n      uTexture: { value: THREE.Texture };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uResolution: { value: new THREE.Vector2() },\n               uTextureResolution: { value: new THREE.Vector2() },\n               uTexture: { value: new THREE.Texture() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as FxTextureMaterial;\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(material, \"uResolution\", resolution.clone());\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\n\nexport type CoverTextureParams = {\n   /** Textures that you want to display exactly on the screen , default:THREE.Texture()  */\n   texture?: THREE.Texture;\n};\n\nexport type CoverTextureObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const COVERTEXTURE_PARAMS: CoverTextureParams = {\n   texture: new THREE.Texture(),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useCoverTexture = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<CoverTextureParams, CoverTextureObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      dpr,\n      size,\n      samples,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] =\n      useParams<CoverTextureParams>(COVERTEXTURE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: CoverTextureParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uTextureResolution\", [\n            params.texture!?.source?.data?.width || 0,\n            params.texture!?.source?.data?.height || 0,\n         ]);\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","precision mediump float;\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nuniform float uBlurSize;\n\nvoid main() {\n\tvec2 uv = vUv;\t\n\tvec2 perDivSize = uBlurSize / uResolution;\n\n\t// calc average color value from adjacent point\n\tvec4 outColor = vec4(\n\t\ttexture2D(uTexture, uv + perDivSize * vec2(-1.0, -1.0)) +\n\t\ttexture2D(uTexture, uv + perDivSize * vec2(0.0, -1.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(1.0, -1.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(-1.0, 0.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(0.0,  0.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(1.0,  0.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(-1.0, 1.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(0.0,  1.0)) + \n\t\ttexture2D(uTexture, uv + perDivSize * vec2(1.0,  1.0))\n\t\t) / 9.0;\n\t\n\tgl_FragColor = outColor;\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\n\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\n\nexport class SampleMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uTexture: { value: THREE.Texture };\n      uResolution: { value: THREE.Vector2 };\n      uBlurSize: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uResolution: { value: new THREE.Vector2(0, 0) },\n               uBlurSize: { value: 1 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as SampleMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { useDoubleFBO } from \"../../../utils/useDoubleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { useParams } from \"../../../utils/useParams\";\n\nimport type { HooksProps, HooksReturn } from \"../../types\";\n\nexport type SimpleBlurParams = {\n   /** Make this texture blur , Default:new THREE.Texture() */\n   texture?: THREE.Texture;\n   /** blurSize, default:3 */\n   blurSize?: number;\n   /** blurPower, affects performance default:5 */\n   blurPower?: number;\n};\n\nexport type SimpleBlurObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const SIMPLEBLUR_PARAMS: SimpleBlurParams = {\n   texture: new THREE.Texture(),\n   blurSize: 3,\n   blurPower: 5,\n};\n\nexport const useSimpleBlur = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<SimpleBlurParams, SimpleBlurObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n\n   const fboProps = useMemo(\n      () => ({\n         scene,\n         camera,\n         size,\n         dpr,\n         samples,\n      }),\n      [scene, camera, size, dpr, samples]\n   );\n   const [renderTarget, updateRenderTarget] = useSingleFBO(fboProps);\n   const [_, updateTempTexture] = useDoubleFBO(fboProps);\n   const [params, setParams] = useParams<SimpleBlurParams>(SIMPLEBLUR_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: SimpleBlurParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uResolution\", [\n            params.texture!?.source?.data?.width || 0,\n            params.texture!?.source?.data?.height || 0,\n         ]);\n         setUniform(material, \"uBlurSize\", params.blurSize!);\n\n         let _tempTexture: THREE.Texture = updateTempTexture(gl);\n\n         const iterations = params.blurPower!;\n         for (let i = 0; i < iterations; i++) {\n            setUniform(material, \"uTexture\", _tempTexture);\n            _tempTexture = updateTempTexture(gl);\n         }\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, updateTempTexture, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform float uProgress;\nuniform float uStrength;\nuniform float uWidth;\nuniform vec2 uEpicenter;\nuniform int uMode;\n\nfloat PI = 3.141592653589;\n\nvoid main() {\n\n\tvec2 uv = vUv;\n\n\tfloat progress = min(uProgress, 1.0);\n\tfloat progressFactor = sin(progress * PI);\n\n\tfloat border = progress - progress * progressFactor * uWidth;\n\tfloat blur = uStrength * progressFactor;\n\t\n\t// 0 ~ 1\n\tvec2 normalizeCenter = (uEpicenter + 1.0) / 2.0;\n\n\t// 0:center 1:horizontal 2:vertical\n\tfloat dist = uMode == 0 ? length(uv - normalizeCenter) : uMode == 1 ? length(uv.x - normalizeCenter.x) : length(uv.y - normalizeCenter.y);\n\n\t// Calculate the maximum distance to the four corners of the screen\n\tfloat maxDistance = max(\n\t\tlength(vec2(0.0, 0.0) - normalizeCenter),\n\t\tmax(\n\t\t\t\tlength(vec2(1.0, 0.0) - normalizeCenter),\n\t\t\t\tmax(\n\t\t\t\t\tlength(vec2(0.0, 1.0) - normalizeCenter),\n\t\t\t\t\tlength(vec2(1.0, 1.0) - normalizeCenter)\n\t\t\t\t)\n\t\t)\n\t);\n\n\t// Scale distance so that waves extend to the edge of the screen\n\tdist = maxDistance > 0.0 ? dist / maxDistance : dist;\n\n\tvec3 color = vec3(smoothstep(border - blur, border, dist) -\n                  smoothstep(progress, progress + blur, dist));\n\t\n\t// Ensure color is 0 when progress is 0,1\n\tcolor *= progressFactor;\n\n\tgl_FragColor = vec4(color, 1.0);\n}\n\n","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\n\nexport class WaveMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      uEpicenter: { value: THREE.Vector2 };\n      uProgress: { value: number };\n      uStrength: { value: number };\n      uWidth: { value: number };\n      uMode: { value: number };\n   };\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uEpicenter: { value: new THREE.Vector2(0.0, 0.0) },\n               uProgress: { value: 0.0 },\n               uStrength: { value: 0.0 },\n               uWidth: { value: 0.0 },\n               uMode: { value: 0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   useAddMesh(scene, geometry, material);\n\n   return material as WaveMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { useMesh } from \"./useMesh\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { useParams } from \"../../../utils/useParams\";\nimport { HooksProps, HooksReturn } from \"../../types\";\n\nexport type WaveParams = {\n   /** -1.0 ~ 1.0 , default:vec2(0.0,0.0) */\n   epicenter?: THREE.Vector2;\n   /** 0.0 ~ 1.0 , default:0.0 */\n   progress?: number;\n   /** default:0.0 */\n   width?: number;\n   /** default:0.0 */\n   strength?: number;\n   /** default:center */\n   mode?: \"center\" | \"horizontal\" | \"vertical\";\n};\n\nexport type WaveObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const WAVE_PARAMS: WaveParams = {\n   epicenter: new THREE.Vector2(0.0, 0.0),\n   progress: 0.0,\n   width: 0.0,\n   strength: 0.0,\n   mode: \"center\",\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useWave = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<WaveParams, WaveObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] = useParams<WaveParams>(WAVE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: WaveParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uEpicenter\", params.epicenter!);\n         setUniform(material, \"uProgress\", params.progress!);\n         setUniform(material, \"uWidth\", params.width!);\n         setUniform(material, \"uStrength\", params.strength!);\n         setUniform(\n            material,\n            \"uMode\",\n            params.mode! === \"center\"\n               ? 0\n               : params.mode! === \"horizontal\"\n               ? 1\n               : 2\n         );\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision highp float;\nvarying vec2 vUv;\n\nuniform sampler2D u_texture;\nuniform vec2 u_resolution;\nuniform vec3 u_keyColor;\nuniform float u_similarity;\nuniform float u_smoothness;\nuniform float u_spill;\n\nuniform vec4 u_color;\nuniform float u_contrast;\nuniform float u_brightness;\nuniform float u_gamma;\n\n// From https://github.com/libretro/glsl-shaders/blob/master/nnedi3/shaders/rgb-to-yuv.glsl\nvec2 RGBtoUV(vec3 rgb) {\n  return vec2(\n    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,\n    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5\n  );\n}\nfloat getChromeDist(vec3 texColor){\n\tfloat chromaDist = distance(RGBtoUV(texColor), RGBtoUV(u_keyColor));\n\treturn chromaDist;\n}\n\nfloat getBoxFilteredChromaDist(vec3 rgb, vec2 uv)\n{\n\tvec2 pixel_size = vec2(1.) / u_resolution;\n\tvec2 h_pixel_size = pixel_size / 2.0;\n\tvec2 point_0 = vec2(pixel_size.x, h_pixel_size.y);\n\tvec2 point_1 = vec2(h_pixel_size.x, -pixel_size.y);\n\tfloat distVal = getChromeDist(texture2D(u_texture,uv-point_0).rgb);\n\tdistVal += getChromeDist(texture2D(u_texture,uv+point_0).rgb);\n\tdistVal += getChromeDist(texture2D(u_texture,uv-point_1).rgb);\n\tdistVal += getChromeDist(texture2D(u_texture,uv+point_1).rgb);\n\tdistVal *= 2.0;\n\tdistVal += getChromeDist(rgb);\n\treturn distVal / 9.0;\n}\n\nvec4 CalcColor(vec4 rgba)\n{\n\treturn vec4(pow(rgba.rgb, vec3(u_gamma, u_gamma, u_gamma)) * u_contrast + u_brightness, rgba.a);\n}\n\nvoid main() {\n\n\tvec2 uv = vUv;\n\n\tvec4 texColor = texture2D(u_texture, uv);\n\ttexColor.rgb *= (texColor.a > 0.) ? (1. / texColor.a) : 0.;\n\n\tfloat chromaDist = getBoxFilteredChromaDist(texColor.rgb,uv);\n\t\n\tfloat baseMask = chromaDist - u_similarity;\n\tfloat fullMask = pow(clamp(baseMask / u_smoothness, 0., 1.), 1.5);\n\t\n\ttexColor.rgba *= u_color;\n\ttexColor.a = fullMask;\n\n\tfloat spillVal = pow(clamp(baseMask / u_spill, 0., 1.), 1.5);\n\tfloat desat = clamp(texColor.r * 0.2126 + texColor.g * 0.7152 + texColor.b * 0.0722, 0., 1.);\n\ttexColor.rgb = mix(vec3(desat, desat, desat), texColor.rgb, spillVal);\n\n\tvec4 finColor = CalcColor(texColor);\n\n\tgl_FragColor = finColor;\n}","import { useEffect, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { Size } from \"@react-three/fiber\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../../utils/useAddMesh\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { useResolution } from \"../../../utils/useResolution\";\n\nexport class ChromaKeyMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_resolution: { value: THREE.Vector2 };\n      u_keyColor: { value: THREE.Color };\n      u_similarity: { value: number };\n      u_smoothness: { value: number };\n      u_spill: { value: number };\n      u_color: { value: THREE.Vector4 };\n      u_contrast: { value: number };\n      u_brightness: { value: number };\n      u_gamma: { value: number };\n   };\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               u_texture: { value: new THREE.Texture() },\n               u_resolution: { value: new THREE.Vector2() },\n               u_keyColor: { value: new THREE.Color() },\n               u_similarity: { value: 0 },\n               u_smoothness: { value: 0 },\n               u_spill: { value: 0 },\n               u_color: { value: new THREE.Vector4() },\n               u_contrast: { value: 0 },\n               u_brightness: { value: 0 },\n               u_gamma: { value: 0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   ) as ChromaKeyMaterial;\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(material, \"u_resolution\", resolution.clone());\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n   return material;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../../utils/useSingleFBO\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { HooksProps, HooksReturn } from \"../../types\";\nimport { useParams } from \"../../../utils/useParams\";\n\nexport type ChromaKeyParams = {\n   /** Process this texture with chroma key , default:THREE.Texture */\n   texture?: THREE.Texture;\n   /** key color for chromakey processing , default: THREE.Color(0x00ff00) */\n   keyColor?: THREE.Color;\n   /** If the similarity with the key color exceeds this value, it becomes transparent. , default: 0.2 */\n   similarity?: number;\n   /** smoothness , default : 0.1 */\n   smoothness?: number;\n   /** spill , default : 0.2 */\n   spill?: number;\n   /** tone correction , default : THREE.Vector4(1.0, 1.0, 1.0, 1.0) */\n   color?: THREE.Vector4;\n   /** contrast , default : 1.0 */\n   contrast?: number;\n   /** brightness , default : 0.0 */\n   brightness?: number;\n   /** gamma correction , default : 1.0 */\n   gamma?: number;\n};\n\nexport type ChromaKeyObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n};\n\nexport const CHROMAKEY_PARAMS: ChromaKeyParams = {\n   texture: new THREE.Texture(),\n   keyColor: new THREE.Color(0x00ff00),\n   similarity: 0.2,\n   smoothness: 0.1,\n   spill: 0.2,\n   color: new THREE.Vector4(1.0, 1.0, 1.0, 1.0),\n   contrast: 1.0,\n   brightness: 0.0,\n   gamma: 1.0,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useChromaKey = ({\n   size,\n   dpr,\n   samples = 0,\n}: HooksProps): HooksReturn<ChromaKeyParams, ChromaKeyObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n   });\n\n   const [params, setParams] = useParams<ChromaKeyParams>(CHROMAKEY_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: ChromaKeyParams) => {\n         const { gl } = props;\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"u_texture\", params.texture!);\n         setUniform(material, \"u_keyColor\", params.keyColor!);\n         setUniform(material, \"u_similarity\", params.similarity!);\n         setUniform(material, \"u_smoothness\", params.smoothness!);\n         setUniform(material, \"u_spill\", params.spill!);\n         setUniform(material, \"u_color\", params.color!);\n         setUniform(material, \"u_contrast\", params.contrast!);\n         setUniform(material, \"u_brightness\", params.brightness!);\n         setUniform(material, \"u_gamma\", params.gamma!);\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n         output: renderTarget.texture,\n      },\n   ];\n};\n","import * as THREE from \"three\";\nimport {\n   useCallback,\n   useEffect,\n   useLayoutEffect,\n   useMemo,\n   useRef,\n} from \"react\";\nimport { useResolution } from \"./useResolution\";\nimport { UseFboProps, renderFBO, FBO_OPTION } from \"./useSingleFBO\";\n\ntype UpdateCopyFunction = (\n   gl: THREE.WebGLRenderer,\n   index: number,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({ read }: { read: THREE.Texture }) => void\n) => THREE.Texture;\n\ntype UseCopyTextureReturn = [THREE.WebGLRenderTarget[], UpdateCopyFunction];\n\n/**\n * Generate an FBO array to copy the texture.\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @param length The number of FBOs to create\n * @returns [THREE.WebGLRenderTarget[] , updateCopyTexture] -Receives the RenderTarget array as the first argument and the update function as the second argument. updateCopyTexture() receives gl as the first argument and the index of the texture you want to copy as the second argument.\n */\nexport const useCopyTexture = (\n   {\n      scene,\n      camera,\n      size,\n      dpr = false,\n      isSizeUpdate = false,\n      samples = 0,\n      depthBuffer = false,\n      depthTexture = false,\n   }: UseFboProps,\n   length: number\n): UseCopyTextureReturn => {\n   const renderTargetArr = useRef<THREE.WebGLRenderTarget[]>([]);\n   const resolution = useResolution(size, dpr);\n\n   renderTargetArr.current = useMemo(() => {\n      return Array.from({ length }, () => {\n         const target = new THREE.WebGLRenderTarget(\n            resolution.x,\n            resolution.y,\n            {\n               ...FBO_OPTION,\n               samples,\n               depthBuffer,\n            }\n         );\n         if (depthTexture) {\n            target.depthTexture = new THREE.DepthTexture(\n               resolution.x,\n               resolution.y,\n               THREE.FloatType\n            );\n         }\n         return target;\n      });\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, [length]);\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTargetArr.current.forEach((fbo) =>\n            fbo.setSize(resolution.x, resolution.y)\n         );\n      }\n   }, [resolution, isSizeUpdate]);\n\n   useEffect(() => {\n      const temp = renderTargetArr.current;\n      return () => {\n         temp.forEach((fbo) => fbo.dispose());\n      };\n   }, [length]);\n\n   const updateCopyTexture: UpdateCopyFunction = useCallback(\n      (gl, index, onBeforeRender) => {\n         const fbo = renderTargetArr.current[index];\n         renderFBO({\n            gl,\n            scene,\n            camera,\n            fbo,\n            onBeforeRender: () =>\n               onBeforeRender && onBeforeRender({ read: fbo.texture }),\n         });\n         return fbo.texture;\n      },\n      [scene, camera]\n   );\n\n   return [renderTargetArr.current, updateCopyTexture];\n};\n","export type EasingTypes =\n   | \"easeInSine\"\n   | \"easeOutSine\"\n   | \"easeInOutSine\"\n   | \"easeInQuad\"\n   | \"easeOutQuad\"\n   | \"easeInOutQuad\"\n   | \"easeInCubic\"\n   | \"easeOutCubic\"\n   | \"easeInOutCubic\"\n   | \"easeInQuart\"\n   | \"easeOutQuart\"\n   | \"easeInOutQuart\"\n   | \"easeInQuint\"\n   | \"easeOutQuint\"\n   | \"easeInOutQuint\"\n   | \"easeInExpo\"\n   | \"easeOutExpo\"\n   | \"easeInOutExpo\"\n   | \"easeInCirc\"\n   | \"easeOutCirc\"\n   | \"easeInOutCirc\"\n   | \"easeInBack\"\n   | \"easeOutBack\"\n   | \"easeInOutBack\"\n   | \"easeInElastic\"\n   | \"easeOutElastic\"\n   | \"easeInOutElastic\"\n   | \"easeInBounce\"\n   | \"easeOutBounce\"\n   | \"easeInOutBounce\";\n\ntype EasingFunctions = {\n   [K in EasingTypes]: (x: number) => number;\n};\n\n/**\n * from https://github.com/ai/easings.net\n */\nexport const Easing: EasingFunctions = Object.freeze({\n   easeInSine(x: number): number {\n      return 1 - Math.cos((x * Math.PI) / 2);\n   },\n   easeOutSine(x: number): number {\n      return Math.sin((x * Math.PI) / 2);\n   },\n   easeInOutSine(x: number): number {\n      return -(Math.cos(Math.PI * x) - 1) / 2;\n   },\n   easeInQuad(x: number): number {\n      return x * x;\n   },\n   easeOutQuad(x: number): number {\n      return 1 - (1 - x) * (1 - x);\n   },\n   easeInOutQuad(x: number): number {\n      return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;\n   },\n   easeInCubic(x: number): number {\n      return x * x * x;\n   },\n   easeOutCubic(x: number): number {\n      return 1 - Math.pow(1 - x, 3);\n   },\n   easeInOutCubic(x: number): number {\n      return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;\n   },\n   easeInQuart(x: number): number {\n      return x * x * x * x;\n   },\n   easeOutQuart(x: number): number {\n      return 1 - Math.pow(1 - x, 4);\n   },\n   easeInOutQuart(x: number): number {\n      return x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2;\n   },\n   easeInQuint(x: number): number {\n      return x * x * x * x * x;\n   },\n   easeOutQuint(x: number): number {\n      return 1 - Math.pow(1 - x, 5);\n   },\n   easeInOutQuint(x: number): number {\n      return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;\n   },\n   easeInExpo(x: number): number {\n      return x === 0 ? 0 : Math.pow(2, 10 * x - 10);\n   },\n   easeOutExpo(x: number): number {\n      return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);\n   },\n   easeInOutExpo(x: number): number {\n      return x === 0\n         ? 0\n         : x === 1\n         ? 1\n         : x < 0.5\n         ? Math.pow(2, 20 * x - 10) / 2\n         : (2 - Math.pow(2, -20 * x + 10)) / 2;\n   },\n   easeInCirc(x: number): number {\n      return 1 - Math.sqrt(1 - Math.pow(x, 2));\n   },\n   easeOutCirc(x: number): number {\n      return Math.sqrt(1 - Math.pow(x - 1, 2));\n   },\n   easeInOutCirc(x: number): number {\n      return x < 0.5\n         ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2\n         : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;\n   },\n   easeInBack(x: number): number {\n      const c1 = 1.70158;\n      const c3 = c1 + 1;\n\n      return c3 * x * x * x - c1 * x * x;\n   },\n   easeOutBack(x: number): number {\n      const c1 = 1.70158;\n      const c3 = c1 + 1;\n\n      return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);\n   },\n   easeInOutBack(x: number): number {\n      const c1 = 1.70158;\n      const c2 = c1 * 1.525;\n\n      return x < 0.5\n         ? (Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n         : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n   },\n   easeInElastic(x: number): number {\n      const c4 = (2 * Math.PI) / 3;\n\n      return x === 0\n         ? 0\n         : x === 1\n         ? 1\n         : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4);\n   },\n   easeOutElastic(x: number): number {\n      const c4 = (2 * Math.PI) / 3;\n\n      return x === 0\n         ? 0\n         : x === 1\n         ? 1\n         : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;\n   },\n   easeInOutElastic(x: number): number {\n      const c5 = (2 * Math.PI) / 4.5;\n\n      return x === 0\n         ? 0\n         : x === 1\n         ? 1\n         : x < 0.5\n         ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2\n         : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) / 2 +\n           1;\n   },\n   easeInBounce(x: number): number {\n      return 1 - Easing.easeOutBounce(1 - x);\n   },\n   easeOutBounce(x: number): number {\n      const n1 = 7.5625;\n      const d1 = 2.75;\n\n      if (x < 1 / d1) {\n         return n1 * x * x;\n      } else if (x < 2 / d1) {\n         return n1 * (x -= 1.5 / d1) * x + 0.75;\n      } else if (x < 2.5 / d1) {\n         return n1 * (x -= 2.25 / d1) * x + 0.9375;\n      } else {\n         return n1 * (x -= 2.625 / d1) * x + 0.984375;\n      }\n   },\n   easeInOutBounce(x: number): number {\n      return x < 0.5\n         ? (1 - Easing.easeOutBounce(1 - 2 * x)) / 2\n         : (1 + Easing.easeOutBounce(2 * x - 1)) / 2;\n   },\n});\n","import * as THREE from \"three\";\nimport { Easing, EasingTypes } from \"../libs/easing\";\nimport { useCallback } from \"react\";\n\n/** Returns a unique hash specific to the beat */\nfunction getHash(input: number) {\n   let n = Math.sin(input * 12.9898) * 43758.5453;\n   return n - Math.floor(n);\n}\n\ntype BeatValues = {\n   beat: number;\n   floor: number;\n   fract: number;\n   /** unique hash specific to the beat */\n   hash: number;\n};\n\n/**\n * @param ease easing functions are referenced from https://github.com/ai/easings.net , default : \"easeOutQuart\"\n */\nexport const useBeat = (bpm: number, ease: EasingTypes = \"easeOutQuart\") => {\n   const rhythm = bpm / 60;\n   const easing = Easing[ease];\n   const updateBeat = useCallback(\n      (clock: THREE.Clock) => {\n         let beat = clock.getElapsedTime() * rhythm;\n         const floor = Math.floor(beat);\n         const fract = easing(beat - floor);\n         beat = fract + floor;\n         const hash = getHash(floor);\n         return {\n            beat,\n            floor,\n            fract,\n            hash,\n         } as BeatValues;\n      },\n      [rhythm, easing]\n   );\n   return updateBeat;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo, useRef } from \"react\";\n\n/**\n * @param fps FPS you want to limit , default : 60\n *\n * ```tsx\n * const limiter = useFPSLimiter(fps);\n * useFrame((props) => {\n *     if (limiter(props.clock)) {\n *\t\t    //some code\n *     }\n * });\n * ```\n */\nexport const useFPSLimiter = (fps: number = 60) => {\n   const interval = useMemo(() => 1 / Math.max(Math.min(fps, 60), 1), [fps]);\n   const prevTime = useRef<number | null>(null);\n\n   const limiter = useCallback(\n      (clock: THREE.Clock) => {\n         const tick = clock.getElapsedTime();\n         if (prevTime.current === null) {\n            prevTime.current = tick;\n            return true;\n         }\n         const deltaTime = tick - prevTime.current;\n         if (deltaTime >= interval) {\n            prevTime.current = tick;\n            return true;\n         }\n         return false;\n      },\n      [interval]\n   );\n\n   return limiter;\n};\n","import { DomSyncerParams } from \"..\";\n\nexport const errorHandler = (params: DomSyncerParams) => {\n   const domLength = params.dom?.length;\n   const textureLength = params.texture?.length;\n\n   if (!domLength || !textureLength) {\n      return true;\n   }\n\n   if (domLength !== textureLength) {\n      return true;\n   }\n\n   return false;\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n}","precision highp float;\n\nvarying vec2 vUv;\nuniform sampler2D u_texture;\nuniform vec2 u_textureResolution;\nuniform vec2 u_resolution;\nuniform float u_borderRadius;\n\nvoid main() {\n\t// texuture color\n\tfloat screenAspect = u_resolution.x / u_resolution.y;\n\tfloat textureAspect = u_textureResolution.x / u_textureResolution.y;\n\tvec2 ratio = vec2(\n\t\tmin(screenAspect / textureAspect, 1.0),\n\t\tmin(textureAspect / screenAspect, 1.0)\n\t);\n\n\tvec2 adjustedUv = vUv * ratio + (1.0 - ratio) * 0.5;\n\tvec3 textureColor = texture2D(u_texture, adjustedUv).rgb;\n\tfloat textureAlpha = texture2D(u_texture, adjustedUv).a;\n\n\t// Based on https://mofu-dev.com/en/blog/three-dom-alignment/\n\tfloat maxSide = max(u_resolution.x, u_resolution.y);\n\tfloat minSide = min(u_resolution.x, u_resolution.y);\n\tvec2 aspect = u_resolution / maxSide;\n\tvec2 alphaUv = vUv - 0.5;\n\n\tfloat borderRadius = min(u_borderRadius, minSide * 0.5);\n\tvec2 offset = vec2(borderRadius) / u_resolution;\n\tvec2 alphaXY = smoothstep(vec2(0.5 - offset), vec2(0.5 - offset - 0.001), abs(alphaUv));\n\tfloat alpha = min(1.0, alphaXY.x + alphaXY.y);\n\n\tvec2 alphaUv2 = abs(vUv - 0.5);\n\tfloat radius = borderRadius / maxSide;\n\talphaUv2 = (alphaUv2 - 0.5) * aspect + radius;\n\tfloat roundAlpha = smoothstep(radius + 0.001, radius, length(alphaUv2));\n\n\talpha = min(1.0, alpha + roundAlpha);\n\n\t// multiply texture alpha\n\talpha *= textureAlpha;\n\n\tgl_FragColor = vec4(textureColor, alpha);\n}\n","import * as THREE from \"three\";\nimport { DomSyncerParams } from \"../\";\nimport { Size } from \"@react-three/fiber\";\nimport vertexShader from \"../shader/main.vert\";\nimport fragmentShader from \"../shader/main.frag\";\n\nexport class DomSyncerMaterial extends THREE.ShaderMaterial {\n   uniforms!: {\n      u_texture: { value: THREE.Texture };\n      u_textureResolution: { value: THREE.Vector2 };\n      u_resolution: { value: THREE.Vector2 };\n      u_borderRadius: { value: number };\n   };\n}\n\nexport const createMesh = ({\n   params,\n   size,\n   scene,\n}: {\n   params: DomSyncerParams;\n   size: Size;\n   scene: THREE.Scene;\n}) => {\n   if (scene.children.length > 0) {\n      scene.children.forEach((child) => {\n         if (child instanceof THREE.Mesh) {\n            child.geometry.dispose();\n            child.material.dispose();\n         }\n      });\n      scene.remove(...scene.children);\n   }\n\n   params.texture!.forEach((texture, i) => {\n      const mesh = new THREE.Mesh(\n         new THREE.PlaneGeometry(1, 1),\n         new THREE.ShaderMaterial({\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            transparent: true,\n            uniforms: {\n               u_texture: { value: texture },\n               u_textureResolution: {\n                  value: new THREE.Vector2(0, 0),\n               },\n               u_resolution: { value: new THREE.Vector2(0, 0) },\n               u_borderRadius: {\n                  value: params.boderRadius![i] ? params.boderRadius![i] : 0.0,\n               },\n            },\n         })\n      );\n      scene.add(mesh);\n   });\n};\n","import { useCallback, useRef } from \"react\";\nimport { DomSyncerParams } from \"..\";\n\nexport const useIntersectionHandler = () => {\n   const intersectionObserverRef = useRef<IntersectionObserver[]>([]);\n   const intersectionDomRef = useRef<(HTMLElement | Element | null)[]>([]);\n\n   const intersectionHandler = useCallback(\n      ({\n         isIntersectingRef,\n         isIntersectingOnceRef,\n         params,\n      }: {\n         isIntersectingRef: React.MutableRefObject<boolean[]>;\n         isIntersectingOnceRef: React.MutableRefObject<boolean[]>;\n         params: DomSyncerParams;\n      }) => {\n         if (intersectionObserverRef.current.length > 0) {\n            intersectionObserverRef.current.forEach((observer, i) => {\n               observer.unobserve(intersectionDomRef.current[i]!);\n            });\n         }\n\n         intersectionDomRef.current = [];\n         intersectionObserverRef.current = [];\n\n         const newArr = new Array(params.dom!.length).fill(false);\n         isIntersectingRef.current = [...newArr];\n         isIntersectingOnceRef.current = [...newArr];\n\n         params.dom!.forEach((dom, i) => {\n            const callback = (entries: IntersectionObserverEntry[]) => {\n               entries.forEach((entry) => {\n                  params.onIntersect![i] && params.onIntersect![i](entry);\n                  // Update the judgment after execution so that the judgment of isIntersectin can be used when executing onIntersect\n                  isIntersectingRef.current[i] = entry.isIntersecting;\n               });\n            };\n            const observer = new IntersectionObserver(callback, {\n               rootMargin: \"0px\",\n               threshold: 0,\n            });\n            observer.observe(dom!);\n            intersectionObserverRef.current.push(observer);\n            intersectionDomRef.current.push(dom!);\n         });\n      },\n      []\n   );\n\n   return intersectionHandler;\n};\n","import * as THREE from \"three\";\nimport { DomSyncerParams } from \"..\";\nimport { Size } from \"@react-three/fiber\";\nimport { setUniform } from \"../../../utils/setUniforms\";\nimport { DomSyncerMaterial } from \"./createMesh\";\nimport { useCallback, useRef } from \"react\";\n\ntype UpdateDomRect = ({\n   params,\n   size,\n   resolutionRef,\n   scene,\n   isIntersectingRef,\n}: {\n   params: DomSyncerParams;\n   size: Size;\n   resolutionRef: React.MutableRefObject<THREE.Vector2>;\n   scene: THREE.Scene;\n   isIntersectingRef: React.MutableRefObject<boolean[]>;\n}) => void;\n\ntype UseUpdateDomRectReturn = [DOMRect[], UpdateDomRect];\n\nexport const useUpdateDomRect = (): UseUpdateDomRectReturn => {\n   const domRects = useRef<DOMRect[]>([]);\n\n   const updateDomRects: UpdateDomRect = useCallback(\n      ({ params, size, resolutionRef, scene, isIntersectingRef }) => {\n         // Initialize domRects if the number of children in the scene is different from the number of DOMRect\n         if (scene.children.length !== domRects.current!.length) {\n            domRects.current = new Array(scene.children.length);\n         }\n\n         scene.children.forEach((mesh, i) => {\n            const domElement = params.dom![i];\n            if (!domElement) {\n               return;\n            }\n\n            // DOMRect is updated even outside the intersection\n            const rect = domElement.getBoundingClientRect();\n            domRects.current[i] = rect;\n\n            // Intersection cannot be determined accurately depending on the mobile navigation bar, so it seems better to update it constantly\n            mesh.scale.set(rect.width, rect.height, 1.0);\n            mesh.position.set(\n               rect.left + rect.width * 0.5 - size.width * 0.5,\n               -rect.top - rect.height * 0.5 + size.height * 0.5,\n               0.0\n            );\n\n            if (isIntersectingRef.current[i]) {\n               if (params.rotation![i]) {\n                  mesh.rotation.copy(params.rotation![i]);\n               }\n\n               if (mesh instanceof THREE.Mesh) {\n                  const material: DomSyncerMaterial = mesh.material;\n                  setUniform(material, \"u_texture\", params.texture![i]);\n                  setUniform(material, \"u_textureResolution\", [\n                     params.texture![i]?.source?.data?.width || 0,\n                     params.texture![i]?.source?.data?.height || 0,\n                  ]);\n                  setUniform(\n                     material,\n                     \"u_resolution\",\n                     resolutionRef.current.set(rect.width, rect.height)\n                  );\n                  setUniform(\n                     material,\n                     \"u_borderRadius\",\n                     params.boderRadius![i] ? params.boderRadius![i] : 0.0\n                  );\n               }\n            }\n         });\n      },\n      []\n   );\n\n   return [domRects.current, updateDomRects];\n};\n","import { useCallback, useRef } from \"react\";\n\nexport type IsIntersecting = (\n   index: number,\n   once?: boolean\n) => boolean[] | boolean;\n\nexport const useIsIntersecting = () => {\n   const isIntersectingRef = useRef<boolean[]>([]);\n   const isIntersectingOnceRef = useRef<boolean[]>([]);\n\n   const isIntersecting: IsIntersecting = useCallback((index, once = false) => {\n      isIntersectingRef.current.forEach((value, i) => {\n         if (value) {\n            isIntersectingOnceRef.current[i] = true;\n         }\n      });\n      const temp = once\n         ? [...isIntersectingOnceRef.current]\n         : [...isIntersectingRef.current];\n      return index < 0 ? temp : temp[index];\n   }, []);\n\n   return {\n      isIntersectingRef,\n      isIntersectingOnceRef,\n      isIntersecting,\n   };\n};\n","import { useEffect, useRef } from \"react\";\n\nexport type UseDomViewProps = {\n   onView?: () => void;\n   onHidden?: () => void;\n};\n\nexport type UseDomView = (props: UseDomViewProps) => void;\n\nexport const createUseDomView = (\n   isIntersectingRef: React.MutableRefObject<boolean[]>\n): UseDomView => {\n   const useDomView = ({ onView, onHidden }: UseDomViewProps) => {\n      const isView = useRef<boolean>(false);\n      useEffect(() => {\n         let id: number;\n         const filterIntersection = () => {\n            if (isIntersectingRef.current.some((item) => item)) {\n               if (!isView.current) {\n                  onView && onView();\n                  isView.current = true;\n               }\n            } else {\n               if (isView.current) {\n                  onHidden && onHidden();\n                  isView.current = false;\n               }\n            }\n            id = requestAnimationFrame(filterIntersection);\n         };\n         id = requestAnimationFrame(filterIntersection);\n         return () => {\n            cancelAnimationFrame(id);\n         };\n      }, [onView, onHidden]);\n   };\n   return useDomView;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo, useRef, useState, Key } from \"react\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { HooksProps, HooksReturn } from \"../../fxs/types\";\nimport { useParams } from \"../../utils/useParams\";\nimport { errorHandler } from \"./utils/errorHandler\";\nimport { createMesh } from \"./utils/createMesh\";\nimport { useIntersectionHandler } from \"./utils/useIntersectionHandler\";\nimport { useUpdateDomRect } from \"./utils/useUpdateDomRect\";\nimport { useIsIntersecting, IsIntersecting } from \"./utils/useIsIntersecting\";\nimport { UseDomView, createUseDomView } from \"./utils/createUseDomView\";\n\nexport type DomSyncerParams = {\n   /** DOM array you want to synchronize */\n   dom?: (HTMLElement | Element | null)[];\n   /** Texture array that you want to synchronize with the DOM rectangle */\n   texture?: THREE.Texture[];\n   /** default:0.0[] */\n   boderRadius?: number[];\n   /** the angle you want to rotate */\n   rotation?: THREE.Euler[];\n   /** Array of callback functions when crossed */\n   onIntersect?: ((entry: IntersectionObserverEntry) => void)[];\n   /** Because DOM rendering and React updates occur asynchronously, there may be a lag between updating dependent arrays and setting DOM arrays. That's what the Key is for. If the dependent array is updated but the Key is not, the loop will skip and return an empty texture. By updating the timing key when DOM acquisition is complete, you can perfectly synchronize DOM and Mesh updates.updateKey must be a unique value for each update, for example `performance.now()`.*/\n   updateKey?: Key;\n};\n\nexport type DomSyncerObject = {\n   scene: THREE.Scene;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n   output: THREE.Texture;\n   /**\n    * A function that returns a determination whether the DOM intersects or not.\n    * The boolean will be updated after executing the onIntersect function.\n    * @param index - Index of the dom for which you want to return an intersection decision. -1 will return the entire array.\n    * @param once - If set to true, it will continue to return true once crossed.\n    */\n   isIntersecting: IsIntersecting;\n   /** target's DOMRect[] */\n   DOMRects: DOMRect[];\n   /** target's intersetions boolean[] */\n   intersections: boolean[];\n   /** You can set callbacks for when at least one DOM is visible and when it is completely hidden. */\n   useDomView: UseDomView;\n};\n\nexport const DOMSYNCER_PARAMS: DomSyncerParams = {\n   texture: [],\n   dom: [],\n   // resolution: [],\n   boderRadius: [],\n   rotation: [],\n   onIntersect: [],\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n * @param dependencies - When this dependency array is changed, the mesh and intersection judgment will be updated according to the passed DOM array.\n */\nexport const useDomSyncer = (\n   { size, dpr, samples = 0 }: HooksProps,\n   dependencies: React.DependencyList = []\n): HooksReturn<DomSyncerParams, DomSyncerObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n      samples,\n      isSizeUpdate: true,\n   });\n   const [params, setParams] = useParams<DomSyncerParams>({\n      ...DOMSYNCER_PARAMS,\n      updateKey: performance.now(),\n   });\n\n   const [DOMRects, updateDomRects] = useUpdateDomRect();\n\n   // Avoid instancing vec2 every frame\n   const resolutionRef = useRef<THREE.Vector2>(new THREE.Vector2(0, 0));\n\n   // Update monitored doms according to the dependency array\n   const [refreshTrigger, setRefreshTrigger] = useState(true);\n   useEffect(() => {\n      setRefreshTrigger(true);\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, dependencies);\n\n   // If the dependencies have been updated but the key has not been updated, skip processing and return an empty texture\n   const updateKey = useRef<Key | null>(null);\n   const emptyTexture = useMemo(() => new THREE.Texture(), []);\n\n   // set intersection\n   const intersectionHandler = useIntersectionHandler();\n   const { isIntersectingOnceRef, isIntersectingRef, isIntersecting } =\n      useIsIntersecting();\n\n   // create useDomView\n   const useDomView = createUseDomView(isIntersectingRef);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: DomSyncerParams) => {\n         const { gl, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         if (errorHandler(params)) {\n            return emptyTexture;\n         }\n\n         if (refreshTrigger) {\n            if (updateKey.current === params.updateKey) {\n               return emptyTexture;\n            } else {\n               updateKey.current = params.updateKey!;\n            }\n         }\n\n         if (refreshTrigger) {\n            createMesh({\n               params,\n               size,\n               scene,\n            });\n\n            intersectionHandler({\n               isIntersectingRef,\n               isIntersectingOnceRef,\n               params,\n            });\n\n            setRefreshTrigger(false);\n         }\n\n         updateDomRects({\n            params,\n            size,\n            resolutionRef,\n            scene,\n            isIntersectingRef,\n         });\n\n         return updateRenderTarget(gl);\n      },\n      [\n         updateRenderTarget,\n         setParams,\n         intersectionHandler,\n         updateDomRects,\n         refreshTrigger,\n         scene,\n         params,\n         isIntersectingOnceRef,\n         isIntersectingRef,\n         emptyTexture,\n      ]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene,\n         camera,\n         renderTarget,\n         output: renderTarget.texture,\n         isIntersecting,\n         DOMRects,\n         intersections: isIntersectingRef.current,\n         useDomView,\n      },\n   ];\n};\n"],"names":["main_default","useResolution","size","dpr","_width","_height","useMemo","THREE","useAddMesh","scene","geometry","material","mesh","useEffect","setUniform","key","value","useMesh","vertexShader","fragmentShader","resolution","getCameraProps","width","height","frustumSize","aspect","w","h","useCamera","near","far","usePointer","lerp","prevPointer","useRef","diffPointer","lerpPointer","lastUpdateTime","velocity","isMoved","useCallback","currentPointer","now","current","deltaTime","isUpdate","prevTemp","useParams","params","paramsRef","obj","setParams","updateParams","paramKey","FBO_OPTION","renderFBO","gl","fbo","camera","onBeforeRender","onSwap","useSingleFBO","isSizeUpdate","samples","depthBuffer","depthTexture","renderTarget","target","useLayoutEffect","_a","temp","updateRenderTarget","useDoubleFBO","initRenderTargets","read","write","_b","BRUSH_PARAMS","useBrush","updatePointer","pressureEnd","props","pointer","pointerValues","color","init_default","useInitialMaterial","advection_default","useAdvectionMaterial","divergence_default","useDivergenceMaterial","pressure_default","usePressureMaterial","curl_default","useCurlMaterial","vorticity_default","useVorticityMaterial","clear_default","useClearMaterial","gradientSubtract_default","useGradientSubtractMaterial","splat_default","useSplateMaterial","initialMaterial","updateMaterial","curlMaterial","vorticityMaterial","advectionMaterial","divergenceMaterial","pressureMaterial","clearMaterial","gradientSubtractMaterial","splatMaterial","materials","setMeshMaterial","FLUID_PARAMS","useFluid","fboProps","velocityFBO","updateVelocityFBO","densityFBO","updateDensityFBO","curlFBO","updateCurlFBO","divergenceFBO","updateDivergenceFBO","pressureFBO","updatePressureFBO","lastTime","scaledDiffVec","spaltVec","clock","dt","velocityTex","densityTex","scaledDiff","curlTex","divergenceTex","pressureTexTemp","i","scale","max","texture","meshArr","RIPPLE_PARAMS","useRipple","currentWave","NOISE_PARAMS","useNoise","COLORSTRATA_PARAMS","useColorStrata","MARBLE_PARAMS","useMarble","DUOTONE_PARAMS","useDuoTone","BLENDING_PARAMS","useBlending","FXTEXTURE_PARAMS","useFxTexture","tex0Res","_d","_c","tex1Res","_f","_e","_h","_g","interpolatedResolution","index","BRIGHTNESSPICKER_PARAMS","useBrightnessPicker","FXBLENDING_PARAMS","useFxBlending","ALPHABLENDING_PARAMS","useAlphaBlending","HSV_PARAMS","useHSV","COVERTEXTURE_PARAMS","useCoverTexture","SIMPLEBLUR_PARAMS","useSimpleBlur","_","updateTempTexture","_tempTexture","iterations","WAVE_PARAMS","useWave","CHROMAKEY_PARAMS","useChromaKey","useCopyTexture","length","renderTargetArr","updateCopyTexture","Easing","x","c2","c4","c5","getHash","input","n","useBeat","bpm","ease","rhythm","easing","beat","floor","fract","hash","useFPSLimiter","fps","interval","prevTime","tick","errorHandler","domLength","textureLength","createMesh","child","useIntersectionHandler","intersectionObserverRef","intersectionDomRef","isIntersectingRef","isIntersectingOnceRef","observer","newArr","dom","callback","entries","entry","useUpdateDomRect","domRects","updateDomRects","resolutionRef","domElement","rect","useIsIntersecting","isIntersecting","once","createUseDomView","onView","onHidden","isView","id","filterIntersection","item","DOMSYNCER_PARAMS","useDomSyncer","dependencies","DOMRects","refreshTrigger","setRefreshTrigger","useState","updateKey","emptyTexture","intersectionHandler","useDomView"],"mappings":"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"}