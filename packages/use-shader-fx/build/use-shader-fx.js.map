{"version":3,"file":"use-shader-fx.js","sources":["../src/hooks/useBrush/shader/main.vert","../src/hooks/useBrush/shader/main.frag","../src/utils/useResolution.ts","../src/utils/useAddMesh.ts","../src/utils/setUniforms.ts","../src/hooks/useBrush/useMesh.ts","../src/utils/useCamera.ts","../src/utils/useSingleFBO.ts","../src/utils/useDoubleFBO.ts","../src/utils/usePointer.ts","../src/utils/useParams.ts","../src/hooks/useBrush/index.ts","../src/hooks/useDuoTone/shader/main.vert","../src/hooks/useDuoTone/shader/main.frag","../src/hooks/useDuoTone/useMesh.ts","../src/hooks/useDuoTone/index.ts","../src/hooks/useFlowmap/shader/main.vert","../src/hooks/useFlowmap/shader/main.frag","../src/hooks/useFlowmap/useMesh.ts","../src/hooks/useFlowmap/index.ts","../src/hooks/useFogProjection/shader/main.vert","../src/hooks/useFogProjection/shader/main.frag","../src/hooks/useFogProjection/useMesh.ts","../src/hooks/useFogProjection/index.ts","../src/hooks/useFruid/shaders/main.vert","../src/hooks/useFruid/shaders/init.frag","../src/hooks/useFruid/materials/useInitialMaterial.ts","../src/hooks/useFruid/shaders/advection.frag","../src/hooks/useFruid/materials/useAdvectionMaterial.ts","../src/hooks/useFruid/shaders/divergence.frag","../src/hooks/useFruid/materials/useDivergenceMaterial.ts","../src/hooks/useFruid/shaders/pressure.frag","../src/hooks/useFruid/materials/usePressureMaterial.ts","../src/hooks/useFruid/shaders/curl.frag","../src/hooks/useFruid/materials/useCurlMaterial.ts","../src/hooks/useFruid/shaders/vorticity.frag","../src/hooks/useFruid/materials/useVorticityMaterial.ts","../src/hooks/useFruid/shaders/clear.frag","../src/hooks/useFruid/materials/useClearMaterial.ts","../src/hooks/useFruid/shaders/gradientSubtract.frag","../src/hooks/useFruid/materials/useGradientSubtractMaterial.ts","../src/hooks/useFruid/shaders/splat.frag","../src/hooks/useFruid/materials/useSplatMaterial.ts","../src/hooks/useFruid/useMesh.ts","../src/hooks/useFruid/index.ts","../src/hooks/useRipple/useMesh.ts","../src/hooks/useRipple/index.ts","../src/hooks/useTransitionBg/shader/main.vert","../src/hooks/useTransitionBg/shader/main.frag","../src/hooks/useTransitionBg/useMesh.ts","../src/hooks/useTransitionBg/index.ts","../src/hooks/useNoise/shader/main.vert","../src/hooks/useNoise/shader/main.frag","../src/hooks/useNoise/useMesh.ts","../src/hooks/useNoise/index.ts"],"sourcesContent":["varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nuniform sampler2D uMap;\nuniform sampler2D uTexture;\nuniform float uRadius;\nuniform float uDissipation;\nuniform vec2 uResolution;\nuniform float uSmudge;\nuniform float uAspect;\nuniform vec2 uMouse;\nuniform vec2 uPrevMouse;\nuniform vec2 uVelocity;\nuniform vec3 uColor;\nuniform float uMotionBlur;\nuniform int uMotionSample;\n\nvarying vec2 vUv;\n\nfloat isOnLine(vec2 point, vec2 start, vec2 end, float width, float aspect) {\n\t//正円にする\n\tpoint.x *= aspect;\n\tstart.x *= aspect;\n\tend.x *= aspect;\n\n\t//方向の単位ベクトル\n\tvec2 dir = normalize(end - start);\n\t//線分に対して垂直の単位ベクトル\n\tvec2 n = vec2(dir.y, -dir.x);\n\t//方向ベクトル\n\tvec2 p0 = point - start;\n\t\n\t//線上の距離を計算する\n\tfloat distToLine = abs(dot(p0, n));\n\tfloat distAlongLine = dot(p0, dir);\n\tfloat totalLength = length(end - start);\n\n\t//始点と終点の円の半径も範囲に含める\n\tfloat distFromStart = length(point - start);\n\tfloat distFromEnd = length(point - end);\n\t\n\tbool withinLine = (distToLine < width && distAlongLine > 0.0 && distAlongLine < totalLength) || distFromStart < width || distFromEnd < width;\n\n\treturn float(withinLine);\n}\n\nvec4 createSmudge(){\n\tvec2 offsets[9];\n\toffsets[0] = vec2(-1, -1); offsets[1] = vec2( 0, -1); offsets[2] = vec2( 1, -1);\n\toffsets[3] = vec2(-1,  0); offsets[4] = vec2( 0,  0); offsets[5] = vec2( 1,  0);\n\toffsets[6] = vec2(-1,  1); offsets[7] = vec2( 0,  1); offsets[8] = vec2( 1,  1);\n\t// オフセットをテクスチャサイズにスケール\n\tfor(int i = 0; i < 9; i++) {\n\t\toffsets[i] = (offsets[i] * uSmudge) / uResolution;\n\t}\t\n\tvec4 smudgedColor = vec4(0.0);\n\tfor(int i = 0; i < 9; i++) {\n\t\tsmudgedColor += texture2D(uMap, vUv + offsets[i]);\n\t}\n\treturn smudgedColor / 9.0;\n}\n\nvec4 createMotionBlur(vec4 baseColor, vec2 velocity, float motion, int samples) {\n\tvec4 motionBlurredColor = baseColor;\n\tvec2 scaledVelocity = velocity * motion;\n\tfor(int i = 1; i < samples; i++) {\n\t\tfloat t = float(i) / float(samples - 1);\n\t\tvec2 offset = t * scaledVelocity / uResolution;\n\t\tmotionBlurredColor += texture2D(uMap, vUv + offset);\n\t}\n\treturn motionBlurredColor / float(samples);\n}\n\n\nvoid main() {\n\t// UV座標を[-1, 1]の範囲に変換\n\tvec2 st = vUv * 2.0 - 1.0;\n\t\n\t// 速度ベクトル\n\tvec2 velocity = uVelocity * uResolution;\n\n\t// 滲みを加える\n\tvec4 smudgedColor = createSmudge();\n\t\n\t// モーションブラー\n\tvec4 motionBlurredColor = createMotionBlur(smudgedColor, velocity, uMotionBlur,uMotionSample);\n\n\t// バッファーテクスチャー\n\tvec4 bufferColor = motionBlurredColor * uDissipation;\n\n\t// radius\n\tfloat modifiedRadius = max(0.0,uRadius);\n\n\t//\tcolor \n\tvec3 color = uColor;\n\n\t// カラーにテクスチャーをマッピングする\n\tvec4 textureColor = texture2D(uTexture, vUv);\n\tvec3 finalColor = mix(color, textureColor.rgb, textureColor.a);\n\n\t// 始点と終点の直線上を判定する\n\tfloat onLine = isOnLine(st, uPrevMouse, uMouse, modifiedRadius, uAspect);\n\tbufferColor.rgb = mix(bufferColor.rgb, finalColor, onLine);\n\t\n\tgl_FragColor = vec4(bufferColor.rgb,1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\n/**\n * @params isDpr Whether to multiply dpr, default:false\n */\nexport const useResolution = (size: Size, dpr: number | false = false) => {\n   const _width = dpr ? size.width * dpr : size.width;\n   const _height = dpr ? size.height * dpr : size.height;\n   const resolution = useMemo(\n      () => new THREE.Vector2(_width, _height),\n      [_width, _height]\n   );\n   return resolution;\n};\n","import * as THREE from \"three\";\nimport { useEffect, useMemo } from \"react\";\n\nexport const useAddMesh = (\n   scene: THREE.Scene,\n   geometry: THREE.PlaneGeometry,\n   material: THREE.Material\n) => {\n   const mesh = useMemo(\n      () => new THREE.Mesh(geometry, material),\n      [geometry, material]\n   );\n   useEffect(() => {\n      scene.add(mesh);\n   }, [scene, mesh]);\n   return mesh;\n};\n","type UniformValue =\n   | THREE.CubeTexture\n   | THREE.Texture\n   | Int32Array\n   | Float32Array\n   | THREE.Matrix4\n   | THREE.Matrix3\n   | THREE.Quaternion\n   | THREE.Vector4\n   | THREE.Vector3\n   | THREE.Vector2\n   | THREE.Color\n   | number\n   | boolean\n   | Array<any>\n   | null;\ntype UniformObject = { [key: string]: { value: UniformValue } };\n\nexport const setUniform = <T extends UniformObject>(\n   material: { uniforms: T },\n   key: keyof T,\n   value: UniformValue\n) => {\n   if (\n      material.uniforms &&\n      material.uniforms[key] &&\n      value !== undefined &&\n      value !== null\n   ) {\n      material.uniforms[key].value = value;\n   } else {\n      console.error(\n         `Uniform key \"${String(\n            key\n         )}\" does not exist in the material. or \"${String(\n            key\n         )}\" is null | undefined`\n      );\n   }\n};\n","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useEffect, useMemo } from \"react\";\nimport { useResolution } from \"../../utils/useResolution\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TUniforms = {\n   uMap: { value: THREE.Texture };\n   uResolution: { value: THREE.Texture };\n   uAspect: { value: number };\n   uTexture: { value: THREE.Texture };\n   uRadius: { value: number };\n   uSmudge: { value: number };\n   uDissipation: { value: number };\n   uMotionBlur: { value: number };\n   uMotionSample: { value: number };\n   uMouse: { value: number };\n   uPrevMouse: { value: number };\n   uVelocity: { value: number };\n   uColor: { value: THREE.Color };\n};\n\nexport class BrushMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uMap: { value: new THREE.Texture() },\n               uResolution: { value: new THREE.Vector2(0, 0) },\n               uAspect: { value: 0.0 },\n               uTexture: { value: new THREE.Texture() },\n               uRadius: { value: 0.0 },\n               uSmudge: { value: 0.0 },\n               uDissipation: { value: 0.0 },\n               uMotionBlur: { value: 0.0 },\n               uMotionSample: { value: 0 },\n               uMouse: { value: new THREE.Vector2(0, 0) },\n               uPrevMouse: { value: new THREE.Vector2(0, 0) },\n               uVelocity: { value: new THREE.Vector2(0, 0) },\n               uColor: { value: new THREE.Color(0xffffff) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(material, \"uAspect\", resolution.width / resolution.height);\n      setUniform(material, \"uResolution\", resolution.clone());\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material as BrushMaterial;\n};\n","import * as THREE from \"three\";\nimport { useResolution } from \"./useResolution\";\nimport { useMemo } from \"react\";\nimport { Size } from \"@react-three/fiber\";\n\nconst getCameraProps = (width: number, height: number) => {\n   const frustumSize = height;\n   const aspect = width / height;\n   const [w, h] = [(frustumSize * aspect) / 2, frustumSize / 2];\n   return { width: w, height: h, near: -1000, far: 1000 };\n};\n\nexport const useCamera = (size: Size) => {\n   const resolution = useResolution(size);\n   const { width, height, near, far } = getCameraProps(\n      resolution.x,\n      resolution.y\n   );\n   const camera = useMemo(\n      () =>\n         new THREE.OrthographicCamera(\n            -width,\n            width,\n            height,\n            -height,\n            near,\n            far\n         ),\n      [width, height, near, far]\n   );\n   return camera;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useLayoutEffect, useMemo, useRef } from \"react\";\nimport { useResolution } from \"./useResolution\";\nimport { UseFboProps } from \"./types\";\n\nexport const FBO_OPTION = {\n   minFilter: THREE.LinearFilter,\n   magFilter: THREE.LinearFilter,\n   type: THREE.HalfFloatType,\n   depthBuffer: false,\n   stencilBuffer: false,\n};\n\ntype FBOUpdateFunction = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({ read }: { read: THREE.Texture }) => void\n) => THREE.Texture;\n\ntype Return = [THREE.WebGLRenderTarget, FBOUpdateFunction];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [THREE.WebGLRenderTarget , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useSingleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n}: UseFboProps): Return => {\n   const renderTarget = useRef<THREE.WebGLRenderTarget>();\n\n   const resolution = useResolution(size, dpr);\n   renderTarget.current = useMemo(\n      () => new THREE.WebGLRenderTarget(resolution.x, resolution.y, FBO_OPTION),\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      []\n   );\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current?.setSize(resolution.x, resolution.y);\n      }\n   }, [resolution, isSizeUpdate]);\n\n   const updateRenderTarget: FBOUpdateFunction = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current!;\n         gl.setRenderTarget(fbo);\n         onBeforeRender && onBeforeRender({ read: fbo.texture });\n         gl.render(scene, camera);\n         gl.setRenderTarget(null);\n         gl.clear();\n         return fbo.texture;\n      },\n      [scene, camera]\n   );\n\n   return [renderTarget.current, updateRenderTarget];\n};\n","import * as THREE from \"three\";\nimport {\n   useCallback,\n   useEffect,\n   useLayoutEffect,\n   useMemo,\n   useRef,\n} from \"react\";\nimport { FBO_OPTION } from \"./useSingleFBO\";\nimport { useResolution } from \"./useResolution\";\nimport { DoubleRenderTarget, UseFboProps } from \"./types\";\n\ninterface RenderTarget extends DoubleRenderTarget {\n   swap: () => void;\n}\n\ntype FBOUpdateFunction = (\n   gl: THREE.WebGLRenderer,\n   /**  call before FBO is rendered */\n   onBeforeRender?: ({\n      read,\n      write,\n   }: {\n      read: THREE.Texture;\n      write: THREE.Texture;\n   }) => void\n) => THREE.Texture;\n\ntype Return = [\n   { read: THREE.WebGLRenderTarget; write: THREE.WebGLRenderTarget },\n   FBOUpdateFunction\n];\n\n/**\n * @param dpr If dpr is set, dpr will be multiplied, default:false\n * @param isSizeUpdate Whether to resize when resizing occurs. If isDpr is true, set FBO to setSize even if dpr is changed, default:false\n * @returns [{read:THREE.WebGLRenderTarget,write:THREE.WebGLRenderTarget} , updateFBO] -Receives the RenderTarget as the first argument and the update function as the second argument.\n */\nexport const useDoubleFBO = ({\n   scene,\n   camera,\n   size,\n   dpr = false,\n   isSizeUpdate = false,\n}: UseFboProps): Return => {\n   const renderTarget = useRef<RenderTarget>({\n      read: null,\n      write: null,\n      swap: function () {\n         let temp = this.read;\n         this.read = this.write;\n         this.write = temp;\n      },\n   });\n\n   const resolution = useResolution(size, dpr);\n   const initRenderTargets = useMemo(() => {\n      const read = new THREE.WebGLRenderTarget(\n         resolution.x,\n         resolution.y,\n         FBO_OPTION\n      );\n      const write = new THREE.WebGLRenderTarget(\n         resolution.x,\n         resolution.y,\n         FBO_OPTION\n      );\n      return { read, write };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, []);\n   renderTarget.current.read = initRenderTargets.read;\n   renderTarget.current.write = initRenderTargets.write;\n\n   useLayoutEffect(() => {\n      if (isSizeUpdate) {\n         renderTarget.current.read?.setSize(resolution.x, resolution.y);\n         renderTarget.current.write?.setSize(resolution.x, resolution.y);\n      }\n   }, [resolution, isSizeUpdate]);\n\n   const updateRenderTarget: FBOUpdateFunction = useCallback(\n      (gl, onBeforeRender) => {\n         const fbo = renderTarget.current;\n         gl.setRenderTarget(fbo.write);\n         onBeforeRender &&\n            onBeforeRender({\n               read: fbo.read!.texture,\n               write: fbo.write!.texture,\n            });\n         gl.render(scene, camera);\n         fbo.swap();\n         gl.setRenderTarget(null);\n         gl.clear();\n         return fbo.read?.texture as THREE.Texture;\n      },\n      [scene, camera]\n   );\n\n   return [\n      { read: renderTarget.current.read, write: renderTarget.current.write },\n      updateRenderTarget,\n   ];\n};\n","import * as THREE from \"three\";\nimport { useCallback, useRef } from \"react\";\n\ntype UpdatePointer = (currentPointer: THREE.Vector2) => {\n   currentPointer: THREE.Vector2;\n   prevPointer: THREE.Vector2;\n   diffPointer: THREE.Vector2;\n   velocity: THREE.Vector2;\n   isVelocityUpdate: boolean;\n};\n\nexport const usePointer = (): UpdatePointer => {\n   const prevPointer = useRef(new THREE.Vector2(0, 0));\n   const diffPointer = useRef(new THREE.Vector2(0, 0));\n   const lastUpdateTime = useRef<number>(0);\n   const velocity = useRef(new THREE.Vector2(0, 0));\n   const isMoved = useRef(false);\n\n   const updatePointer = useCallback((currentPointer: THREE.Vector2) => {\n      const now = performance.now();\n      const current = currentPointer.clone();\n\n      // first frame\n      if (lastUpdateTime.current === 0) {\n         lastUpdateTime.current = now;\n         prevPointer.current = current;\n      }\n      const deltaTime = Math.max(1, now - lastUpdateTime.current);\n      lastUpdateTime.current = now;\n\n      // get velocity\n      velocity.current\n         .copy(current)\n         .sub(prevPointer.current)\n         .divideScalar(deltaTime);\n      const isUpdate = velocity.current.length() > 0;\n\n      //set prev temp pos\n      const prevTemp = isMoved.current ? prevPointer.current.clone() : current;\n      if (!isMoved.current && isUpdate) {\n         isMoved.current = true;\n      }\n      prevPointer.current = current;\n\n      return {\n         currentPointer: current,\n         prevPointer: prevTemp,\n         diffPointer: diffPointer.current.subVectors(current, prevTemp),\n         velocity: velocity.current,\n         isVelocityUpdate: isUpdate,\n      };\n   }, []);\n\n   return updatePointer;\n};\n","import { useCallback, useRef } from \"react\";\n\ntype Return<T> = [T, (params: Partial<T>) => void];\n\nexport const useParams = <T extends object>(params: T): Return<T> => {\n   const paramsRef = useRef(params);\n   const setParams = useCallback((updateParams: Partial<T>) => {\n      for (const key in updateParams) {\n         const paramKey = key as keyof T;\n         if (\n            paramKey in paramsRef.current &&\n            updateParams[paramKey] !== undefined &&\n            updateParams[paramKey] !== null\n         ) {\n            paramsRef.current[paramKey] = updateParams[paramKey]!;\n         } else {\n            console.error(\n               `\"${String(\n                  paramKey\n               )}\" does not exist in the params. or \"${String(\n                  paramKey\n               )}\" is null | undefined`\n            );\n         }\n      }\n   }, []);\n   return [paramsRef.current, setParams];\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { useDoubleFBO } from \"../../utils/useDoubleFBO\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { usePointer } from \"../../utils/usePointer\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\nimport { DoubleRenderTarget } from \"../../utils/types\";\n\nexport type BrushParams = {\n   /** ブラシに適用するテクスチャー.aの値でmixさせてます , default:THREE.Texture() */\n   texture?: THREE.Texture;\n   /** size of the stamp, percentage of the size ,default:0.05 */\n   radius?: number;\n   /** 滲み効果の強さ , default:0.0*/\n   smudge?: number;\n   /** 拡散率。1にすると残り続ける ,default:0.9 */\n   dissipation?: number;\n   /** モーションブラーの強さ , default:0.0 */\n   motionBlur?: number;\n   /** モーションブラーのサンプル数 これを高くするとパフォーマンスへの影響大, default: 5 */\n   motionSample?: number;\n   /** ブラシの色 , default:THREE.Color(0xffffff) */\n   color?: THREE.Color;\n};\n\nexport type BrushObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: DoubleRenderTarget;\n};\n\nexport const BRUSH_PARAMS: BrushParams = {\n   texture: new THREE.Texture(),\n   radius: 0.05,\n   smudge: 0.0,\n   dissipation: 0.9,\n   motionBlur: 0.0,\n   motionSample: 5,\n   color: new THREE.Color(0xffffff),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useBrush = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<BrushParams, BrushObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useDoubleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<BrushParams>(BRUSH_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: BrushParams) => {\n         const { gl, pointer } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uRadius\", params.radius!);\n         setUniform(material, \"uSmudge\", params.smudge!);\n         setUniform(material, \"uDissipation\", params.dissipation!);\n         setUniform(material, \"uMotionBlur\", params.motionBlur!);\n         setUniform(material, \"uMotionSample\", params.motionSample!);\n         setUniform(material, \"uColor\", params.color!);\n\n         const { currentPointer, prevPointer, velocity } =\n            updatePointer(pointer);\n         setUniform(material, \"uMouse\", currentPointer);\n         setUniform(material, \"uPrevMouse\", prevPointer);\n         setUniform(material, \"uVelocity\", velocity);\n\n         const bufferTexture = updateRenderTarget(gl, ({ read }) => {\n            setUniform(material, \"uMap\", read);\n         });\n\n         return bufferTexture;\n      },\n      [material, updatePointer, updateRenderTarget, params, setParams]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\n\nuniform vec3 uColor0;\nuniform vec3 uColor1;\n\nvoid main() {\n\tvec2 uv = vUv;\n\tvec4 texColor = texture2D(uTexture, uv);\n\tfloat grayscale = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n\tvec3 duotone = mix(uColor0, uColor1, grayscale);\n\tgl_FragColor = vec4(duotone, texColor.a);\n}","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\n\ntype TUniforms = {\n   uTexture: { value: THREE.Texture };\n   uColor0: { value: THREE.Color };\n   uColor1: { value: THREE.Color };\n};\n\nexport class DuoToneMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               uColor0: { value: new THREE.Color(0xffffff) },\n               uColor1: { value: new THREE.Color(0x000000) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as DuoToneMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { DuoToneMaterial, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\n\nexport type DuoToneParams = {\n   /** Make this texture duotone , Default:new THREE.Texture() */\n   texture?: THREE.Texture;\n   /** 1色目 ,　Default:new THREE.Color(0xffffff) */\n   color0?: THREE.Color;\n   /** 2色目 , Default: new THREE.Color(0x000000) */\n   color1?: THREE.Color;\n};\n\nexport type DuoToneObject = {\n   scene: THREE.Scene;\n   material: DuoToneMaterial;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const DUOTONE_PARAMS: DuoToneParams = {\n   texture: new THREE.Texture(),\n   color0: new THREE.Color(0xffffff),\n   color1: new THREE.Color(0x000000),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useDuoTone = ({\n   size,\n}: {\n   size: Size;\n}): HooksReturn<DuoToneParams, DuoToneObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<DuoToneParams>(DUOTONE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: DuoToneParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uColor0\", params.color0!);\n         setUniform(material, \"uColor1\", params.color1!);\n\n         const bufferTexture = updateRenderTarget(gl);\n\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nuniform sampler2D uMap;\nuniform float uRadius;\nuniform float uAlpha;\nuniform float uDissipation;\nuniform float uMagnification;\nuniform vec2 uResolution;\n\nuniform float uAspect;\nuniform vec2 uMouse;\nuniform vec2 uVelocity;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec2 st = vUv * 2.0 - 1.0; // UV座標を[-1, 1]の範囲に変換\n\n\tvec2 vel = uVelocity * uResolution;\n\n\t// buffer color\n\tvec4 bufferColor = texture2D(uMap, vUv) * uDissipation;\n\t\n\t//\tcolor\n\tvec3 color = vec3(vel * vec2(1, -1), 1.0 - pow(1.0 - min(1.0, length(vel)), 1.0));\n\t// vec3 color = vec3(1.0,1.0,1.0);\n\n\t// cursor\n\tvec2 nMouse = (uMouse + vec2(1.0)) * 0.5;\n\tvec2 cursor = vUv - nMouse;\n\tcursor.x *= uAspect;\n\n\t// radius\n\tfloat modifiedRadius = uRadius + (length(vel) * uMagnification);\n\tmodifiedRadius = max(0.0,modifiedRadius);\n\tfloat finalBrush = smoothstep(modifiedRadius,0.0,length(cursor)) * uAlpha;\n\n\t// mix buffer and current color\n\tbufferColor.rgb = mix(bufferColor.rgb, color, vec3(finalBrush));\n\n\tgl_FragColor = bufferColor;\n}","import * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useEffect, useMemo } from \"react\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\nimport { useResolution } from \"../../utils/useResolution\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uMap: { value: null },\n               uResolution: { value: new THREE.Vector2(0, 0) },\n               uAspect: { value: 1 },\n               uRadius: { value: 0.0 },\n               uAlpha: { value: 0.0 },\n               uDissipation: { value: 0.0 },\n               uMagnification: { value: 0.0 },\n               uMouse: { value: new THREE.Vector2(0, 0) },\n               uVelocity: { value: new THREE.Vector2(0, 0) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size, dpr);\n\n   useEffect(() => {\n      setUniform(material, \"uAspect\", resolution.width / resolution.height);\n      setUniform(material, \"uResolution\", resolution.clone());\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material;\n};\n","import * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { useDoubleFBO } from \"../../utils/useDoubleFBO\";\nimport { useCallback, useMemo } from \"react\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { usePointer } from \"../../utils/usePointer\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\nimport { DoubleRenderTarget } from \"../../utils/types\";\n\nexport type FlowmapParams = {\n   /** size of the stamp, percentage of the size ,default:0.1 */\n   radius?: number;\n   /** 拡大率 , default:0.0 */\n   magnification?: number;\n   /** opacity  , default:0.0 */\n   alpha?: number;\n   /** 拡散率。1にすると残り続ける , default:0.9 */\n   dissipation?: number;\n};\n\nexport type FlowmapObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: DoubleRenderTarget;\n};\n\nexport const FLOWMAP_PARAMS: FlowmapParams = {\n   radius: 0.1,\n   magnification: 0.0,\n   alpha: 0.0,\n   dissipation: 0.9,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useFlowmap = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<FlowmapParams, FlowmapObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useDoubleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<FlowmapParams>(FLOWMAP_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FlowmapParams) => {\n         const { gl, pointer } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uRadius\", params.radius!);\n         setUniform(material, \"uAlpha\", params.alpha!);\n         setUniform(material, \"uDissipation\", params.dissipation!);\n         setUniform(material, \"uMagnification\", params.magnification!);\n\n         const { currentPointer, velocity } = updatePointer(pointer);\n         setUniform(material, \"uMouse\", currentPointer);\n         setUniform(material, \"uVelocity\", velocity);\n\n         const bufferTexture = updateRenderTarget(gl, ({ read }) => {\n            setUniform(material, \"uMap\", read);\n         });\n\n         return bufferTexture;\n      },\n      [material, updatePointer, updateRenderTarget, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform float uTime;\nuniform sampler2D uTexture;\nuniform sampler2D uNoiseMap;\nuniform float distortionStrength;\nuniform float fogEdge0;\nuniform float fogEdge1;\nuniform vec3 fogColor;\n\nvoid main() {\n\tvec2 uv = vUv;\n\n\tfloat noiseMap = texture2D(uNoiseMap,uv).r;\n\t\n\tfloat noiseTextureMap = noiseMap*2.0-1.0;\n\tuv += noiseTextureMap * distortionStrength;\n\tvec3 textureMap = texture2D(uTexture, uv).rgb;\n\n\tfloat edge0 = fogEdge0;\n\tfloat edge1 = fogEdge1;\n\tfloat blendValue = smoothstep(edge0, edge1, noiseMap);\n\n\tvec3 outputColor = blendValue * fogColor + (1.0 - blendValue) * textureMap;\n\tgl_FragColor = vec4(outputColor, 1.0);\n}\n\n\n","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\n\ntype TUniforms = {\n   uTime: { value: number };\n   uTexture: { value: THREE.Texture };\n   uNoiseMap: { value: THREE.Texture };\n   distortionStrength: { value: number };\n   fogEdge0: { value: number };\n   fogEdge1: { value: number };\n   fogColor: { value: THREE.Color };\n};\n\nexport class FogProjectionMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTime: { value: 0.0 },\n               uTexture: { value: new THREE.Texture() },\n               uNoiseMap: { value: new THREE.Texture() },\n               distortionStrength: { value: 0.0 },\n               fogEdge0: { value: 0.0 },\n               fogEdge1: { value: 0.9 },\n               fogColor: { value: new THREE.Color(0xffffff) },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as FogProjectionMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\n\nexport type FogProjectionParams = {\n   /** Make this texture FogProjection , default:THREE.Texture */\n   texture?: THREE.Texture;\n   /** 重ねがけるnoise texture, default:THREE.Texture */\n   noiseMap?: THREE.Texture;\n   /** 乗算するdistortionの強さ , default:0.03 */\n   distortionStrength?: number;\n   /** noiseを反映する底地 , default:0.0 */\n   fogEdge0?: number;\n   /** noiseを反映する天井値 , default:0.9  */\n   fogEdge1?: number;\n   /** fogのカラー , default: THREE.Color(0xffffff) */\n   fogColor?: THREE.Color;\n};\n\nexport type FogProjectionObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const FOGPROJECTION_PARAMS: FogProjectionParams = {\n   texture: new THREE.Texture(),\n   noiseMap: new THREE.Texture(),\n   distortionStrength: 0.03,\n   fogEdge0: 0.0,\n   fogEdge1: 0.9,\n   fogColor: new THREE.Color(0xffffff),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useFogProjection = ({\n   size,\n}: {\n   size: Size;\n}): HooksReturn<FogProjectionParams, FogProjectionObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] =\n      useParams<FogProjectionParams>(FOGPROJECTION_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FogProjectionParams) => {\n         const { gl, clock } = props;\n         updateParams && setParams(updateParams);\n         setUniform(material, \"uTime\", clock.getElapsedTime());\n         setUniform(material, \"uTexture\", params.texture!);\n         setUniform(material, \"uNoiseMap\", params.noiseMap!);\n         setUniform(material, \"distortionStrength\", params.distortionStrength!);\n         setUniform(material, \"fogEdge0\", params.fogEdge0!);\n         setUniform(material, \"fogEdge1\", params.fogEdge1!);\n         setUniform(material, \"fogColor\", params.fogColor!);\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform vec2 texelSize;\n\nvoid main () {\n\tvUv = uv;\n\tvL = vUv - vec2(texelSize.x, 0.0);\n\tvR = vUv + vec2(texelSize.x, 0.0);\n\tvT = vUv + vec2(0.0, texelSize.y);\n\tvB = vUv - vec2(0.0, texelSize.y);\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvoid main(){\n\tgl_FragColor = vec4(0.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/init.frag\";\n\nexport const useInitialMaterial = () => {\n   const initialMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      []\n   );\n\n   return initialMaterial as THREE.ShaderMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uVelocity;\nuniform sampler2D uSource;\nuniform vec2 texelSize;\nuniform float dt;\nuniform float dissipation;\n\nvoid main () {\n\tvec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n\tgl_FragColor = dissipation * texture2D(uSource, coord);\n\tgl_FragColor.a = 1.0;\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/advection.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   uSource: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n   dt: { value: number };\n   dissipation: { value: number };\n};\n\nexport class AdvectionMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useAdvectionMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: new THREE.Texture() },\n               uSource: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n               dt: { value: 0.0 },\n               dissipation: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as AdvectionMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvec2 sampleVelocity (in vec2 uv) {\n\tvec2 multiplier = vec2(1.0, 1.0);\n\tif (uv.x < 0.0) { uv.x = 0.0; multiplier.x = -1.0; }\n\tif (uv.x > 1.0) { uv.x = 1.0; multiplier.x = -1.0; }\n\tif (uv.y < 0.0) { uv.y = 0.0; multiplier.y = -1.0; }\n\tif (uv.y > 1.0) { uv.y = 1.0; multiplier.y = -1.0; }\n\treturn multiplier * texture2D(uVelocity, uv).xy;\n}\n\nvoid main () {\n\tfloat L = sampleVelocity(vL).x;\n\tfloat R = sampleVelocity(vR).x;\n\tfloat T = sampleVelocity(vT).y;\n\tfloat B = sampleVelocity(vB).y;\n\tfloat div = 0.5 * (R - L + T - B);\n\tgl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/divergence.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class DivergenceMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useDivergenceMaterial = () => {\n   const divergenceMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return divergenceMaterial as DivergenceMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uDivergence;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tfloat C = texture2D(uPressure, vUv).x;\n\tfloat divergence = texture2D(uDivergence, vUv).x;\n\tfloat pressure = (L + R + B + T - divergence) * 0.25;\n\tgl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/pressure.frag\";\n\ntype TUniforms = {\n   uPressure: { value: THREE.Texture };\n   uDivergence: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class PressureMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const usePressureMaterial = () => {\n   const pressureMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: null },\n               uDivergence: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return pressureMaterial as PressureMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvoid main () {\n\tfloat L = texture2D(uVelocity, vL).y;\n\tfloat R = texture2D(uVelocity, vR).y;\n\tfloat T = texture2D(uVelocity, vT).x;\n\tfloat B = texture2D(uVelocity, vB).x;\n\tfloat vorticity = R - L - T + B;\n\tgl_FragColor = vec4(vorticity, 0.0, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/curl.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class CurlMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useCurlMaterial = () => {\n   const curlMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return curlMaterial as CurlMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\nuniform sampler2D uCurl;\nuniform float curl;\nuniform float dt;\n\nvoid main () {\n\tfloat T = texture2D(uCurl, vT).x;\n\tfloat B = texture2D(uCurl, vB).x;\n\tfloat C = texture2D(uCurl, vUv).x;\n\tvec2 force = vec2(abs(T) - abs(B), 0.0);\n\tforce *= 1.0 / length(force + 0.00001) * curl * C;\n\tvec2 vel = texture2D(uVelocity, vUv).xy;\n\tgl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/vorticity.frag\";\n\ntype TUniforms = {\n   uVelocity: { value: THREE.Texture };\n   uCurl: { value: THREE.Texture };\n   curl: { value: number };\n   dt: { value: number };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class VorticityMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useVorticityMaterial = () => {\n   const vorticityMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uVelocity: { value: null },\n               uCurl: { value: null },\n               curl: { value: 0 },\n               dt: { value: 0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return vorticityMaterial as VorticityMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform float value;\n\nvoid main () {\n\tgl_FragColor = value * texture2D(uTexture, vUv);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/clear.frag\";\n\ntype TUniforms = {\n   uTexture: { value: THREE.Texture };\n   value: { value: number };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class ClearMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useClearMaterial = () => {\n   const advectionMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTexture: { value: new THREE.Texture() },\n               value: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return advectionMaterial as ClearMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uVelocity;\n\nvec2 boundary (in vec2 uv) {\n\tuv = min(max(uv, 0.0), 1.0);\n\treturn uv;\n}\n\nvoid main () {\n\tfloat L = texture2D(uPressure, boundary(vL)).x;\n\tfloat R = texture2D(uPressure, boundary(vR)).x;\n\tfloat T = texture2D(uPressure, boundary(vT)).x;\n\tfloat B = texture2D(uPressure, boundary(vB)).x;\n\tvec2 velocity = texture2D(uVelocity, vUv).xy;\n\tvelocity.xy -= vec2(R - L, T - B);\n\tgl_FragColor = vec4(velocity, 0.0, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/gradientSubtract.frag\";\n\ntype TUniforms = {\n   uPressure: { value: THREE.Texture };\n   uVelocity: { value: THREE.Texture };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class GradientSubtractMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useGradientSubtractMaterial = () => {\n   const gradientSubtractMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uPressure: { value: new THREE.Texture() },\n               uVelocity: { value: new THREE.Texture() },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return gradientSubtractMaterial as GradientSubtractMaterial;\n};\n","precision mediump float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uTarget;\nuniform float aspectRatio;\nuniform vec3 color;\nuniform vec2 point;\nuniform float radius;\n\nvoid main () {\n\tvec2 nPoint = (point + vec2(1.0)) * 0.5;\n\tvec2 p = vUv - nPoint.xy;\n\tp.x *= aspectRatio;\n\tvec3 splat = exp(-dot(p, p) / radius) * color;\n\tvec3 base = texture2D(uTarget, vUv).xyz;\n\tgl_FragColor = vec4(base + splat, 1.0);\n}","import * as THREE from \"three\";\nimport { useMemo } from \"react\";\nimport vertexShader from \"../shaders/main.vert\";\nimport fragmentShader from \"../shaders/splat.frag\";\n\ntype TUniforms = {\n   uTarget: { value: THREE.Texture };\n   aspectRatio: { value: number };\n   color: { value: THREE.Vector3 };\n   point: { value: THREE.Vector2 };\n   radius: { value: number };\n   texelSize: { value: THREE.Vector2 };\n};\n\nexport class SplatMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useSplateMaterial = () => {\n   const splatMaterial = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTarget: { value: new THREE.Texture() },\n               aspectRatio: { value: 0 },\n               color: { value: new THREE.Vector3() },\n               point: { value: new THREE.Vector2() },\n               radius: { value: 0.0 },\n               texelSize: { value: new THREE.Vector2() },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   return splatMaterial as SplatMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useEffect, useMemo } from \"react\";\nimport { useInitialMaterial } from \"./materials/useInitialMaterial\";\nimport {\n   AdvectionMaterial,\n   useAdvectionMaterial,\n} from \"./materials/useAdvectionMaterial\";\nimport {\n   DivergenceMaterial,\n   useDivergenceMaterial,\n} from \"./materials/useDivergenceMaterial\";\nimport {\n   PressureMaterial,\n   usePressureMaterial,\n} from \"./materials/usePressureMaterial\";\nimport { CurlMaterial, useCurlMaterial } from \"./materials/useCurlMaterial\";\nimport {\n   VorticityMaterial,\n   useVorticityMaterial,\n} from \"./materials/useVorticityMaterial\";\nimport { useResolution } from \"../../utils/useResolution\";\nimport { ClearMaterial, useClearMaterial } from \"./materials/useClearMaterial\";\nimport {\n   GradientSubtractMaterial,\n   useGradientSubtractMaterial,\n} from \"./materials/useGradientSubtractMaterial\";\nimport { SplatMaterial, useSplateMaterial } from \"./materials/useSplatMaterial\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TMaterials =\n   | AdvectionMaterial\n   | DivergenceMaterial\n   | CurlMaterial\n   | PressureMaterial\n   | ClearMaterial\n   | GradientSubtractMaterial\n   | SplatMaterial;\n\nexport type FruidMaterials = {\n   vorticityMaterial: VorticityMaterial;\n   curlMaterial: CurlMaterial;\n   advectionMaterial: AdvectionMaterial;\n   divergenceMaterial: DivergenceMaterial;\n   pressureMaterial: PressureMaterial;\n   clearMaterial: ClearMaterial;\n   gradientSubtractMaterial: GradientSubtractMaterial;\n   splatMaterial: SplatMaterial;\n};\ntype TUseMeshReturnType = [FruidMaterials, (material: TMaterials) => void];\n\n/**\n * Returns the material update function in the second argument\n */\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}): TUseMeshReturnType => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const initialMaterial = useInitialMaterial();\n   const updateMaterial = initialMaterial.clone();\n   const curlMaterial = useCurlMaterial();\n   const vorticityMaterial = useVorticityMaterial();\n   const advectionMaterial = useAdvectionMaterial();\n   const divergenceMaterial = useDivergenceMaterial();\n   const pressureMaterial = usePressureMaterial();\n   const clearMaterial = useClearMaterial();\n   const gradientSubtractMaterial = useGradientSubtractMaterial();\n   const splatMaterial = useSplateMaterial();\n   const materials = useMemo(\n      () => ({\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      }),\n      [\n         vorticityMaterial,\n         curlMaterial,\n         advectionMaterial,\n         divergenceMaterial,\n         pressureMaterial,\n         clearMaterial,\n         gradientSubtractMaterial,\n         splatMaterial,\n      ]\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      setUniform(\n         materials.splatMaterial,\n         \"aspectRatio\",\n         resolution.x / resolution.y\n      );\n      for (const material of Object.values(materials)) {\n         setUniform<any>(\n            material,\n            \"texelSize\",\n            new THREE.Vector2(1.0 / resolution.x, 1.0 / resolution.y)\n         );\n      }\n   }, [resolution, materials]);\n\n   const mesh = useAddMesh(scene, geometry, initialMaterial);\n   useEffect(() => {\n      initialMaterial.dispose();\n      mesh.material = updateMaterial;\n   }, [initialMaterial, mesh, updateMaterial]);\n\n   const setMeshMaterial = useCallback(\n      (material: TMaterials) => {\n         mesh.material = material;\n         mesh.material.needsUpdate = true;\n      },\n      [mesh]\n   );\n\n   return [materials, setMeshMaterial];\n};\n","import * as THREE from \"three\";\nimport { FruidMaterials, useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { useDoubleFBO } from \"../../utils/useDoubleFBO\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { usePointer } from \"../../utils/usePointer\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\nimport { DoubleRenderTarget } from \"../../utils/types\";\n\nexport type FruidParams = {\n   /** density disspation , default:0.98 */\n   density_dissipation?: number;\n   /** velocity dissipation , default:0.99 */\n   velocity_dissipation?: number;\n   /** velocity acceleration , default:10.0 */\n   velocity_acceleration?: number;\n   /** pressure dissipation , default:0.9 */\n   pressure_dissipation?: number;\n   /** pressure iterations. パフォーマンスに影響する , default:20 */\n   pressure_iterations?: number;\n   /** curl_strength , default:35 */\n   curl_strength?: number;\n   /** splat radius , default:0.002 */\n   splat_radius?: number;\n   /** 流体のカラー.THREE.Vector3 あるいは、THREE.Vector3を返す関数を受け入れます.関数はvelocity:THREE.Vector2を引数に取ります.  , default:THREE.Vector3(1.0, 1.0, 1.0) */\n   fruid_color?: ((velocity: THREE.Vector2) => THREE.Vector3) | THREE.Vector3;\n};\n\nexport type FruidObject = {\n   scene: THREE.Scene;\n   materials: FruidMaterials;\n   camera: THREE.Camera;\n   renderTarget: {\n      velocity: DoubleRenderTarget;\n      density: DoubleRenderTarget;\n      curl: THREE.WebGLRenderTarget;\n      divergence: THREE.WebGLRenderTarget;\n      pressure: DoubleRenderTarget;\n   };\n};\n\nexport const FRUID_PARAMS: FruidParams = {\n   density_dissipation: 0.98,\n   velocity_dissipation: 0.99,\n   velocity_acceleration: 10.0,\n   pressure_dissipation: 0.9,\n   pressure_iterations: 20,\n   curl_strength: 35,\n   splat_radius: 0.002,\n   fruid_color: new THREE.Vector3(1.0, 1.0, 1.0),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useFruid = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<FruidParams, FruidObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const [materials, setMeshMaterial] = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n\n   const fboProps = useMemo(\n      () => ({\n         scene,\n         camera,\n         size,\n         dpr,\n      }),\n      [scene, camera, size, dpr]\n   );\n   const [velocityFBO, updateVelocityFBO] = useDoubleFBO(fboProps);\n   const [densityFBO, updateDensityFBO] = useDoubleFBO(fboProps);\n   const [curlFBO, updateCurlFBO] = useSingleFBO(fboProps);\n   const [divergenceFBO, updateDivergenceFBO] = useSingleFBO(fboProps);\n   const [pressureFBO, updatePressureFBO] = useDoubleFBO(fboProps);\n\n   const lastTime = useRef(0);\n   const scaledDiffVec = useRef(new THREE.Vector2(0, 0));\n   const spaltVec = useRef(new THREE.Vector3(0, 0, 0));\n\n   const [params, setParams] = useParams<FruidParams>(FRUID_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: FruidParams) => {\n         const { gl, pointer, clock, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         if (lastTime.current === 0) {\n            lastTime.current = clock.getElapsedTime();\n         }\n         const dt = Math.min(\n            (clock.getElapsedTime() - lastTime.current) / 3,\n            0.02\n         );\n         lastTime.current = clock.getElapsedTime();\n\n         // update velocity\n         const velocityTex = updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", read);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(materials.advectionMaterial, \"dt\", dt);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.velocity_dissipation!\n            );\n         });\n\n         // update density\n         const densityTex = updateDensityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.advectionMaterial);\n            setUniform(materials.advectionMaterial, \"uVelocity\", velocityTex);\n            setUniform(materials.advectionMaterial, \"uSource\", read);\n            setUniform(\n               materials.advectionMaterial,\n               \"dissipation\",\n               params.density_dissipation!\n            );\n         });\n\n         // update splatting\n         const { currentPointer, diffPointer, isVelocityUpdate, velocity } =\n            updatePointer(pointer);\n         if (isVelocityUpdate) {\n            updateVelocityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               setUniform(materials.splatMaterial, \"point\", currentPointer);\n               const scaledDiff = diffPointer.multiply(\n                  scaledDiffVec.current\n                     .set(size.width, size.height)\n                     .multiplyScalar(params.velocity_acceleration!)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"color\",\n                  spaltVec.current.set(scaledDiff.x, scaledDiff.y, 1.0)\n               );\n               setUniform(\n                  materials.splatMaterial,\n                  \"radius\",\n                  params.splat_radius!\n               );\n            });\n            updateDensityFBO(gl, ({ read }) => {\n               setMeshMaterial(materials.splatMaterial);\n               setUniform(materials.splatMaterial, \"uTarget\", read);\n               const color: THREE.Vector3 =\n                  typeof params.fruid_color === \"function\"\n                     ? params.fruid_color(velocity)\n                     : params.fruid_color!;\n               setUniform(materials.splatMaterial, \"color\", color);\n            });\n         }\n\n         // update curl\n         const curlTex = updateCurlFBO(gl, () => {\n            setMeshMaterial(materials.curlMaterial);\n            setUniform(materials.curlMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update vorticity\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.vorticityMaterial);\n            setUniform(materials.vorticityMaterial, \"uVelocity\", read);\n            setUniform(materials.vorticityMaterial, \"uCurl\", curlTex);\n            setUniform(\n               materials.vorticityMaterial,\n               \"curl\",\n               params.curl_strength!\n            );\n            setUniform(materials.vorticityMaterial, \"dt\", dt);\n         });\n\n         // update divergence\n         const divergenceTex = updateDivergenceFBO(gl, () => {\n            setMeshMaterial(materials.divergenceMaterial);\n            setUniform(materials.divergenceMaterial, \"uVelocity\", velocityTex);\n         });\n\n         // update pressure\n         updatePressureFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.clearMaterial);\n            setUniform(materials.clearMaterial, \"uTexture\", read);\n            setUniform(\n               materials.clearMaterial,\n               \"value\",\n               params.pressure_dissipation!\n            );\n         });\n\n         // solve pressure iterative (Gauss-Seidel)\n         setMeshMaterial(materials.pressureMaterial);\n         setUniform(materials.pressureMaterial, \"uDivergence\", divergenceTex);\n         let pressureTexTemp: THREE.Texture;\n         for (let i = 0; i < params.pressure_iterations!; i++) {\n            pressureTexTemp = updatePressureFBO(gl, ({ read }) => {\n               setUniform(materials.pressureMaterial, \"uPressure\", read);\n            });\n         }\n\n         // update gradienSubtract\n         updateVelocityFBO(gl, ({ read }) => {\n            setMeshMaterial(materials.gradientSubtractMaterial);\n            setUniform(\n               materials.gradientSubtractMaterial,\n               \"uPressure\",\n               pressureTexTemp\n            );\n            setUniform(materials.gradientSubtractMaterial, \"uVelocity\", read);\n         });\n\n         return densityTex;\n      },\n      [\n         materials,\n         setMeshMaterial,\n         updateCurlFBO,\n         updateDensityFBO,\n         updateDivergenceFBO,\n         updatePointer,\n         updatePressureFBO,\n         updateVelocityFBO,\n         setParams,\n         params,\n      ]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         materials: materials,\n         camera: camera,\n         renderTarget: {\n            velocity: velocityFBO,\n            density: densityFBO,\n            curl: curlFBO,\n            divergence: divergenceFBO,\n            pressure: pressureFBO,\n         },\n      },\n   ];\n};\n","import { useEffect, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\n\ntype TcreateMesh = {\n   scale: number;\n   max: number;\n   texture?: THREE.Texture;\n   scene: THREE.Scene;\n};\nexport const useMesh = ({ scale, max, texture, scene }: TcreateMesh) => {\n   const meshArr = useRef<THREE.Mesh[]>([]);\n   const geometry = useMemo(\n      () => new THREE.PlaneGeometry(scale, scale),\n      [scale]\n   );\n   const material = useMemo(\n      () =>\n         new THREE.MeshBasicMaterial({\n            map: texture ?? null,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false,\n         }),\n      [texture]\n   );\n   useEffect(() => {\n      for (let i = 0; i < max; i++) {\n         const mesh = new THREE.Mesh(geometry.clone(), material.clone());\n         mesh.rotateZ(2 * Math.PI * Math.random());\n         mesh.visible = false;\n         scene.add(mesh);\n         meshArr.current.push(mesh);\n      }\n   }, [geometry, material, scene, max]);\n   return meshArr.current;\n};\n","import { useCallback, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { usePointer } from \"../../utils/usePointer\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\n\nexport type RippleParams = {\n   /** rippleが出現する頻度,default:0.01 */\n   frequency?: number;\n   /** rippleの回転,default:0.01 */\n   rotation?: number;\n   /** rippleがフェードアウトするスピード,default:0.9 */\n   fadeout_speed?: number;\n   /** rippleの拡大率,default:0.15 */\n   scale?: number;\n   /** rippleの透明度,default:0.6 */\n   alpha?: number;\n};\n\nexport type RippleObject = {\n   scene: THREE.Scene;\n   meshArr: THREE.Mesh[];\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const RIPPLE_PARAMS: RippleParams = {\n   frequency: 0.01,\n   rotation: 0.01,\n   fadeout_speed: 0.9,\n   scale: 0.15,\n   alpha: 0.6,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useRipple = ({\n   texture,\n   scale = 64,\n   max = 100,\n   size,\n}: {\n   /** texture applied to ripple */\n   texture: THREE.Texture;\n   /** ripple size, default:64 */\n   scale?: number;\n   /** ripple max length, default:100 */\n   max?: number;\n   size: Size;\n}): HooksReturn<RippleParams, RippleObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const meshArr = useMesh({\n      scale: scale,\n      max: max,\n      texture,\n      scene,\n   });\n   const camera = useCamera(size);\n   const updatePointer = usePointer();\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n   });\n\n   const [params, setParams] = useParams<RippleParams>(RIPPLE_PARAMS);\n\n   const currentWave = useRef(0);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: RippleParams) => {\n         const { gl, pointer, size } = props;\n\n         updateParams && setParams(updateParams);\n\n         const { currentPointer, diffPointer } = updatePointer(pointer);\n         if (params.frequency! < diffPointer.length()) {\n            const mesh = meshArr[currentWave.current];\n            mesh.visible = true;\n            mesh.position.set(\n               currentPointer.x * (size.width / 2),\n               currentPointer.y * (size.height / 2),\n               0\n            );\n            mesh.scale.x = mesh.scale.y = 0.0;\n            (mesh.material as THREE.MeshBasicMaterial).opacity = params.alpha!;\n            currentWave.current = (currentWave.current + 1) % max;\n         }\n         meshArr.forEach((mesh) => {\n            if (mesh.visible) {\n               const material = mesh.material as THREE.MeshBasicMaterial;\n               mesh.rotation.z += params.rotation!;\n               material.opacity *= params.fadeout_speed!;\n               mesh.scale.x =\n                  params.fadeout_speed! * mesh.scale.x + params.scale!;\n               mesh.scale.y = mesh.scale.x;\n               if (material.opacity < 0.002) mesh.visible = false;\n            }\n         });\n\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, meshArr, updatePointer, max, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         camera: camera,\n         meshArr: meshArr,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\nuniform vec2 uResolution;\nuniform vec2 uImageResolution;\n\nuniform sampler2D uTexture0;\nuniform sampler2D uTexture1;\nuniform sampler2D uNoiseMap;\nuniform float noiseStrength;\nuniform float progress;\nuniform float dirX;\nuniform float dirY;\n\nvoid main() {\n\tvec2 bgRatio=vec2(\n\t\tmin((uResolution.x/uResolution.y)/(uImageResolution.x/uImageResolution.y),1.),\n\t\tmin((uResolution.y/uResolution.x)/(uImageResolution.y/uImageResolution.x),1.)\n\t);\n\tvec2 uv=vec2(\n\t\tvUv.x*bgRatio.x+(1.-bgRatio.x)*.5,\n\t\tvUv.y*bgRatio.y+(1.-bgRatio.y)*.5\n\t);\n\n\t// noise\n\tvec2 noiseMap = texture2D(uNoiseMap, uv).rg;\n\tnoiseMap=noiseMap*2.0-1.0;\n\tuv += noiseMap * noiseStrength;\n\n\t// uvをセンター基準に\n\tvec2 centeredUV = uv - vec2(0.5);\n\t\n\t//texture 0\n\tfloat xOffsetTexture0 = 0.5 - dirX * progress;\n\tfloat yOffsetTexture0 = 0.5 - dirY * progress;\n\tvec2 samplePosTexture0 = vec2(xOffsetTexture0, yOffsetTexture0) + centeredUV;\n\n\t//texture 1\n\tfloat xOffsetTexture1 = 0.5 + dirX * (1.0 - progress);\n\tfloat yOffsetTexture1 = 0.5 + dirY * (1.0 - progress);\n\tvec2 samplePosTexture1 = vec2(xOffsetTexture1, yOffsetTexture1) + centeredUV;\n\n\tvec4 color0 = texture2D(uTexture0, samplePosTexture0);\n\tvec4 color1 = texture2D(uTexture1, samplePosTexture1);\n\n\tgl_FragColor = mix(color0, color1, progress);\n\n}","import { useEffect, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useResolution } from \"../../utils/useResolution\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\nimport { Size } from \"@react-three/fiber\";\n\ntype TUniforms = {\n   uResolution: { value: THREE.Vector2 };\n   uImageResolution: { value: THREE.Vector2 };\n   uTexture0: { value: THREE.Texture };\n   uTexture1: { value: THREE.Texture };\n   uNoiseMap: { value: THREE.Texture };\n   noiseStrength: { value: number };\n   progress: { value: number };\n   dirX: { value: number };\n   dirY: { value: number };\n};\n\nexport class TransitionBgMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = ({\n   scene,\n   size,\n   dpr,\n}: {\n   scene: THREE.Scene;\n   size: Size;\n   dpr: number;\n}) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uResolution: { value: new THREE.Vector2() },\n               uImageResolution: { value: new THREE.Vector2() },\n               uTexture0: { value: new THREE.Texture() },\n               uTexture1: { value: new THREE.Texture() },\n               uNoiseMap: { value: new THREE.Texture() },\n               noiseStrength: { value: 0.0 },\n               progress: { value: 0.0 },\n               dirX: { value: 0.0 },\n               dirY: { value: 0.0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n\n   const resolution = useResolution(size, dpr);\n   useEffect(() => {\n      material.uniforms.uResolution.value = resolution.clone();\n   }, [resolution, material]);\n\n   useAddMesh(scene, geometry, material);\n\n   return material as TransitionBgMaterial;\n};\n","import * as THREE from \"three\";\nimport { useCallback, useMemo } from \"react\";\nimport { useMesh } from \"./useMesh\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { HooksReturn } from \"../types\";\nimport { useParams } from \"../../utils/useParams\";\n\nexport type TransitionBgParams = {\n   /** 0番目のtexture , default:THREE.Texture() */\n   texture0?: THREE.Texture;\n   /** 1番目のtexture , default:THREE.Texture() */\n   texture1?: THREE.Texture;\n   /** 画像の比率 , default:THREE.Vector2(0, 0) */\n   imageResolution?: THREE.Vector2;\n   /** transitionする際に乗算するnoise texture. useNoiseでもいいけど、画像として書き出したnoise textureでも可 , default:THREE.Texture() */\n   uNoiseMap?: THREE.Texture;\n   /** noiseの強さ , default:0.0 */\n   noiseStrength?: number;\n   /** texture0とtexture1を切り替えるスイッチ値 */\n   progress?: number;\n   /** transitionする方向 , default: THREE.Vector2(0, 0) */\n   dir?: THREE.Vector2;\n};\n\nexport type TransitionBgObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const TRANSITIONBG_PARAMS: TransitionBgParams = {\n   texture0: new THREE.Texture(),\n   texture1: new THREE.Texture(),\n   imageResolution: new THREE.Vector2(0, 0),\n   uNoiseMap: new THREE.Texture(),\n   noiseStrength: 0.0,\n   progress: 0.0,\n   dir: new THREE.Vector2(0, 0),\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useTransitionBg = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<TransitionBgParams, TransitionBgObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh({ scene, size, dpr });\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      dpr,\n      size,\n      isSizeUpdate: true,\n   });\n\n   const [params, setParams] =\n      useParams<TransitionBgParams>(TRANSITIONBG_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: TransitionBgParams) => {\n         const { gl } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"uTexture0\", params.texture0!);\n         setUniform(material, \"uTexture1\", params.texture1!);\n         setUniform(material, \"uImageResolution\", params.imageResolution!);\n         setUniform(material, \"uNoiseMap\", params.uNoiseMap!);\n         setUniform(material, \"noiseStrength\", params.noiseStrength!);\n         setUniform(material, \"progress\", params.progress!);\n         setUniform(material, \"dirX\", params.dir!.x);\n         setUniform(material, \"dirY\", params.dir!.y);\n\n         const bufferTexture = updateRenderTarget(gl);\n         return bufferTexture;\n      },\n      [updateRenderTarget, material, params, setParams]\n   );\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n","varying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position, 1.0);\n}","precision mediump float;\n\nvarying vec2 vUv;\n\nuniform float uTime;\nuniform float timeStrength;\nuniform int noiseOctaves;\nuniform int fbmOctaves;\n\nconst float per  = 0.5;\nconst float PI   = 3.1415926;\n\nfloat interpolate(float a, float b, float x){\n    float f = (1.0 - cos(x * PI)) * 0.5;\n    return a * (1.0 - f) + b * f;\n}\n\nfloat rnd(vec2 p){\n    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat irnd(vec2 p){\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tvec4 v = vec4(rnd(vec2(i.x,i.y)),rnd(vec2(i.x + 1.0,i.y)),rnd(vec2(i.x,i.y + 1.0)),rnd(vec2(i.x + 1.0, i.y + 1.0)));\n\treturn interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);\n}\n\nfloat noise(vec2 p, float time){\n\tfloat t = 0.0;\n\tfor(int i = 0; i < noiseOctaves; i++){\n\t\tfloat freq = pow(2.0, float(i));\n\t\tfloat amp  = pow(per, float(noiseOctaves - i));\n\t\tt += irnd(vec2(p.y / freq + time, p.x / freq + time)) * amp;\n\t}\n\treturn t;\n}\n\nfloat fbm(vec2 x, float time) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\tmat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfloat sign = 1.0;\n\tfor (int i = 0; i < fbmOctaves; ++i) {\n\t\tv += a * noise(x, time * sign);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t\tsign *= -1.0;\n\t}\n\treturn v;\n}\n\nvoid main() {\n\tvec2 uv = vUv;\n\tfloat noiseMap = fbm(gl_FragCoord.xy ,uTime * timeStrength);\n\tgl_FragColor = vec4(noiseMap,noiseMap,noiseMap,1.0);\n}\n\n","import { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport vertexShader from \"./shader/main.vert\";\nimport fragmentShader from \"./shader/main.frag\";\nimport { useAddMesh } from \"../../utils/useAddMesh\";\n\ntype TUniforms = {\n   uTime: { value: number };\n   timeStrength: { value: number };\n   noiseOctaves: { value: number };\n   fbmOctaves: { value: number };\n};\n\nexport class NoiseMaterial extends THREE.ShaderMaterial {\n   uniforms!: TUniforms;\n}\n\nexport const useMesh = (scene: THREE.Scene) => {\n   const geometry = useMemo(() => new THREE.PlaneGeometry(2, 2), []);\n   const material = useMemo(\n      () =>\n         new THREE.ShaderMaterial({\n            uniforms: {\n               uTime: { value: 0.0 },\n               timeStrength: { value: 0.0 },\n               noiseOctaves: { value: 0 },\n               fbmOctaves: { value: 0 },\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader,\n         }),\n      []\n   );\n   useAddMesh(scene, geometry, material);\n   return material as NoiseMaterial;\n};\n","import { useCallback, useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { useMesh } from \"./useMesh\";\nimport { RootState, Size } from \"@react-three/fiber\";\nimport { useCamera } from \"../../utils/useCamera\";\nimport { useSingleFBO } from \"../../utils/useSingleFBO\";\nimport { setUniform } from \"../../utils/setUniforms\";\nimport { useParams } from \"../../utils/useParams\";\nimport { HooksReturn } from \"../types\";\n\nexport type NoiseParams = {\n   /** 時間係数 default:0.3 */\n   timeStrength?: number;\n   /** noiseの振幅回数 default:8 */\n   noiseOctaves?: number;\n   /** fbmの振幅回数 default:3 */\n   fbmOctaves?: number;\n};\n\nexport type NoiseObject = {\n   scene: THREE.Scene;\n   material: THREE.Material;\n   camera: THREE.Camera;\n   renderTarget: THREE.WebGLRenderTarget;\n};\n\nexport const NOISE_PARAMS: NoiseParams = {\n   timeStrength: 0.3,\n   noiseOctaves: 8,\n   fbmOctaves: 3,\n};\n\n/**\n * @link https://github.com/takuma-hmng8/use-shader-fx#usage\n */\nexport const useNoise = ({\n   size,\n   dpr,\n}: {\n   size: Size;\n   dpr: number;\n}): HooksReturn<NoiseParams, NoiseObject> => {\n   const scene = useMemo(() => new THREE.Scene(), []);\n   const material = useMesh(scene);\n   const camera = useCamera(size);\n   const [renderTarget, updateRenderTarget] = useSingleFBO({\n      scene,\n      camera,\n      size,\n      dpr,\n   });\n\n   const [params, setParams] = useParams<NoiseParams>(NOISE_PARAMS);\n\n   const updateFx = useCallback(\n      (props: RootState, updateParams?: NoiseParams) => {\n         const { gl, clock } = props;\n\n         updateParams && setParams(updateParams);\n\n         setUniform(material, \"timeStrength\", params.timeStrength!);\n         setUniform(material, \"noiseOctaves\", params.noiseOctaves!);\n         setUniform(material, \"fbmOctaves\", params.fbmOctaves!);\n\n         setUniform(material, \"uTime\", clock.getElapsedTime());\n\n         return updateRenderTarget(gl);\n      },\n      [updateRenderTarget, material, setParams, params]\n   );\n\n   return [\n      updateFx,\n      setParams,\n      {\n         scene: scene,\n         material: material,\n         camera: camera,\n         renderTarget: renderTarget,\n      },\n   ];\n};\n"],"names":["main_default","useResolution","size","dpr","_width","_height","useMemo","THREE","useAddMesh","scene","geometry","material","mesh","useEffect","setUniform","key","value","useMesh","vertexShader","fragmentShader","resolution","getCameraProps","width","height","frustumSize","aspect","w","h","useCamera","near","far","FBO_OPTION","useSingleFBO","camera","isSizeUpdate","renderTarget","useRef","useLayoutEffect","_a","updateRenderTarget","useCallback","gl","onBeforeRender","fbo","useDoubleFBO","temp","initRenderTargets","read","write","_b","usePointer","prevPointer","diffPointer","lastUpdateTime","velocity","isMoved","currentPointer","now","current","deltaTime","isUpdate","prevTemp","useParams","params","paramsRef","setParams","updateParams","paramKey","BRUSH_PARAMS","useBrush","updatePointer","props","pointer","DUOTONE_PARAMS","useDuoTone","FLOWMAP_PARAMS","useFlowmap","FOGPROJECTION_PARAMS","useFogProjection","clock","init_default","useInitialMaterial","advection_default","useAdvectionMaterial","divergence_default","useDivergenceMaterial","pressure_default","usePressureMaterial","curl_default","useCurlMaterial","vorticity_default","useVorticityMaterial","clear_default","useClearMaterial","gradientSubtract_default","useGradientSubtractMaterial","splat_default","useSplateMaterial","initialMaterial","updateMaterial","curlMaterial","vorticityMaterial","advectionMaterial","divergenceMaterial","pressureMaterial","clearMaterial","gradientSubtractMaterial","splatMaterial","materials","setMeshMaterial","FRUID_PARAMS","useFruid","fboProps","velocityFBO","updateVelocityFBO","densityFBO","updateDensityFBO","curlFBO","updateCurlFBO","divergenceFBO","updateDivergenceFBO","pressureFBO","updatePressureFBO","lastTime","scaledDiffVec","spaltVec","dt","velocityTex","densityTex","isVelocityUpdate","scaledDiff","color","curlTex","divergenceTex","pressureTexTemp","i","scale","max","texture","meshArr","RIPPLE_PARAMS","useRipple","currentWave","TRANSITIONBG_PARAMS","useTransitionBg","NOISE_PARAMS","useNoise"],"mappings":";;AAAA,IAAAA,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ICAAA,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACOO,MAAMC,IAAgB,CAACC,GAAYC,IAAsB,OAAU;AACvE,QAAMC,IAASD,IAAMD,EAAK,QAAQC,IAAMD,EAAK,OACvCG,IAAUF,IAAMD,EAAK,SAASC,IAAMD,EAAK;AAKxC,SAJYI;AAAA,IAChB,MAAM,IAAIC,EAAM,QAAQH,GAAQC,CAAO;AAAA,IACvC,CAACD,GAAQC,CAAO;AAAA,EAAA;AAGtB,GCZaG,IAAa,CACvBC,GACAC,GACAC,MACE;AACF,QAAMC,IAAON;AAAA,IACV,MAAM,IAAIC,EAAM,KAAKG,GAAUC,CAAQ;AAAA,IACvC,CAACD,GAAUC,CAAQ;AAAA,EAAA;AAEtB,SAAAE,EAAU,MAAM;AACb,IAAAJ,EAAM,IAAIG,CAAI;AAAA,EAAA,GACd,CAACH,GAAOG,CAAI,CAAC,GACTA;AACV,GCEaE,IAAa,CACvBH,GACAI,GACAC,MACE;AAEC,EAAAL,EAAS,YACTA,EAAS,SAASI,CAAG,KACrBC,MAAU,UACVA,MAAU,OAEDL,EAAA,SAASI,CAAG,EAAE,QAAQC,IAEvB,QAAA;AAAA,IACL,gBAAgB;AAAA,MACbD;AAAA,IACF,CAAA,yCAAyC;AAAA,MACvCA;AAAA,IACF,CAAA;AAAA,EAAA;AAGV,GCVaE,KAAU,CAAC;AAAA,EACrB,OAAAR;AAAA,EACA,MAAAP;AAAA,EACA,KAAAC;AACH,MAIM;AACG,QAAAO,IAAWJ,EAAQ,MAAM,IAAIC,EAAM,cAAc,GAAG,CAAC,GAAG,CAAA,CAAE,GAC1DI,IAAWL;AAAA,IACd,MACG,IAAIC,EAAM,eAAe;AAAA,MACtB,UAAU;AAAA,QACP,MAAM,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,QACnC,aAAa,EAAE,OAAO,IAAIA,EAAM,QAAQ,GAAG,CAAC,EAAE;AAAA,QAC9C,SAAS,EAAE,OAAO,EAAI;AAAA,QACtB,UAAU,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,QACvC,SAAS,EAAE,OAAO,EAAI;AAAA,QACtB,SAAS,EAAE,OAAO,EAAI;AAAA,QACtB,cAAc,EAAE,OAAO,EAAI;AAAA,QAC3B,aAAa,EAAE,OAAO,EAAI;AAAA,QAC1B,eAAe,EAAE,OAAO,EAAE;AAAA,QAC1B,QAAQ,EAAE,OAAO,IAAIA,EAAM,QAAQ,GAAG,CAAC,EAAE;AAAA,QACzC,YAAY,EAAE,OAAO,IAAIA,EAAM,QAAQ,GAAG,CAAC,EAAE;AAAA,QAC7C,WAAW,EAAE,OAAO,IAAIA,EAAM,QAAQ,GAAG,CAAC,EAAE;AAAA,QAC5C,QAAQ,EAAE,OAAO,IAAIA,EAAM,MAAM,QAAQ,EAAE;AAAA,MAC9C;AAAA,MAAA,cACAW;AAAAA,MAAA,gBACAC;AAAAA,IAAA,CACF;AAAA,IACJ,CAAC;AAAA,EAAA,GAGEC,IAAanB,EAAcC,GAAMC,CAAG;AAC1C,SAAAU,EAAU,MAAM;AACb,IAAAC,EAAWH,GAAU,WAAWS,EAAW,QAAQA,EAAW,MAAM,GACpEN,EAAWH,GAAU,eAAeS,EAAW,MAAO,CAAA;AAAA,EAAA,GACtD,CAACA,GAAYT,CAAQ,CAAC,GAEdH,EAAAC,GAAOC,GAAUC,CAAQ,GAE7BA;AACV,GCnEMU,KAAiB,CAACC,GAAeC,MAAmB;AACvD,QAAMC,IAAcD,GACdE,IAASH,IAAQC,GACjB,CAACG,GAAGC,CAAC,IAAI,CAAEH,IAAcC,IAAU,GAAGD,IAAc,CAAC;AACpD,SAAA,EAAE,OAAOE,GAAG,QAAQC,GAAG,MAAM,MAAO,KAAK;AACnD,GAEaC,IAAY,CAAC1B,MAAe;AAChC,QAAAkB,IAAanB,EAAcC,CAAI,GAC/B,EAAE,OAAAoB,GAAO,QAAAC,GAAQ,MAAAM,GAAM,KAAAC,EAAQ,IAAAT;AAAA,IAClCD,EAAW;AAAA,IACXA,EAAW;AAAA,EAAA;AAcP,SAZQd;AAAA,IACZ,MACG,IAAIC,EAAM;AAAA,MACP,CAACe;AAAA,MACDA;AAAA,MACAC;AAAA,MACA,CAACA;AAAA,MACDM;AAAA,MACAC;AAAA,IACH;AAAA,IACH,CAACR,GAAOC,GAAQM,GAAMC,CAAG;AAAA,EAAA;AAG/B,GC1BaC,IAAa;AAAA,EACvB,WAAWxB,EAAM;AAAA,EACjB,WAAWA,EAAM;AAAA,EACjB,MAAMA,EAAM;AAAA,EACZ,aAAa;AAAA,EACb,eAAe;AAClB,GAeayB,IAAe,CAAC;AAAA,EAC1B,OAAAvB;AAAA,EACA,QAAAwB;AAAA,EACA,MAAA/B;AAAA,EACA,KAAAC,IAAM;AAAA,EACN,cAAA+B,IAAe;AAClB,MAA2B;AACxB,QAAMC,IAAeC,KAEfhB,IAAanB,EAAcC,GAAMC,CAAG;AAC1C,EAAAgC,EAAa,UAAU7B;AAAA,IACpB,MAAM,IAAIC,EAAM,kBAAkBa,EAAW,GAAGA,EAAW,GAAGW,CAAU;AAAA;AAAA,IAExE,CAAC;AAAA,EAAA,GAGJM,EAAgB,MAAM;;AACnB,IAAIH,OACDI,IAAAH,EAAa,YAAb,QAAAG,EAAsB,QAAQlB,EAAW,GAAGA,EAAW;AAAA,EAC1D,GACA,CAACA,GAAYc,CAAY,CAAC;AAE7B,QAAMK,IAAwCC;AAAA,IAC3C,CAACC,GAAIC,MAAmB;AACrB,YAAMC,IAAMR,EAAa;AACzB,aAAAM,EAAG,gBAAgBE,CAAG,GACtBD,KAAkBA,EAAe,EAAE,MAAMC,EAAI,QAAS,CAAA,GACnDF,EAAA,OAAOhC,GAAOwB,CAAM,GACvBQ,EAAG,gBAAgB,IAAI,GACvBA,EAAG,MAAM,GACFE,EAAI;AAAA,IACd;AAAA,IACA,CAAClC,GAAOwB,CAAM;AAAA,EAAA;AAGV,SAAA,CAACE,EAAa,SAASI,CAAkB;AACnD,GCxBaK,IAAe,CAAC;AAAA,EAC1B,OAAAnC;AAAA,EACA,QAAAwB;AAAA,EACA,MAAA/B;AAAA,EACA,KAAAC,IAAM;AAAA,EACN,cAAA+B,IAAe;AAClB,MAA2B;AACxB,QAAMC,IAAeC,EAAqB;AAAA,IACvC,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM,WAAY;AACf,UAAIS,IAAO,KAAK;AAChB,WAAK,OAAO,KAAK,OACjB,KAAK,QAAQA;AAAA,IAChB;AAAA,EAAA,CACF,GAEKzB,IAAanB,EAAcC,GAAMC,CAAG,GACpC2C,IAAoBxC,EAAQ,MAAM;AAC/B,UAAAyC,IAAO,IAAIxC,EAAM;AAAA,MACpBa,EAAW;AAAA,MACXA,EAAW;AAAA,MACXW;AAAA,IAAA,GAEGiB,IAAQ,IAAIzC,EAAM;AAAA,MACrBa,EAAW;AAAA,MACXA,EAAW;AAAA,MACXW;AAAA,IAAA;AAEI,WAAA,EAAE,MAAAgB,GAAM,OAAAC;EAElB,GAAG,CAAE,CAAA;AACQ,EAAAb,EAAA,QAAQ,OAAOW,EAAkB,MACjCX,EAAA,QAAQ,QAAQW,EAAkB,OAE/CT,EAAgB,MAAM;;AACnB,IAAIH,OACDI,IAAAH,EAAa,QAAQ,SAArB,QAAAG,EAA2B,QAAQlB,EAAW,GAAGA,EAAW,KAC5D6B,IAAAd,EAAa,QAAQ,UAArB,QAAAc,EAA4B,QAAQ7B,EAAW,GAAGA,EAAW;AAAA,EAChE,GACA,CAACA,GAAYc,CAAY,CAAC;AAE7B,QAAMK,IAAwCC;AAAA,IAC3C,CAACC,GAAIC,MAAmB;;AACrB,YAAMC,IAAMR,EAAa;AACtB,aAAAM,EAAA,gBAAgBE,EAAI,KAAK,GAC5BD,KACGA,EAAe;AAAA,QACZ,MAAMC,EAAI,KAAM;AAAA,QAChB,OAAOA,EAAI,MAAO;AAAA,MAAA,CACpB,GACDF,EAAA,OAAOhC,GAAOwB,CAAM,GACvBU,EAAI,KAAK,GACTF,EAAG,gBAAgB,IAAI,GACvBA,EAAG,MAAM,IACFH,IAAAK,EAAI,SAAJ,gBAAAL,EAAU;AAAA,IACpB;AAAA,IACA,CAAC7B,GAAOwB,CAAM;AAAA,EAAA;AAGV,SAAA;AAAA,IACJ,EAAE,MAAME,EAAa,QAAQ,MAAM,OAAOA,EAAa,QAAQ,MAAM;AAAA,IACrEI;AAAA,EAAA;AAEN,GC3FaW,IAAa,MAAqB;AAC5C,QAAMC,IAAcf,EAAO,IAAI7B,EAAM,QAAQ,GAAG,CAAC,CAAC,GAC5C6C,IAAchB,EAAO,IAAI7B,EAAM,QAAQ,GAAG,CAAC,CAAC,GAC5C8C,IAAiBjB,EAAe,CAAC,GACjCkB,IAAWlB,EAAO,IAAI7B,EAAM,QAAQ,GAAG,CAAC,CAAC,GACzCgD,IAAUnB,EAAO,EAAK;AAqCrB,SAnCeI,EAAY,CAACgB,MAAkC;AAC5D,UAAAC,IAAM,YAAY,OAClBC,IAAUF,EAAe;AAG3B,IAAAH,EAAe,YAAY,MAC5BA,EAAe,UAAUI,GACzBN,EAAY,UAAUO;AAEzB,UAAMC,IAAY,KAAK,IAAI,GAAGF,IAAMJ,EAAe,OAAO;AAC1D,IAAAA,EAAe,UAAUI,GAGhBH,EAAA,QACL,KAAKI,CAAO,EACZ,IAAIP,EAAY,OAAO,EACvB,aAAaQ,CAAS;AAC1B,UAAMC,IAAWN,EAAS,QAAQ,OAAA,IAAW,GAGvCO,IAAWN,EAAQ,UAAUJ,EAAY,QAAQ,MAAU,IAAAO;AAC7D,WAAA,CAACH,EAAQ,WAAWK,MACrBL,EAAQ,UAAU,KAErBJ,EAAY,UAAUO,GAEf;AAAA,MACJ,gBAAgBA;AAAA,MAChB,aAAaG;AAAA,MACb,aAAaT,EAAY,QAAQ,WAAWM,GAASG,CAAQ;AAAA,MAC7D,UAAUP,EAAS;AAAA,MACnB,kBAAkBM;AAAA,IAAA;AAAA,EAExB,GAAG,CAAE,CAAA;AAGR,GClDaE,IAAY,CAAmBC,MAAyB;AAC5D,QAAAC,IAAY5B,EAAO2B,CAAM,GACzBE,IAAYzB,EAAY,CAAC0B,MAA6B;AACzD,eAAWnD,KAAOmD,GAAc;AAC7B,YAAMC,IAAWpD;AAEd,MAAAoD,KAAYH,EAAU,WACtBE,EAAaC,CAAQ,MAAM,UAC3BD,EAAaC,CAAQ,MAAM,OAE3BH,EAAU,QAAQG,CAAQ,IAAID,EAAaC,CAAQ,IAE3C,QAAA;AAAA,QACL,IAAI;AAAA,UACDA;AAAA,QACF,CAAA,uCAAuC;AAAA,UACrCA;AAAA,QACF,CAAA;AAAA,MAAA;AAAA,IAGV;AAAA,EACH,GAAG,CAAE,CAAA;AACE,SAAA,CAACH,EAAU,SAASC,CAAS;AACvC,GCSaG,KAA4B;AAAA,EACtC,SAAS,IAAI7D,EAAM,QAAQ;AAAA,EAC3B,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,aAAa;AAAA,EACb,YAAY;AAAA,EACZ,cAAc;AAAA,EACd,OAAO,IAAIA,EAAM,MAAM,QAAQ;AAClC,GAKa8D,KAAW,CAAC;AAAA,EACtB,MAAAnE;AAAA,EACA,KAAAC;AACH,MAG6C;AACpC,QAAAM,IAAQH,EAAQ,MAAM,IAAIC,EAAM,MAAM,GAAG,CAAA,CAAE,GAC3CI,IAAWM,GAAQ,EAAE,OAAAR,GAAO,MAAAP,GAAM,KAAAC,GAAK,GACvC8B,IAASL,EAAU1B,CAAI,GACvBoE,IAAgBpB,KAChB,CAACf,GAAcI,CAAkB,IAAIK,EAAa;AAAA,IACrD,OAAAnC;AAAA,IACA,QAAAwB;AAAA,IACA,MAAA/B;AAAA,EAAA,CACF,GAEK,CAAC6D,GAAQE,CAAS,IAAIH,EAAuBM,EAAY;AA+BxD,SAAA;AAAA,IA7BU5B;AAAA,MACd,CAAC+B,GAAkBL,MAA+B;AACzC,cAAA,EAAE,IAAAzB,GAAI,SAAA+B,EAAY,IAAAD;AAExB,QAAAL,KAAgBD,EAAUC,CAAY,GAE3BpD,EAAAH,GAAU,YAAYoD,EAAO,OAAQ,GACrCjD,EAAAH,GAAU,WAAWoD,EAAO,MAAO,GACnCjD,EAAAH,GAAU,WAAWoD,EAAO,MAAO,GACnCjD,EAAAH,GAAU,gBAAgBoD,EAAO,WAAY,GAC7CjD,EAAAH,GAAU,eAAeoD,EAAO,UAAW,GAC3CjD,EAAAH,GAAU,iBAAiBoD,EAAO,YAAa,GAC/CjD,EAAAH,GAAU,UAAUoD,EAAO,KAAM;AAE5C,cAAM,EAAE,gBAAAP,GAAgB,aAAAL,GAAa,UAAAG,EAAS,IAC3CgB,EAAcE,CAAO;AACb,eAAA1D,EAAAH,GAAU,UAAU6C,CAAc,GAClC1C,EAAAH,GAAU,cAAcwC,CAAW,GACnCrC,EAAAH,GAAU,aAAa2C,CAAQ,GAEpBf,EAAmBE,GAAI,CAAC,EAAE,MAAAM,QAAW;AAC7C,UAAAjC,EAAAH,GAAU,QAAQoC,CAAI;AAAA,QAAA,CACnC;AAAA,MAGJ;AAAA,MACA,CAACpC,GAAU2D,GAAe/B,GAAoBwB,GAAQE,CAAS;AAAA,IAAA;AAAA,IAK/DA;AAAA,IACA;AAAA,MACG,OAAAxD;AAAA,MACA,UAAAE;AAAA,MACA,QAAAsB;AAAA,MACA,cAAAE;AAAA,IACH;AAAA,EAAA;AAEN;AC3GA,IAAAnC,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ICAAA,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACgBa,MAAAiB,KAAU,CAACR,MAAuB;AACtC,QAAAC,IAAWJ,EAAQ,MAAM,IAAIC,EAAM,cAAc,GAAG,CAAC,GAAG,CAAA,CAAE,GAC1DI,IAAWL;AAAA,IACd,MACG,IAAIC,EAAM,eAAe;AAAA,MACtB,UAAU;AAAA,QACP,UAAU,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,QACvC,SAAS,EAAE,OAAO,IAAIA,EAAM,MAAM,QAAQ,EAAE;AAAA,QAC5C,SAAS,EAAE,OAAO,IAAIA,EAAM,MAAM,CAAQ,EAAE;AAAA,MAC/C;AAAA,MAAA,cACAW;AAAAA,MAAA,gBACAC;AAAAA,IAAA,CACF;AAAA,IACJ,CAAC;AAAA,EAAA;AAEO,SAAAX,EAAAC,GAAOC,GAAUC,CAAQ,GAC7BA;AACV,GCPa8D,KAAgC;AAAA,EAC1C,SAAS,IAAIlE,EAAM,QAAQ;AAAA,EAC3B,QAAQ,IAAIA,EAAM,MAAM,QAAQ;AAAA,EAChC,QAAQ,IAAIA,EAAM,MAAM,CAAQ;AACnC,GAKamE,KAAa,CAAC;AAAA,EACxB,MAAAxE;AACH,MAEiD;AACxC,QAAAO,IAAQH,EAAQ,MAAM,IAAIC,EAAM,MAAM,GAAG,CAAA,CAAE,GAC3CI,IAAWM,GAAQR,CAAK,GACxBwB,IAASL,EAAU1B,CAAI,GACvB,CAACiC,GAAcI,CAAkB,IAAIP,EAAa;AAAA,IACrD,OAAAvB;AAAA,IACA,QAAAwB;AAAA,IACA,MAAA/B;AAAA,EAAA,CACF,GAEK,CAAC6D,GAAQE,CAAS,IAAIH,EAAyBW,EAAc;AAmB5D,SAAA;AAAA,IAjBUjC;AAAA,MACd,CAAC+B,GAAkBL,MAAiC;AAC3C,cAAA,EAAE,IAAAzB,EAAO,IAAA8B;AAEf,eAAAL,KAAgBD,EAAUC,CAAY,GAE3BpD,EAAAH,GAAU,YAAYoD,EAAO,OAAQ,GACrCjD,EAAAH,GAAU,WAAWoD,EAAO,MAAO,GACnCjD,EAAAH,GAAU,WAAWoD,EAAO,MAAO,GAExBxB,EAAmBE,CAAE;AAAA,MAG9C;AAAA,MACA,CAACF,GAAoB5B,GAAUsD,GAAWF,CAAM;AAAA,IAAA;AAAA,IAKhDE;AAAA,IACA;AAAA,MACG,OAAAxD;AAAA,MACA,UAAAE;AAAA,MACA,QAAAsB;AAAA,MACA,cAAAE;AAAA,IACH;AAAA,EAAA;AAEN;AC9EA,IAAAnC,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ICAAA,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACSO,MAAMiB,KAAU,CAAC;AAAA,EACrB,OAAAR;AAAA,EACA,MAAAP;AAAA,EACA,KAAAC;AACH,MAIM;AACG,QAAAO,IAAWJ,EAAQ,MAAM,IAAIC,EAAM,cAAc,GAAG,CAAC,GAAG,CAAA,CAAE,GAC1DI,IAAWL;AAAA,IACd,MACG,IAAIC,EAAM,eAAe;AAAA,MACtB,UAAU;AAAA,QACP,MAAM,EAAE,OAAO,KAAK;AAAA,QACpB,aAAa,EAAE,OAAO,IAAIA,EAAM,QAAQ,GAAG,CAAC,EAAE;AAAA,QAC9C,SAAS,EAAE,OAAO,EAAE;AAAA,QACpB,SAAS,EAAE,OAAO,EAAI;AAAA,QACtB,QAAQ,EAAE,OAAO,EAAI;AAAA,QACrB,cAAc,EAAE,OAAO,EAAI;AAAA,QAC3B,gBAAgB,EAAE,OAAO,EAAI;AAAA,QAC7B,QAAQ,EAAE,OAAO,IAAIA,EAAM,QAAQ,GAAG,CAAC,EAAE;AAAA,QACzC,WAAW,EAAE,OAAO,IAAIA,EAAM,QAAQ,GAAG,CAAC,EAAE;AAAA,MAC/C;AAAA,MAAA,cACAW;AAAAA,MAAA,gBACAC;AAAAA,IAAA,CACF;AAAA,IACJ,CAAC;AAAA,EAAA,GAGEC,IAAanB,EAAcC,GAAMC,CAAG;AAE1C,SAAAU,EAAU,MAAM;AACb,IAAAC,EAAWH,GAAU,WAAWS,EAAW,QAAQA,EAAW,MAAM,GACpEN,EAAWH,GAAU,eAAeS,EAAW,MAAO,CAAA;AAAA,EAAA,GACtD,CAACA,GAAYT,CAAQ,CAAC,GAEdH,EAAAC,GAAOC,GAAUC,CAAQ,GAE7BA;AACV,GCnBagE,KAAgC;AAAA,EAC1C,QAAQ;AAAA,EACR,eAAe;AAAA,EACf,OAAO;AAAA,EACP,aAAa;AAChB,GAKaC,KAAa,CAAC;AAAA,EACxB,MAAA1E;AAAA,EACA,KAAAC;AACH,MAGiD;AACxC,QAAAM,IAAQH,EAAQ,MAAM,IAAIC,EAAM,MAAM,GAAG,CAAA,CAAE,GAC3CI,IAAWM,GAAQ,EAAE,OAAAR,GAAO,MAAAP,GAAM,KAAAC,GAAK,GACvC8B,IAASL,EAAU1B,CAAI,GACvBoE,IAAgBpB,KAChB,CAACf,GAAcI,CAAkB,IAAIK,EAAa;AAAA,IACrD,OAAAnC;AAAA,IACA,QAAAwB;AAAA,IACA,MAAA/B;AAAA,EAAA,CACF,GAEK,CAAC6D,GAAQE,CAAS,IAAIH,EAAyBa,EAAc;AAyB5D,SAAA;AAAA,IAvBUnC;AAAA,MACd,CAAC+B,GAAkBL,MAAiC;AAC3C,cAAA,EAAE,IAAAzB,GAAI,SAAA+B,EAAY,IAAAD;AAExB,QAAAL,KAAgBD,EAAUC,CAAY,GAE3BpD,EAAAH,GAAU,WAAWoD,EAAO,MAAO,GACnCjD,EAAAH,GAAU,UAAUoD,EAAO,KAAM,GACjCjD,EAAAH,GAAU,gBAAgBoD,EAAO,WAAY,GAC7CjD,EAAAH,GAAU,kBAAkBoD,EAAO,aAAc;AAE5D,cAAM,EAAE,gBAAAP,GAAgB,UAAAF,EAAS,IAAIgB,EAAcE,CAAO;AAC/C,eAAA1D,EAAAH,GAAU,UAAU6C,CAAc,GAClC1C,EAAAH,GAAU,aAAa2C,CAAQ,GAEpBf,EAAmBE,GAAI,CAAC,EAAE,MAAAM,QAAW;AAC7C,UAAAjC,EAAAH,GAAU,QAAQoC,CAAI;AAAA,QAAA,CACnC;AAAA,MAGJ;AAAA,MACA,CAACpC,GAAU2D,GAAe/B,GAAoBwB,GAAQE,CAAS;AAAA,IAAA;AAAA,IAI/DA;AAAA,IACA;AAAA,MACG,OAAAxD;AAAA,MACA,UAAAE;AAAA,MACA,QAAAsB;AAAA,MACA,cAAAE;AAAA,IACH;AAAA,EAAA;AAEN;AC5FA,IAAAnC,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ICAAA,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACoBa,MAAAiB,KAAU,CAACR,MAAuB;AACtC,QAAAC,IAAWJ,EAAQ,MAAM,IAAIC,EAAM,cAAc,GAAG,CAAC,GAAG,CAAA,CAAE,GAC1DI,IAAWL;AAAA,IACd,MACG,IAAIC,EAAM,eAAe;AAAA,MACtB,UAAU;AAAA,QACP,OAAO,EAAE,OAAO,EAAI;AAAA,QACpB,UAAU,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,QACvC,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,QACxC,oBAAoB,EAAE,OAAO,EAAI;AAAA,QACjC,UAAU,EAAE,OAAO,EAAI;AAAA,QACvB,UAAU,EAAE,OAAO,IAAI;AAAA,QACvB,UAAU,EAAE,OAAO,IAAIA,EAAM,MAAM,QAAQ,EAAE;AAAA,MAChD;AAAA,MAAA,cACAW;AAAAA,MAAA,gBACAC;AAAAA,IAAA,CACF;AAAA,IACJ,CAAC;AAAA,EAAA;AAEO,SAAAX,EAAAC,GAAOC,GAAUC,CAAQ,GAC7BA;AACV,GCTakE,KAA4C;AAAA,EACtD,SAAS,IAAItE,EAAM,QAAQ;AAAA,EAC3B,UAAU,IAAIA,EAAM,QAAQ;AAAA,EAC5B,oBAAoB;AAAA,EACpB,UAAU;AAAA,EACV,UAAU;AAAA,EACV,UAAU,IAAIA,EAAM,MAAM,QAAQ;AACrC,GAKauE,KAAmB,CAAC;AAAA,EAC9B,MAAA5E;AACH,MAE6D;AACpD,QAAAO,IAAQH,EAAQ,MAAM,IAAIC,EAAM,MAAM,GAAG,CAAA,CAAE,GAC3CI,IAAWM,GAAQR,CAAK,GACxBwB,IAASL,EAAU1B,CAAI,GACvB,CAACiC,GAAcI,CAAkB,IAAIP,EAAa;AAAA,IACrD,OAAAvB;AAAA,IACA,QAAAwB;AAAA,IACA,MAAA/B;AAAA,EAAA,CACF,GAEK,CAAC6D,GAAQE,CAAS,IACrBH,EAA+Be,EAAoB;AAmB/C,SAAA;AAAA,IAjBUrC;AAAA,MACd,CAAC+B,GAAkBL,MAAuC;AACjD,cAAA,EAAE,IAAAzB,GAAI,OAAAsC,EAAU,IAAAR;AACtB,eAAAL,KAAgBD,EAAUC,CAAY,GACtCpD,EAAWH,GAAU,SAASoE,EAAM,eAAgB,CAAA,GACzCjE,EAAAH,GAAU,YAAYoD,EAAO,OAAQ,GACrCjD,EAAAH,GAAU,aAAaoD,EAAO,QAAS,GACvCjD,EAAAH,GAAU,sBAAsBoD,EAAO,kBAAmB,GAC1DjD,EAAAH,GAAU,YAAYoD,EAAO,QAAS,GACtCjD,EAAAH,GAAU,YAAYoD,EAAO,QAAS,GACtCjD,EAAAH,GAAU,YAAYoD,EAAO,QAAS,GAC3BxB,EAAmBE,CAAE;AAAA,MAE9C;AAAA,MACA,CAACF,GAAoB5B,GAAUsD,GAAWF,CAAM;AAAA,IAAA;AAAA,IAKhDE;AAAA,IACA;AAAA,MACG,OAAAxD;AAAA,MACA,UAAAE;AAAA,MACA,QAAAsB;AAAA,MACA,cAAAE;AAAA,IACH;AAAA,EAAA;AAEN;ACxFA,IAAAnC,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ICAAgF,KAAA;AAAA;AAAA;AAAA;AAAA;ACKO,MAAMC,KAAqB,MACP3E;AAAA,EACrB,MACG,IAAIC,EAAM,eAAe;AAAA,IAAA,cACtBW;AAAAA,IAAA,gBACAC;AAAAA,IACA,WAAW;AAAA,IACX,YAAY;AAAA,EAAA,CACd;AAAA,EACJ,CAAC;AAAA;ACdP,IAAA+D,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACiBO,MAAMC,KAAuB,MACP7E;AAAA,EACvB,MACG,IAAIC,EAAM,eAAe;AAAA,IACtB,UAAU;AAAA,MACP,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,MACxC,SAAS,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,MACtC,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,MACxC,IAAI,EAAE,OAAO,EAAI;AAAA,MACjB,aAAa,EAAE,OAAO,EAAI;AAAA,IAC7B;AAAA,IAAA,cACAW;AAAAA,IAAA,gBACAC;AAAAA,EAAA,CACF;AAAA,EACJ,CAAC;AAAA;AC/BP,IAAAiE,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACcO,MAAMC,KAAwB,MACP/E;AAAA,EACxB,MACG,IAAIC,EAAM,eAAe;AAAA,IACtB,UAAU;AAAA,MACP,WAAW,EAAE,OAAO,KAAK;AAAA,MACzB,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,IAC3C;AAAA,IAAA,cACAW;AAAAA,IAAA,gBACAC;AAAAA,EAAA,CACF;AAAA,EACJ,CAAC;AAAA;ACzBP,IAAAmE,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACeO,MAAMC,KAAsB,MACPjF;AAAA,EACtB,MACG,IAAIC,EAAM,eAAe;AAAA,IACtB,UAAU;AAAA,MACP,WAAW,EAAE,OAAO,KAAK;AAAA,MACzB,aAAa,EAAE,OAAO,KAAK;AAAA,MAC3B,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,IAC3C;AAAA,IAAA,cACAW;AAAAA,IAAA,gBACAC;AAAAA,EAAA,CACF;AAAA,EACJ,CAAC;AAAA;AC3BP,IAAAqE,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACcO,MAAMC,KAAkB,MACPnF;AAAA,EAClB,MACG,IAAIC,EAAM,eAAe;AAAA,IACtB,UAAU;AAAA,MACP,WAAW,EAAE,OAAO,KAAK;AAAA,MACzB,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,IAC3C;AAAA,IAAA,cACAW;AAAAA,IAAA,gBACAC;AAAAA,EAAA,CACF;AAAA,EACJ,CAAC;AAAA;ACzBP,IAAAuE,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACiBO,MAAMC,KAAuB,MACPrF;AAAA,EACvB,MACG,IAAIC,EAAM,eAAe;AAAA,IACtB,UAAU;AAAA,MACP,WAAW,EAAE,OAAO,KAAK;AAAA,MACzB,OAAO,EAAE,OAAO,KAAK;AAAA,MACrB,MAAM,EAAE,OAAO,EAAE;AAAA,MACjB,IAAI,EAAE,OAAO,EAAE;AAAA,MACf,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,IAC3C;AAAA,IAAA,cACAW;AAAAA,IAAA,gBACAC;AAAAA,EAAA,CACF;AAAA,EACJ,CAAC;AAAA;AC/BP,IAAAyE,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACeO,MAAMC,KAAmB,MACHvF;AAAA,EACvB,MACG,IAAIC,EAAM,eAAe;AAAA,IACtB,UAAU;AAAA,MACP,UAAU,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,MACvC,OAAO,EAAE,OAAO,EAAI;AAAA,MACpB,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,IAC3C;AAAA,IAAA,cACAW;AAAAA,IAAA,gBACAC;AAAAA,EAAA,CACF;AAAA,EACJ,CAAC;AAAA;AC3BP,IAAA2E,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACeO,MAAMC,KAA8B,MACPzF;AAAA,EAC9B,MACG,IAAIC,EAAM,eAAe;AAAA,IACtB,UAAU;AAAA,MACP,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,MACxC,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,MACxC,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,IAC3C;AAAA,IAAA,cACAW;AAAAA,IAAA,gBACAC;AAAAA,EAAA,CACF;AAAA,EACJ,CAAC;AAAA;AC3BP,IAAA6E,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACkBO,MAAMC,KAAoB,MACR3F;AAAA,EACnB,MACG,IAAIC,EAAM,eAAe;AAAA,IACtB,UAAU;AAAA,MACP,SAAS,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,MACtC,aAAa,EAAE,OAAO,EAAE;AAAA,MACxB,OAAO,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,MACpC,OAAO,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,MACpC,QAAQ,EAAE,OAAO,EAAI;AAAA,MACrB,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,IAC3C;AAAA,IAAA,cACAW;AAAAA,IAAA,gBACAC;AAAAA,EAAA,CACF;AAAA,EACJ,CAAC;AAAA,GCsBMF,KAAU,CAAC;AAAA,EACrB,OAAAR;AAAA,EACA,MAAAP;AAAA,EACA,KAAAC;AACH,MAI0B;AACjB,QAAAO,IAAWJ,EAAQ,MAAM,IAAIC,EAAM,cAAc,GAAG,CAAC,GAAG,CAAA,CAAE,GAC1D2F,IAAkBjB,MAClBkB,IAAiBD,EAAgB,SACjCE,IAAeX,MACfY,IAAoBV,MACpBW,IAAoBnB,MACpBoB,IAAqBlB,MACrBmB,IAAmBjB,MACnBkB,IAAgBZ,MAChBa,IAA2BX,MAC3BY,IAAgBV,MAChBW,IAAYtG;AAAA,IACf,OAAO;AAAA,MACJ,mBAAA+F;AAAA,MACA,cAAAD;AAAA,MACA,mBAAAE;AAAA,MACA,oBAAAC;AAAA,MACA,kBAAAC;AAAA,MACA,eAAAC;AAAA,MACA,0BAAAC;AAAA,MACA,eAAAC;AAAA,IAAA;AAAA,IAEH;AAAA,MACGN;AAAA,MACAD;AAAA,MACAE;AAAA,MACAC;AAAA,MACAC;AAAA,MACAC;AAAA,MACAC;AAAA,MACAC;AAAA,IACH;AAAA,EAAA,GAGGvF,IAAanB,EAAcC,GAAMC,CAAG;AAC1C,EAAAU,EAAU,MAAM;AACb,IAAAC;AAAA,MACG8F,EAAU;AAAA,MACV;AAAA,MACAxF,EAAW,IAAIA,EAAW;AAAA,IAAA;AAE7B,eAAWT,KAAY,OAAO,OAAOiG,CAAS;AAC3C,MAAA9F;AAAA,QACGH;AAAA,QACA;AAAA,QACA,IAAIJ,EAAM,QAAQ,IAAMa,EAAW,GAAG,IAAMA,EAAW,CAAC;AAAA,MAAA;AAAA,EAE9D,GACA,CAACA,GAAYwF,CAAS,CAAC;AAE1B,QAAMhG,IAAOJ,EAAWC,GAAOC,GAAUwF,CAAe;AACxD,EAAArF,EAAU,MAAM;AACb,IAAAqF,EAAgB,QAAQ,GACxBtF,EAAK,WAAWuF;AAAA,EAChB,GAAA,CAACD,GAAiBtF,GAAMuF,CAAc,CAAC;AAE1C,QAAMU,IAAkBrE;AAAA,IACrB,CAAC7B,MAAyB;AACvB,MAAAC,EAAK,WAAWD,GAChBC,EAAK,SAAS,cAAc;AAAA,IAC/B;AAAA,IACA,CAACA,CAAI;AAAA,EAAA;AAGD,SAAA,CAACgG,GAAWC,CAAe;AACrC,GCpFaC,KAA4B;AAAA,EACtC,qBAAqB;AAAA,EACrB,sBAAsB;AAAA,EACtB,uBAAuB;AAAA,EACvB,sBAAsB;AAAA,EACtB,qBAAqB;AAAA,EACrB,eAAe;AAAA,EACf,cAAc;AAAA,EACd,aAAa,IAAIvG,EAAM,QAAQ,GAAK,GAAK,CAAG;AAC/C,GAKawG,KAAW,CAAC;AAAA,EACtB,MAAA7G;AAAA,EACA,KAAAC;AACH,MAG6C;AACpC,QAAAM,IAAQH,EAAQ,MAAM,IAAIC,EAAM,MAAM,GAAG,CAAA,CAAE,GAC3C,CAACqG,GAAWC,CAAe,IAAI5F,GAAQ,EAAE,OAAAR,GAAO,MAAAP,GAAM,KAAAC,EAAA,CAAK,GAC3D8B,IAASL,EAAU1B,CAAI,GACvBoE,IAAgBpB,KAEhB8D,IAAW1G;AAAA,IACd,OAAO;AAAA,MACJ,OAAAG;AAAA,MACA,QAAAwB;AAAA,MACA,MAAA/B;AAAA,MACA,KAAAC;AAAA,IAAA;AAAA,IAEH,CAACM,GAAOwB,GAAQ/B,GAAMC,CAAG;AAAA,EAAA,GAEtB,CAAC8G,GAAaC,CAAiB,IAAItE,EAAaoE,CAAQ,GACxD,CAACG,GAAYC,CAAgB,IAAIxE,EAAaoE,CAAQ,GACtD,CAACK,GAASC,CAAa,IAAItF,EAAagF,CAAQ,GAChD,CAACO,GAAeC,CAAmB,IAAIxF,EAAagF,CAAQ,GAC5D,CAACS,GAAaC,CAAiB,IAAI9E,EAAaoE,CAAQ,GAExDW,IAAWvF,EAAO,CAAC,GACnBwF,IAAgBxF,EAAO,IAAI7B,EAAM,QAAQ,GAAG,CAAC,CAAC,GAC9CsH,IAAWzF,EAAO,IAAI7B,EAAM,QAAQ,GAAG,GAAG,CAAC,CAAC,GAE5C,CAACwD,GAAQE,CAAS,IAAIH,EAAuBgD,EAAY;AAqJxD,SAAA;AAAA,IAnJUtE;AAAA,MACd,CAAC+B,GAAkBL,MAA+B;AAC/C,cAAM,EAAE,IAAAzB,GAAI,SAAA+B,GAAS,OAAAO,GAAO,MAAA7E,EAAS,IAAAqE;AAErC,QAAAL,KAAgBD,EAAUC,CAAY,GAElCyD,EAAS,YAAY,MACbA,EAAA,UAAU5C,EAAM;AAE5B,cAAM+C,IAAK,KAAK;AAAA,WACZ/C,EAAM,eAAA,IAAmB4C,EAAS,WAAW;AAAA,UAC9C;AAAA,QAAA;AAEM,QAAAA,EAAA,UAAU5C,EAAM;AAGzB,cAAMgD,IAAcb,EAAkBzE,GAAI,CAAC,EAAE,MAAAM,QAAW;AACrD,UAAA8D,EAAgBD,EAAU,iBAAiB,GAChC9F,EAAA8F,EAAU,mBAAmB,aAAa7D,CAAI,GAC9CjC,EAAA8F,EAAU,mBAAmB,WAAW7D,CAAI,GAC5CjC,EAAA8F,EAAU,mBAAmB,MAAMkB,CAAE,GAChDhH;AAAA,YACG8F,EAAU;AAAA,YACV;AAAA,YACA7C,EAAO;AAAA,UAAA;AAAA,QACV,CACF,GAGKiE,IAAaZ,EAAiB3E,GAAI,CAAC,EAAE,MAAAM,QAAW;AACnD,UAAA8D,EAAgBD,EAAU,iBAAiB,GAChC9F,EAAA8F,EAAU,mBAAmB,aAAamB,CAAW,GACrDjH,EAAA8F,EAAU,mBAAmB,WAAW7D,CAAI,GACvDjC;AAAA,YACG8F,EAAU;AAAA,YACV;AAAA,YACA7C,EAAO;AAAA,UAAA;AAAA,QACV,CACF,GAGK,EAAE,gBAAAP,GAAgB,aAAAJ,GAAa,kBAAA6E,IAAkB,UAAA3E,OACpDgB,EAAcE,CAAO;AACxB,QAAIyD,OACDf,EAAkBzE,GAAI,CAAC,EAAE,MAAAM,QAAW;AACjC,UAAA8D,EAAgBD,EAAU,aAAa,GAC5B9F,EAAA8F,EAAU,eAAe,WAAW7D,CAAI,GACxCjC,EAAA8F,EAAU,eAAe,SAASpD,CAAc;AAC3D,gBAAM0E,IAAa9E,EAAY;AAAA,YAC5BwE,EAAc,QACV,IAAI1H,EAAK,OAAOA,EAAK,MAAM,EAC3B,eAAe6D,EAAO,qBAAsB;AAAA,UAAA;AAEnD,UAAAjD;AAAA,YACG8F,EAAU;AAAA,YACV;AAAA,YACAiB,EAAS,QAAQ,IAAIK,EAAW,GAAGA,EAAW,GAAG,CAAG;AAAA,UAAA,GAEvDpH;AAAA,YACG8F,EAAU;AAAA,YACV;AAAA,YACA7C,EAAO;AAAA,UAAA;AAAA,QACV,CACF,GACDqD,EAAiB3E,GAAI,CAAC,EAAE,MAAAM,QAAW;AAChC,UAAA8D,EAAgBD,EAAU,aAAa,GAC5B9F,EAAA8F,EAAU,eAAe,WAAW7D,CAAI;AAC7C,gBAAAoF,IACH,OAAOpE,EAAO,eAAgB,aACzBA,EAAO,YAAYT,EAAQ,IAC3BS,EAAO;AACJ,UAAAjD,EAAA8F,EAAU,eAAe,SAASuB,CAAK;AAAA,QAAA,CACpD;AAIE,cAAAC,KAAUd,EAAc7E,GAAI,MAAM;AACrC,UAAAoE,EAAgBD,EAAU,YAAY,GAC3B9F,EAAA8F,EAAU,cAAc,aAAamB,CAAW;AAAA,QAAA,CAC7D;AAGD,QAAAb,EAAkBzE,GAAI,CAAC,EAAE,MAAAM,QAAW;AACjC,UAAA8D,EAAgBD,EAAU,iBAAiB,GAChC9F,EAAA8F,EAAU,mBAAmB,aAAa7D,CAAI,GAC9CjC,EAAA8F,EAAU,mBAAmB,SAASwB,EAAO,GACxDtH;AAAA,YACG8F,EAAU;AAAA,YACV;AAAA,YACA7C,EAAO;AAAA,UAAA,GAECjD,EAAA8F,EAAU,mBAAmB,MAAMkB,CAAE;AAAA,QAAA,CAClD;AAGK,cAAAO,KAAgBb,EAAoB/E,GAAI,MAAM;AACjD,UAAAoE,EAAgBD,EAAU,kBAAkB,GACjC9F,EAAA8F,EAAU,oBAAoB,aAAamB,CAAW;AAAA,QAAA,CACnE;AAGD,QAAAL,EAAkBjF,GAAI,CAAC,EAAE,MAAAM,QAAW;AACjC,UAAA8D,EAAgBD,EAAU,aAAa,GAC5B9F,EAAA8F,EAAU,eAAe,YAAY7D,CAAI,GACpDjC;AAAA,YACG8F,EAAU;AAAA,YACV;AAAA,YACA7C,EAAO;AAAA,UAAA;AAAA,QACV,CACF,GAGD8C,EAAgBD,EAAU,gBAAgB,GAC/B9F,EAAA8F,EAAU,kBAAkB,eAAeyB,EAAa;AAC/D,YAAAC;AACJ,iBAASC,IAAI,GAAGA,IAAIxE,EAAO,qBAAsBwE;AAC9C,UAAAD,IAAkBZ,EAAkBjF,GAAI,CAAC,EAAE,MAAAM,QAAW;AACxC,YAAAjC,EAAA8F,EAAU,kBAAkB,aAAa7D,CAAI;AAAA,UAAA,CAC1D;AAIJ,eAAAmE,EAAkBzE,GAAI,CAAC,EAAE,MAAAM,QAAW;AACjC,UAAA8D,EAAgBD,EAAU,wBAAwB,GAClD9F;AAAA,YACG8F,EAAU;AAAA,YACV;AAAA,YACA0B;AAAA,UAAA,GAEQxH,EAAA8F,EAAU,0BAA0B,aAAa7D,CAAI;AAAA,QAAA,CAClE,GAEMiF;AAAA,MACV;AAAA,MACA;AAAA,QACGpB;AAAA,QACAC;AAAA,QACAS;AAAA,QACAF;AAAA,QACAI;AAAA,QACAlD;AAAA,QACAoD;AAAA,QACAR;AAAA,QACAjD;AAAA,QACAF;AAAA,MACH;AAAA,IAAA;AAAA,IAIAE;AAAA,IACA;AAAA,MACG,OAAAxD;AAAA,MACA,WAAAmG;AAAA,MACA,QAAA3E;AAAA,MACA,cAAc;AAAA,QACX,UAAUgF;AAAA,QACV,SAASE;AAAA,QACT,MAAME;AAAA,QACN,YAAYE;AAAA,QACZ,UAAUE;AAAA,MACb;AAAA,IACH;AAAA,EAAA;AAEN,GCtPaxG,KAAU,CAAC,EAAE,OAAAuH,GAAO,KAAAC,GAAK,SAAAC,GAAS,OAAAjI,QAAyB;AAC/D,QAAAkI,IAAUvG,EAAqB,CAAA,CAAE,GACjC1B,IAAWJ;AAAA,IACd,MAAM,IAAIC,EAAM,cAAciI,GAAOA,CAAK;AAAA,IAC1C,CAACA,CAAK;AAAA,EAAA,GAEH7H,IAAWL;AAAA,IACd,MACG,IAAIC,EAAM,kBAAkB;AAAA,MACzB,KAAKmI,KAAW;AAAA,MAChB,aAAa;AAAA,MACb,UAAUnI,EAAM;AAAA,MAChB,WAAW;AAAA,MACX,YAAY;AAAA,IAAA,CACd;AAAA,IACJ,CAACmI,CAAO;AAAA,EAAA;AAEX,SAAA7H,EAAU,MAAM;AACb,aAAS0H,IAAI,GAAGA,IAAIE,GAAKF,KAAK;AACrB,YAAA3H,IAAO,IAAIL,EAAM,KAAKG,EAAS,SAASC,EAAS,MAAA,CAAO;AAC9D,MAAAC,EAAK,QAAQ,IAAI,KAAK,KAAK,KAAK,QAAQ,GACxCA,EAAK,UAAU,IACfH,EAAM,IAAIG,CAAI,GACN+H,EAAA,QAAQ,KAAK/H,CAAI;AAAA,IAC5B;AAAA,KACA,CAACF,GAAUC,GAAUF,GAAOgI,CAAG,CAAC,GAC5BE,EAAQ;AAClB,GCNaC,KAA8B;AAAA,EACxC,WAAW;AAAA,EACX,UAAU;AAAA,EACV,eAAe;AAAA,EACf,OAAO;AAAA,EACP,OAAO;AACV,GAKaC,KAAY,CAAC;AAAA,EACvB,SAAAH;AAAA,EACA,OAAAF,IAAQ;AAAA,EACR,KAAAC,IAAM;AAAA,EACN,MAAAvI;AACH,MAQ+C;AACtC,QAAAO,IAAQH,EAAQ,MAAM,IAAIC,EAAM,MAAM,GAAG,CAAA,CAAE,GAC3CoI,IAAU1H,GAAQ;AAAA,IACrB,OAAAuH;AAAA,IACA,KAAAC;AAAA,IACA,SAAAC;AAAA,IACA,OAAAjI;AAAA,EAAA,CACF,GACKwB,IAASL,EAAU1B,CAAI,GACvBoE,IAAgBpB,KAChB,CAACf,GAAcI,CAAkB,IAAIP,EAAa;AAAA,IACrD,OAAAvB;AAAA,IACA,QAAAwB;AAAA,IACA,MAAA/B;AAAA,EAAA,CACF,GAEK,CAAC6D,GAAQE,CAAS,IAAIH,EAAwB8E,EAAa,GAE3DE,IAAc1G,EAAO,CAAC;AAsCrB,SAAA;AAAA,IApCUI;AAAA,MACd,CAAC+B,GAAkBL,MAAgC;AAChD,cAAM,EAAE,IAAAzB,GAAI,SAAA+B,GAAS,MAAAtE,MAASqE;AAE9B,QAAAL,KAAgBD,EAAUC,CAAY;AAEtC,cAAM,EAAE,gBAAAV,GAAgB,aAAAJ,EAAY,IAAIkB,EAAcE,CAAO;AAC7D,YAAIT,EAAO,YAAaX,EAAY,OAAA,GAAU;AACrC,gBAAAxC,IAAO+H,EAAQG,EAAY,OAAO;AACxC,UAAAlI,EAAK,UAAU,IACfA,EAAK,SAAS;AAAA,YACX4C,EAAe,KAAKtD,EAAK,QAAQ;AAAA,YACjCsD,EAAe,KAAKtD,EAAK,SAAS;AAAA,YAClC;AAAA,UAAA,GAEHU,EAAK,MAAM,IAAIA,EAAK,MAAM,IAAI,GAC7BA,EAAK,SAAqC,UAAUmD,EAAO,OAChD+E,EAAA,WAAWA,EAAY,UAAU,KAAKL;AAAA,QACrD;AACQ,eAAAE,EAAA,QAAQ,CAAC/H,MAAS;AACvB,cAAIA,EAAK,SAAS;AACf,kBAAMD,IAAWC,EAAK;AACjB,YAAAA,EAAA,SAAS,KAAKmD,EAAO,UAC1BpD,EAAS,WAAWoD,EAAO,eAC3BnD,EAAK,MAAM,IACRmD,EAAO,gBAAiBnD,EAAK,MAAM,IAAImD,EAAO,OAC5CnD,EAAA,MAAM,IAAIA,EAAK,MAAM,GACtBD,EAAS,UAAU,SAAOC,EAAK,UAAU;AAAA,UAChD;AAAA,QAAA,CACF,GAEqB2B,EAAmBE,CAAE;AAAA,MAE9C;AAAA,MACA,CAACF,GAAoBoG,GAASrE,GAAemE,GAAK1E,GAAQE,CAAS;AAAA,IAAA;AAAA,IAInEA;AAAA,IACA;AAAA,MACG,OAAAxD;AAAA,MACA,QAAAwB;AAAA,MACA,SAAA0G;AAAA,MACA,cAAAxG;AAAA,IACH;AAAA,EAAA;AAEN;ACxHA,IAAAnC,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ICAAA,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACwBO,MAAMiB,KAAU,CAAC;AAAA,EACrB,OAAAR;AAAA,EACA,MAAAP;AAAA,EACA,KAAAC;AACH,MAIM;AACG,QAAAO,IAAWJ,EAAQ,MAAM,IAAIC,EAAM,cAAc,GAAG,CAAC,GAAG,CAAA,CAAE,GAC1DI,IAAWL;AAAA,IACd,MACG,IAAIC,EAAM,eAAe;AAAA,MACtB,UAAU;AAAA,QACP,aAAa,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,QAC1C,kBAAkB,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,QAC/C,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,QACxC,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,QACxC,WAAW,EAAE,OAAO,IAAIA,EAAM,UAAU;AAAA,QACxC,eAAe,EAAE,OAAO,EAAI;AAAA,QAC5B,UAAU,EAAE,OAAO,EAAI;AAAA,QACvB,MAAM,EAAE,OAAO,EAAI;AAAA,QACnB,MAAM,EAAE,OAAO,EAAI;AAAA,MACtB;AAAA,MAAA,cACAW;AAAAA,MAAA,gBACAC;AAAAA,IAAA,CACF;AAAA,IACJ,CAAC;AAAA,EAAA,GAGEC,IAAanB,EAAcC,GAAMC,CAAG;AAC1C,SAAAU,EAAU,MAAM;AACb,IAAAF,EAAS,SAAS,YAAY,QAAQS,EAAW,MAAM;AAAA,EAAA,GACvD,CAACA,GAAYT,CAAQ,CAAC,GAEdH,EAAAC,GAAOC,GAAUC,CAAQ,GAE7BA;AACV,GC5BaoI,KAA0C;AAAA,EACpD,UAAU,IAAIxI,EAAM,QAAQ;AAAA,EAC5B,UAAU,IAAIA,EAAM,QAAQ;AAAA,EAC5B,iBAAiB,IAAIA,EAAM,QAAQ,GAAG,CAAC;AAAA,EACvC,WAAW,IAAIA,EAAM,QAAQ;AAAA,EAC7B,eAAe;AAAA,EACf,UAAU;AAAA,EACV,KAAK,IAAIA,EAAM,QAAQ,GAAG,CAAC;AAC9B,GAKayI,KAAkB,CAAC;AAAA,EAC7B,MAAA9I;AAAA,EACA,KAAAC;AACH,MAG2D;AAClD,QAAAM,IAAQH,EAAQ,MAAM,IAAIC,EAAM,MAAM,GAAG,CAAA,CAAE,GAC3CI,IAAWM,GAAQ,EAAE,OAAAR,GAAO,MAAAP,GAAM,KAAAC,GAAK,GACvC8B,IAASL,EAAU1B,CAAI,GACvB,CAACiC,GAAcI,CAAkB,IAAIP,EAAa;AAAA,IACrD,OAAAvB;AAAA,IACA,QAAAwB;AAAA,IACA,KAAA9B;AAAA,IACA,MAAAD;AAAA,IACA,cAAc;AAAA,EAAA,CAChB,GAEK,CAAC6D,GAAQE,CAAS,IACrBH,EAA8BiF,EAAmB;AAsB7C,SAAA;AAAA,IApBUvG;AAAA,MACd,CAAC+B,GAAkBL,MAAsC;AAChD,cAAA,EAAE,IAAAzB,EAAO,IAAA8B;AAEf,eAAAL,KAAgBD,EAAUC,CAAY,GAE3BpD,EAAAH,GAAU,aAAaoD,EAAO,QAAS,GACvCjD,EAAAH,GAAU,aAAaoD,EAAO,QAAS,GACvCjD,EAAAH,GAAU,oBAAoBoD,EAAO,eAAgB,GACrDjD,EAAAH,GAAU,aAAaoD,EAAO,SAAU,GACxCjD,EAAAH,GAAU,iBAAiBoD,EAAO,aAAc,GAChDjD,EAAAH,GAAU,YAAYoD,EAAO,QAAS,GACjDjD,EAAWH,GAAU,QAAQoD,EAAO,IAAK,CAAC,GAC1CjD,EAAWH,GAAU,QAAQoD,EAAO,IAAK,CAAC,GAEpBxB,EAAmBE,CAAE;AAAA,MAE9C;AAAA,MACA,CAACF,GAAoB5B,GAAUoD,GAAQE,CAAS;AAAA,IAAA;AAAA,IAIhDA;AAAA,IACA;AAAA,MACG,OAAAxD;AAAA,MACA,UAAAE;AAAA,MACA,QAAAsB;AAAA,MACA,cAAAE;AAAA,IACH;AAAA,EAAA;AAEN;AClGA,IAAAnC,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ICAAA,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACiBa,MAAAiB,KAAU,CAACR,MAAuB;AACtC,QAAAC,IAAWJ,EAAQ,MAAM,IAAIC,EAAM,cAAc,GAAG,CAAC,GAAG,CAAA,CAAE,GAC1DI,IAAWL;AAAA,IACd,MACG,IAAIC,EAAM,eAAe;AAAA,MACtB,UAAU;AAAA,QACP,OAAO,EAAE,OAAO,EAAI;AAAA,QACpB,cAAc,EAAE,OAAO,EAAI;AAAA,QAC3B,cAAc,EAAE,OAAO,EAAE;AAAA,QACzB,YAAY,EAAE,OAAO,EAAE;AAAA,MAC1B;AAAA,MAAA,cACAW;AAAAA,MAAA,gBACAC;AAAAA,IAAA,CACF;AAAA,IACJ,CAAC;AAAA,EAAA;AAEO,SAAAX,EAAAC,GAAOC,GAAUC,CAAQ,GAC7BA;AACV,GCTasI,KAA4B;AAAA,EACtC,cAAc;AAAA,EACd,cAAc;AAAA,EACd,YAAY;AACf,GAKaC,KAAW,CAAC;AAAA,EACtB,MAAAhJ;AAAA,EACA,KAAAC;AACH,MAG6C;AACpC,QAAAM,IAAQH,EAAQ,MAAM,IAAIC,EAAM,MAAM,GAAG,CAAA,CAAE,GAC3CI,IAAWM,GAAQR,CAAK,GACxBwB,IAASL,EAAU1B,CAAI,GACvB,CAACiC,GAAcI,CAAkB,IAAIP,EAAa;AAAA,IACrD,OAAAvB;AAAA,IACA,QAAAwB;AAAA,IACA,MAAA/B;AAAA,IACA,KAAAC;AAAA,EAAA,CACF,GAEK,CAAC4D,GAAQE,CAAS,IAAIH,EAAuBmF,EAAY;AAmBxD,SAAA;AAAA,IAjBUzG;AAAA,MACd,CAAC+B,GAAkBL,MAA+B;AACzC,cAAA,EAAE,IAAAzB,GAAI,OAAAsC,EAAU,IAAAR;AAEtB,eAAAL,KAAgBD,EAAUC,CAAY,GAE3BpD,EAAAH,GAAU,gBAAgBoD,EAAO,YAAa,GAC9CjD,EAAAH,GAAU,gBAAgBoD,EAAO,YAAa,GAC9CjD,EAAAH,GAAU,cAAcoD,EAAO,UAAW,GAErDjD,EAAWH,GAAU,SAASoE,EAAM,eAAgB,CAAA,GAE7CxC,EAAmBE,CAAE;AAAA,MAC/B;AAAA,MACA,CAACF,GAAoB5B,GAAUsD,GAAWF,CAAM;AAAA,IAAA;AAAA,IAKhDE;AAAA,IACA;AAAA,MACG,OAAAxD;AAAA,MACA,UAAAE;AAAA,MACA,QAAAsB;AAAA,MACA,cAAAE;AAAA,IACH;AAAA,EAAA;AAEN;"}